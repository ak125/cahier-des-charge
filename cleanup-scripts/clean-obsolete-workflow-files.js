/**
 * Script de nettoyage final des fichiers de workflows obsol√®tes
 * 
 * Ce script v√©rifie que tous les workflows standardis√©s fonctionnent correctement,
 * puis supprime les fichiers obsol√®tes si la v√©rification r√©ussit.
 */

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

// Chemins des dossiers et fichiers
const PROJECT_ROOT = '/workspaces/cahier-des-charge';
const BACKUP_DIR = path.join(PROJECT_ROOT, 'backup/obsolete-files-20250505');
const REPORT_DIR = path.join(PROJECT_ROOT, 'cleanup-report');

const OBSOLETE_FILES = [
  // Structure obsol√®te de workflows
  path.join(PROJECT_ROOT, 'packages/business/workflows/temporal'),

  // Anciens workflows AI maintenant consolid√©s
  path.join(PROJECT_ROOT, 'packages/business/temporal/workflows/ai-migration-consolidated.workflow.ts'),
  path.join(PROJECT_ROOT, 'packages/business/temporal/workflows/ai-migration-pipeline.workflow.ts'),

  // Fichiers d'analyse PHP obsol√®tes (ajout√©s depuis cleanup_obsolete_workflows.sh)
  path.join(PROJECT_ROOT, 'packages/business/workflows/01-php-analyzer.json'),
  path.join(PROJECT_ROOT, 'packages/business/workflows/extracted/php-analyzer.json'),
  path.join(PROJECT_ROOT, 'packages/business/workflows/extracted/s-lection-intelligente-des-fichiers-php.json'),
  path.join(PROJECT_ROOT, 'packages/business/config/n8n-php-analyzer-webhook.json'),
  path.join(PROJECT_ROOT, 'packages/business/config/n8n-php-complexity-alerts.json'),
  path.join(PROJECT_ROOT, 'packages/business/config/php-analyzer-pipelinen8n.json'),

  // Fichiers d'audit obsol√®tes (ajout√©s depuis cleanup_obsolete_workflows.sh)
  path.join(PROJECT_ROOT, 'packages/business/workflows/extracted/v-rification-qualit--du-code.json'),
  path.join(PROJECT_ROOT, 'packages/business/workflows/extracted/pipeline-d-audit-multi-agents.json'),
  path.join(PROJECT_ROOT, 'packages/business/workflows/extracted/audit-validator.json'),
  path.join(PROJECT_ROOT, 'packages/business/workflows/extracted/audit-quality-metrics.json'),
  path.join(PROJECT_ROOT, 'packages/business/templates/n8n-audit-workflow.json'),
  path.join(PROJECT_ROOT, 'packages/business/config/n8n-audit-analyzer-workflow.json')
];

// V√©rifiez que les nouveaux workflows standards existent
const STANDARD_WORKFLOWS = [
  path.join(PROJECT_ROOT, 'packages/business/temporal/workflows/php-migration.workflow.ts'),
  path.join(PROJECT_ROOT, 'packages/business/temporal/workflows/ai-migration-standard.workflow.ts')
];

// Dossiers √† exclure lors de la recherche de r√©f√©rences
const EXCLUDE_DIRS = [
  'node_modules',
  'backup',
  'cleanup-scripts',  // Ignorer les r√©f√©rences dans les scripts de nettoyage
];

// Mod√®les √† rechercher dans les fichiers pour v√©rifier les r√©f√©rences r√©siduelles
const PATTERNS_TO_CHECK = [
  // Rechercher des imports ou des r√©f√©rences explicites, en excluant les commentaires
  'import.*from [\'"].*ai-migration-consolidated\\.workflow[\'"]',
  'import.*from [\'"].*ai-migration-pipeline\\.workflow[\'"]',
  'import.*from [\'"].*workflows/temporal/php-migration\\.workflow[\'"]',
  'import.*from [\'"].*business/workflows/temporal/',
  'client\\.workflow\\.start\\([\'"]aiMigrationPipelineWorkflow[\'"]',
  'client\\.workflow\\.start\\([\'"]aiMigrationConsolidatedWorkflow[\'"]',
  'client\\.workflow\\.start\\([\'"]PhpToNestJsMigrationWorkflow[\'"]',
  'workflowType: [\'"]aiMigrationPipelineWorkflow[\'"]',
  'workflowType: [\'"]aiMigrationConsolidatedWorkflow[\'"]',
  'workflowType: [\'"]PhpToNestJsMigrationWorkflow[\'"]',
];

// Patterns √† ignorer car ce sont des faux positifs (noms d'API, variables, etc.)
const IGNORE_PATTERNS = [
  '/ai-migration/',
  'router.post',
  'router.get',
  'aiMigrationRouter',
  'const workflowId = `ai-migration-',
  'const workflowId = `php-',
  'pipelineType',
  ': \'ai-migration\''  // Sp√©cifique √† la variable pipelineType
];

// Fonction pour v√©rifier si un fichier existe
function fileExists(filePath) {
  return fs.existsSync(filePath);
}

// Fonction pour rechercher des motifs dans les fichiers avec une expression r√©guli√®re
function searchPatternsInFiles() {
  console.log('Recherche de r√©f√©rences r√©siduelles aux workflows obsol√®tes...');

  let found = false;
  const excludeDirsArg = EXCLUDE_DIRS.map(dir => `--exclude-dir="${dir}"`).join(' ');

  // Utiliser grep avec des expressions r√©guli√®res pour rechercher les mod√®les
  for (const pattern of PATTERNS_TO_CHECK) {
    try {
      const result = execSync(
        `grep -r -E "${pattern}" --include="*.ts" --include="*.js" ${excludeDirsArg} ${PROJECT_ROOT}`,
        { stdio: ['pipe', 'pipe', 'ignore'] }
      ).toString();

      if (result.trim()) {
        console.log(`‚ö†Ô∏è R√©f√©rences trouv√©es √† "${pattern}":`);
        console.log(result);
        found = true;
      }
    } catch (error) {
      // grep renvoie un code d'erreur si aucune correspondance n'est trouv√©e
      // Nous ignorons cette erreur car c'est le comportement attendu
    }
  }

  // V√©rifier sp√©cifiquement les r√©f√©rences dynamiques qui pourraient √™tre manqu√©es
  try {
    const result = execSync(
      `grep -r "ai-migration" --include="*.ts" --include="*.js" ${excludeDirsArg} ${PROJECT_ROOT} | grep -v "ai-migration-standard"`,
      { stdio: ['pipe', 'pipe', 'ignore'] }
    ).toString();

    // Filtrer les r√©sultats pour exclure les commentaires et les faux positifs
    const lines = result.split('\n').filter(line => {
      // Ignorer les lignes vides ou les commentaires
      if (!line.trim() || line.includes('//') || line.includes('*') || line.includes('cleanup')) {
        return false;
      }

      // Ignorer les faux positifs (noms d'API, variables, etc.)
      return !IGNORE_PATTERNS.some(pattern => line.includes(pattern));
    });

    if (lines.length > 0) {
      console.log(`‚ö†Ô∏è R√©f√©rences potentielles √† d'anciens workflows trouv√©es:`);
      console.log(lines.join('\n'));
      found = true;
    }
  } catch (error) {
    // Ignorer les erreurs de grep
  }

  return found;
}

// Fonction pour v√©rifier les importations statiques
function verifyStandardWorkflows() {
  console.log('V√©rification des workflows standards...');

  // V√©rifier que tous les workflows standards existent
  for (const workflow of STANDARD_WORKFLOWS) {
    if (!fileExists(workflow)) {
      console.error(`‚ùå Workflow standard manquant: ${workflow}`);
      return false;
    }
  }

  return true;
}

// Fonction pour cr√©er une copie de sauvegarde des fichiers
function backupFile(filePath) {
  // Ne pas sauvegarder si le fichier n'existe pas
  if (!fileExists(filePath)) {
    return;
  }

  // Cr√©er le chemin de sauvegarde
  const relativePath = path.relative(PROJECT_ROOT, filePath);
  const backupPath = path.join(BACKUP_DIR, relativePath);

  // Cr√©er les dossiers parents si n√©cessaire
  const backupDir = path.dirname(backupPath);
  if (!fileExists(backupDir)) {
    fs.mkdirSync(backupDir, { recursive: true });
  }

  // Si c'est un dossier, on utilise cp -r
  if (fs.lstatSync(filePath).isDirectory()) {
    try {
      execSync(`cp -r "${filePath}" "${backupPath}"`);
      console.log(`üì¶ Dossier sauvegard√©: ${relativePath}`);
    } catch (error) {
      console.error(`‚ùå Erreur lors de la sauvegarde du dossier ${relativePath}:`, error.message);
    }
  } else {
    // Si c'est un fichier, on utilise fs.copyFileSync
    try {
      fs.copyFileSync(filePath, backupPath);
      console.log(`üì¶ Fichier sauvegard√©: ${relativePath}`);
    } catch (error) {
      console.error(`‚ùå Erreur lors de la sauvegarde du fichier ${relativePath}:`, error.message);
    }
  }
}

// Fonction pour supprimer un fichier ou un dossier
function removeFileOrDir(filePath) {
  // Ne pas supprimer si le fichier n'existe pas
  if (!fileExists(filePath)) {
    return;
  }

  const relativePath = path.relative(PROJECT_ROOT, filePath);

  try {
    // Si c'est un dossier, on utilise rm -rf
    if (fs.lstatSync(filePath).isDirectory()) {
      execSync(`rm -rf "${filePath}"`);
      console.log(`üóëÔ∏è Dossier supprim√©: ${relativePath}`);
    } else {
      // Si c'est un fichier, on utilise fs.unlinkSync
      fs.unlinkSync(filePath);
      console.log(`üóëÔ∏è Fichier supprim√©: ${relativePath}`);
    }
  } catch (error) {
    console.error(`‚ùå Erreur lors de la suppression de ${relativePath}:`, error.message);
  }
}

// Fonction principale
async function main() {
  console.log('=== Script de nettoyage final des workflows obsol√®tes ===');
  console.log('Date: ' + new Date().toISOString());
  console.log('\n1. V√©rification des pr√©requis...');

  // V√©rifier que les dossiers existent
  if (!fileExists(BACKUP_DIR)) {
    fs.mkdirSync(BACKUP_DIR, { recursive: true });
    console.log(`üìÅ Dossier de sauvegarde cr√©√©: ${path.relative(PROJECT_ROOT, BACKUP_DIR)}`);
  }

  if (!fileExists(REPORT_DIR)) {
    fs.mkdirSync(REPORT_DIR, { recursive: true });
    console.log(`üìÅ Dossier de rapport cr√©√©: ${path.relative(PROJECT_ROOT, REPORT_DIR)}`);
  }

  // V√©rifier que les workflows standards existent
  const workflowsExist = verifyStandardWorkflows();
  if (!workflowsExist) {
    console.error('\n‚ùå Les workflows standards n\'existent pas ou sont incomplets.');
    console.error('Veuillez ex√©cuter les scripts de standardisation et consolidation d\'abord.');
    process.exit(1);
  }

  console.log('‚úÖ Les workflows standards existent.');

  // V√©rifier s'il reste des r√©f√©rences aux anciens workflows
  console.log('\n2. V√©rification des r√©f√©rences aux anciens workflows...');
  const referencesFound = searchPatternsInFiles();

  if (referencesFound) {
    console.error('\n‚ö†Ô∏è Des r√©f√©rences aux anciens workflows ont √©t√© trouv√©es.');
    console.error('Veuillez mettre √† jour ces r√©f√©rences avant de continuer.');

    // √âcrire un rapport des r√©f√©rences trouv√©es
    const reportPath = path.join(REPORT_DIR, 'references-obsoletes.md');
    fs.writeFileSync(reportPath, `# R√©f√©rences obsol√®tes trouv√©es\n\nDate: ${new Date().toISOString()}\n\nDes r√©f√©rences aux anciens workflows ont √©t√© trouv√©es. Veuillez les mettre √† jour avant de continuer.\n\n`);

    console.log(`Rapport de r√©f√©rences obsol√®tes cr√©√©: ${path.relative(PROJECT_ROOT, reportPath)}`);
    process.exit(1);
  }

  console.log('‚úÖ Aucune r√©f√©rence importante aux anciens workflows n\'a √©t√© trouv√©e.');

  // Demander confirmation avant de continuer
  console.log('\n3. Sauvegarde des fichiers obsol√®tes...');

  // Sauvegarder tous les fichiers obsol√®tes
  for (const file of OBSOLETE_FILES) {
    backupFile(file);
  }

  console.log('\n4. Suppression des fichiers obsol√®tes...');

  // Mode simulation par d√©faut sauf si --force est sp√©cifi√©
  const isForced = process.argv.includes('--force');

  if (!isForced) {
    console.log('\n‚ö†Ô∏è Mode simulation activ√©: aucun fichier ne sera supprim√©.');
    console.log('Pour supprimer r√©ellement les fichiers, ex√©cutez avec l\'option --force');
    console.log('Exemple: node cleanup-scripts/clean-obsolete-workflow-files.js --force');

    // Liste des fichiers qui seraient supprim√©s
    console.log('\nFichiers qui seraient supprim√©s:');
    for (const file of OBSOLETE_FILES) {
      if (fileExists(file)) {
        console.log(`- ${path.relative(PROJECT_ROOT, file)}`);
      }
    }
  } else {
    // Supprimer tous les fichiers obsol√®tes
    for (const file of OBSOLETE_FILES) {
      removeFileOrDir(file);
    }

    console.log('\n‚úÖ Nettoyage termin√© avec succ√®s!');
    console.log('Les fichiers obsol√®tes ont √©t√© supprim√©s et sauvegard√©s dans le dossier backup.');

    // Cr√©er un rapport de nettoyage
    const reportPath = path.join(REPORT_DIR, 'rapport-nettoyage-workflows.md');
    fs.writeFileSync(reportPath, `# Rapport de nettoyage des workflows obsol√®tes\n\nDate: ${new Date().toISOString()}\n\nLe nettoyage des workflows a √©t√© effectu√© avec succ√®s. Les fichiers suivants ont √©t√© supprim√©s et sauvegard√©s dans le dossier backup:\n\n${OBSOLETE_FILES.map(f => `- ${path.relative(PROJECT_ROOT, f)}`).join('\n')}\n\n`);

    console.log(`Rapport de nettoyage cr√©√©: ${path.relative(PROJECT_ROOT, reportPath)}`);
  }
}

main().catch(error => {
  console.error('Une erreur est survenue:', error);
  process.exit(1);
});