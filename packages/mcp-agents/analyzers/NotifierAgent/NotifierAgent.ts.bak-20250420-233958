/**
 * MCP Notifier - Syst√®me de notification pour les migrations PHP vers Remix
 * 
 * Ce module √©coute les √©v√©nements Redis et Supabase pour envoyer des notifications
 * via diff√©rents canaux (Slack, Email, Discord, Webhook) lors d'√©v√©nements importants
 * dans le pipeline de migration.
 */

import { createClient as createRedisClient } from 'redis';
import { createClient as createSupabaseClient } from '@supabase/supabase-js';
import axios from 'axios';
import nodemailer from 'nodemailer';
import { WebClient } from '@slack/web-api';
import fs from 'fs-extra';
import path from 'path';
import { Logger } from '@nestjs/common';
import { MCPManifestManager } from './mcp-manifest-manager';
import { BaseAgent, OrchestrationAgent } from '../core/interfaces/base-agent';


// Types
export interface NotifierConfig {
  redis: {
    url: string;
    enabled: boolean;
    channels: string[];
  };
  supabase: {
    url: string;
    key: string;
    enabled: boolean;
    tables: string[];
  };
  slack: {
    token: string;
    enabled: boolean;
    defaultChannel: string;
    mentionUsers?: string[];
    events: string[];
  };
  email: {
    smtp: {
      host: string;
      port: number;
      secure: boolean;
      auth: {
        user: string;
        pass: string;
      }
    };
    enabled: boolean;
    defaultRecipients: string[];
    events: string[];
  };
  discord: {
    webhook: string;
    enabled: boolean;
    events: string[];
  };
  webhook: {
    url: string;
    enabled: boolean;
    events: string[];
  };
  manifestPath: string;
}

export interface NotificationEvent {
  type: string;
  migrationId?: string;
  sourceFile?: string;
  targetFiles?: Record<string, string>;
  status?: string;
  qaStatus?: string;
  seoStatus?: string;
  score?: number;
  message?: string;
  error?: any;
  prUrl?: string;
  timestamp: string;
  tags?: string[];
}

/**
 * Classe principale de notification
 */
export class MCPNotifier implements BaseAgent, OrchestrationAgent , BusinessAgent, AnalyzerAgent{
  private logger = new Logger('MCPNotifier');
  private redisClient: any;
  private supabaseClient: any;
  private slackClient: any;
  private emailTransporter: any;
  private config: NotifierConfig;
  private manifest: MCPManifestManager;
  
  constructor(config: NotifierConfig) {
    this.config = config;
    this.manifest = new MCPManifestManager(config.manifestPath);
    this.initialize();
  }
  
  /**
   * Initialise les clients et connexions
   */
  private async initialize() {
    try {
      // Initialiser Redis si activ√©
      if (this.config.redis.enabled) {
        this.redisClient = createRedisClient({
          url: this.config.redis.url
        });
        
        await this.redisClient.connect();
        this.logger.log('üîå Connexion √† Redis √©tablie');
        
        // S'abonner aux canaux Redis
        for (const channel of this.config.redis.channels) {
          await this.redisClient.subscribe(channel, (message: string) => {
            this.handleRedisMessage(channel, message);
          });
          this.logger.log(`üìª Abonnement au canal Redis: ${channel}`);
        }
      }
      
      // Initialiser Supabase si activ√©
      if (this.config.supabase.enabled) {
        this.supabaseClient = createSupabaseClient(
          this.config.supabase.url,
          this.config.supabase.key
        );
        
        // Configurer les abonnements Supabase
        for (const table of this.config.supabase.tables) {
          this.supabaseClient
            .channel('notifier-channel')
            .on(
              'postgres_changes',
              { event: '*', schema: 'public', table },
              (payload: any) => this.handleSupabaseChange(table, payload)
            )
            .subscribe();
          
          this.logger.log(`üìª Abonnement √† la table Supabase: ${table}`);
        }
        
        this.logger.log('üîå Connexion √† Supabase √©tablie');
      }
      
      // Initialiser Slack si activ√©
      if (this.config.slack.enabled) {
        this.slackClient = new WebClient(this.config.slack.token);
        this.logger.log('üîå Client Slack initialis√©');
      }
      
      // Initialiser le transporteur d'email si activ√©
      if (this.config.email.enabled) {
        this.emailTransporter = nodemailer.createTransport(this.config.email.smtp);
        this.logger.log('üîå Transporteur Email initialis√©');
      }
      
      this.logger.log('‚úÖ MCPNotifier initialis√© avec succ√®s');
    } catch (error: any) {
      this.logger.error(`‚ùå Erreur lors de l'initialisation de MCPNotifier: ${error.message}`);
      throw error;
    }
  }
  
  /**
   * Traite les messages Redis
   */
  private async handleRedisMessage(channel: string, message: string) {
    try {
      const event = JSON.parse(message) as NotificationEvent;
      this.logger.log(`üì® Message re√ßu sur le canal ${channel}: ${event.type}`);
      
      // Mettre √† jour le manifeste si n√©cessaire
      if (event.migrationId) {
        await this.updateManifest(event);
      }
      
      // Envoyer les notifications
      await this.sendNotifications(event);
    } catch (error: any) {
      this.logger.error(`‚ùå Erreur lors du traitement du message Redis: ${error.message}`);
    }
  }
  
  /**
   * Traite les changements Supabase
   */
  private async handleSupabaseChange(table: string, payload: any) {
    try {
      const { eventType, new: newRecord, old: oldRecord } = payload;
      this.logger.log(`üì® Changement Supabase dans la table ${table}: ${eventType}`);
      
      // Convertir le changement Supabase en √©v√©nement de notification
      const event: NotificationEvent = {
        type: `${table}:${eventType}`,
        timestamp: new Date().toISOString()
      };
      
      // Ajouter les donn√©es sp√©cifiques en fonction de la table
      if (table === 'audit.migrations') {
        event.migrationId = newRecord.migration_id;
        event.sourceFile = newRecord.source_file;
        event.targetFiles = newRecord.target_files;
        event.status = newRecord.status;
        event.qaStatus = newRecord.qa_status;
        event.seoStatus = newRecord.seo_status;
        event.prUrl = newRecord.pr_url;
        event.tags = newRecord.tags;
        
        // D√©tecter les changements de statut
        if (oldRecord && newRecord.status !== oldRecord.status) {
          event.type = `migration:${newRecord.status}`;
        }
      } else if (table === 'audit.qa_results') {
        event.migrationId = newRecord.migration_id;
        event.sourceFile = newRecord.source_file;
        event.qaStatus = newRecord.status;
        event.score = newRecord.score;
        event.tags = newRecord.tags;
        
        event.type = `qa:${newRecord.status.toLowerCase()}`;
      }
      
      // Mettre √† jour le manifeste si n√©cessaire
      if (event.migrationId) {
        await this.updateManifest(event);
      }
      
      // Envoyer les notifications
      await this.sendNotifications(event);
    } catch (error: any) {
      this.logger.error(`‚ùå Erreur lors du traitement du changement Supabase: ${error.message}`);
    }
  }
  
  /**
   * Met √† jour le manifest MCPManifest.json
   */
  private async updateManifest(event: NotificationEvent) {
    try {
      if (!event.migrationId) return;
      
      await this.manifest.load();
      
      // Trouver la migration dans le manifeste
      const migration = this.manifest.getMigration(event.migrationId);
      
      if (!migration) {
        this.logger.warn(`‚ö†Ô∏è Migration ${event.migrationId} non trouv√©e dans le manifeste`);
        return;
      }
      
      // Mettre √† jour les champs pertinents
      let updated = false;
      
      if (event.status && migration.status !== event.status) {
        migration.status = event.status;
        if (event.status === 'completed') {
          migration.completedAt = new Date().toISOString();
        }
        updated = true;
      }
      
      if (event.qaStatus && migration.qaStatus !== event.qaStatus) {
        migration.qaStatus = event.qaStatus;
        updated = true;
      }
      
      if (event.seoStatus && migration.seoStatus !== event.seoStatus) {
        migration.seoStatus = event.seoStatus;
        updated = true;
      }
      
      if (event.prUrl && migration.prUrl !== event.prUrl) {
        migration.prUrl = event.prUrl;
        updated = true;
      }
      
      // Mettre √† jour les tags
      if (event.tags && event.tags.length > 0) {
        const currentTags = new Set(migration.tags || []);
        for (const tag of event.tags) {
          if (!currentTags.has(tag)) {
            migration.tags = migration.tags || [];
            migration.tags.push(tag);
            updated = true;
          }
        }
      }
      
      // Ajouter une √©tape de v√©rification si c'est une mise √† jour de QA
      if (event.type.startsWith('qa:')) {
        const step = {
          name: 'qa-analyzer',
          status: event.qaStatus === 'OK' ? 'passed' : event.qaStatus === 'Partial' ? 'partial' : 'failed',
          score: event.score
        };
        
        migration.verificationSteps = migration.verificationSteps || [];
        
        // Remplacer l'√©tape existante ou ajouter une nouvelle
        const existingStepIndex = migration.verificationSteps.findIndex(s => s.name === 'qa-analyzer');
        if (existingStepIndex >= 0) {
          migration.verificationSteps[existingStepIndex] = step;
        } else {
          migration.verificationSteps.push(step);
        }
        
        updated = true;
      }
      
      // Sauvegarder le manifeste si des modifications ont √©t√© effectu√©es
      if (updated) {
        // Mettre √† jour les m√©tadonn√©es
        this.manifest.updateMetadata();
        await this.manifest.save();
        this.logger.log(`‚úÖ Manifest mis √† jour pour la migration ${event.migrationId}`);
      }
    } catch (error: any) {
      this.logger.error(`‚ùå Erreur lors de la mise √† jour du manifeste: ${error.message}`);
    }
  }
  
  /**
   * Envoie des notifications sur les diff√©rents canaux
   */
  private async sendNotifications(event: NotificationEvent) {
    // V√©rifier si l'√©v√©nement doit d√©clencher des notifications
    
    // Slack
    if (this.shouldNotify('slack', event.type)) {
      await this.sendSlackNotification(event);
    }
    
    // Email
    if (this.shouldNotify('email', event.type)) {
      await this.sendEmailNotification(event);
    }
    
    // Discord
    if (this.shouldNotify('discord', event.type)) {
      await this.sendDiscordNotification(event);
    }
    
    // Webhook
    if (this.shouldNotify('webhook', event.type)) {
      await this.sendWebhookNotification(event);
    }
  }
  
  /**
   * V√©rifie si une notification doit √™tre envoy√©e pour un canal et un type d'√©v√©nement
   */
  private shouldNotify(channel: string, eventType: string): boolean {
    const config = this.config[channel as keyof NotifierConfig] as any;
    
    if (!config || !config.enabled) {
      return false;
    }
    
    // Si aucun √©v√©nement n'est sp√©cifi√©, notifier pour tout
    if (!config.events || config.events.length === 0) {
      return true;
    }
    
    // V√©rifier si l'√©v√©nement correspond √† un pattern dans la liste
    return config.events.some((pattern: string) => {
      // Support des wildcards, ex: 'migration:*'
      if (pattern.endsWith('*')) {
        const prefix = pattern.slice(0, -1);
        return eventType.startsWith(prefix);
      }
      
      return pattern === eventType;
    });
  }
  
  /**
   * Envoie une notification Slack
   */
  private async sendSlackNotification(event: NotificationEvent) {
    if (!this.slackClient) return;
    
    try {
      const channel = this.config.slack.defaultChannel;
      const message = this.formatSlackMessage(event);
      
      await this.slackClient.chat.postMessage({
        channel,
        text: message.text,
        blocks: message.blocks,
        unfurl_links: false
      });
      
      this.logger.log(`‚úÖ Notification Slack envoy√©e: ${event.type}`);
    } catch (error: any) {
      this.logger.error(`‚ùå Erreur lors de l'envoi de la notification Slack: ${error.message}`);
    }
  }
  
  /**
   * Formate un message Slack avec mise en forme riche
   */
  private formatSlackMessage(event: NotificationEvent): { text: string; blocks: any[] } {
    let icon, title;
    
    // D√©terminer l'ic√¥ne et le titre en fonction du type d'√©v√©nement
    if (event.type.includes('completed')) {
      icon = 'üöÄ';
      title = 'MIGRATION R√âUSSIE';
    } else if (event.type.includes('partial')) {
      icon = '‚ö†Ô∏è';
      title = 'MIGRATION PARTIELLE';
    } else if (event.type.includes('failed')) {
      icon = '‚ùå';
      title = 'MIGRATION √âCHOU√âE';
    } else if (event.type.includes('qa:ok')) {
      icon = '‚úÖ';
      title = 'QA VALID√âE';
    } else if (event.type.includes('qa:partial')) {
      icon = '‚ö†Ô∏è';
      title = 'QA PARTIELLEMENT VALID√âE';
    } else if (event.type.includes('qa:failed')) {
      icon = '‚ùå';
      title = 'QA √âCHOU√âE';
    } else {
      icon = 'üîî';
      title = 'NOTIFICATION MCP';
    }
    
    // Obtenir le nom du fichier √† partir du chemin complet
    const sourceFileName = event.sourceFile ? path.basename(event.sourceFile) : 'N/A';
    const targetFileNames = event.targetFiles ? Object.values(event.targetFiles).map(f => path.basename(f)) : [];
    
    // Texte de base (fallback pour les clients qui ne supportent pas les blocs)
    const text = `${icon} ${title} : ${sourceFileName} ‚Üí ${targetFileNames.join(', ')}`;
    
    // Construire les blocs riches pour Slack
    const blocks = [
      {
        type: 'header',
        text: {
          type: 'plain_text',
          text: `${icon} ${title} : ${sourceFileName}`,
          emoji: true
        }
      },
      {
        type: 'section',
        fields: [
          {
            type: 'mrkdwn',
            text: `*Source:*\n\`${sourceFileName}\``
          }
        ]
      }
    ];
    
    // Ajouter les fichiers cibles s'ils existent
    if (targetFileNames.length > 0) {
      blocks.push({
        type: 'section',
        fields: [
          {
            type: 'mrkdwn',
            text: `*Composants:*\n${targetFileNames.map(f => `\`${f}\``).join(', ')}`
          }
        ]
      });
    }
    
    // Ajouter les statuts QA et SEO s'ils existent
    const statusFields = [];
    
    if (event.qaStatus) {
      let qaIcon;
      switch (event.qaStatus) {
        case 'OK': qaIcon = '‚úÖ'; break;
        case 'Partial': qaIcon = '‚ö†Ô∏è'; break;
        case 'Failed': qaIcon = '‚ùå'; break;
        default: qaIcon = '‚ùî';
      }
      statusFields.push({
        type: 'mrkdwn',
        text: `*QA:* ${qaIcon} ${event.qaStatus}`
      });
    }
    
    if (event.seoStatus) {
      let seoIcon;
      switch (event.seoStatus) {
        case 'OK': seoIcon = '‚úÖ'; break;
        case 'Partial': seoIcon = '‚ö†Ô∏è'; break;
        case 'Failed': seoIcon = '‚ùå'; break;
        default: seoIcon = '‚ùî';
      }
      statusFields.push({
        type: 'mrkdwn',
        text: `*SEO:* ${seoIcon} ${event.seoStatus}`
      });
    }
    
    if (statusFields.length > 0) {
      blocks.push({
        type: 'section',
        fields: statusFields
      });
    }
    
    // Ajouter le score QA s'il existe
    if (event.score !== undefined) {
      blocks.push({
        type: 'section',
        fields: [
          {
            type: 'mrkdwn',
            text: `*Score QA:* ${event.score}/100`
          }
        ]
      });
    }
    
    // Ajouter l'URL de la PR si elle existe
    if (event.prUrl) {
      blocks.push({
        type: 'section',
        fields: [
          {
            type: 'mrkdwn',
            text: `*PR:* <${event.prUrl}|Voir la Pull Request>`
          }
        ]
      });
    }
    
    // Ajouter l'erreur si elle existe
    if (event.error) {
      let errorMessage;
      if (typeof event.error === 'string') {
        errorMessage = event.error;
      } else if (event.error.message) {
        errorMessage = event.error.message;
      } else {
        errorMessage = JSON.stringify(event.error);
      }
      
      blocks.push({
        type: 'section',
        text: {
          type: 'mrkdwn',
          text: `*Erreur:*\n\`\`\`${errorMessage}\`\`\``
        }
      });
    }
    
    // Ajouter les tags s'ils existent
    if (event.tags && event.tags.length > 0) {
      blocks.push({
        type: 'context',
        elements: [
          {
            type: 'mrkdwn',
            text: `*Tags:* ${event.tags.join(', ')}`
          }
        ]
      });
    }
    
    // Ajouter la mention aux utilisateurs si configur√©e
    if (this.config.slack.mentionUsers && this.config.slack.mentionUsers.length > 0) {
      blocks.push({
        type: 'section',
        text: {
          type: 'mrkdwn',
          text: `${this.config.slack.mentionUsers.map(user => `<@${user}>`).join(' ')}`
        }
      });
    }
    
    return { text, blocks };

  id: string = '';
  type: string = '';
  version: string = '1.0.0';

  /**
   * Indique si l'agent est pr√™t √† √™tre utilis√©
   */
  isReady(): boolean {
    return true;
  }

  /**
   * Arr√™te et nettoie l'agent
   */
  async shutdown(): Promise<void> {
    console.log(`[${this.name}] Arr√™t...`);
  }

  /**
   * R√©cup√®re les m√©tadonn√©es de l'agent
   */
  getMetadata(): Record<string, any> {
    return {
      id: this.id,
      name: this.name,
      type: this.type,
      version: this.version
    };
  }

  /**
   * R√©cup√®re l'√©tat actuel du syst√®me
   */
  async getSystemState(): Promise<Record<string, any>> {
    return {
      status: 'active',
      timestamp: new Date().toISOString()
    };
  }
  }
  
  /**
   * Envoie une notification par email
   */
  private async sendEmailNotification(event: NotificationEvent) {
    if (!this.emailTransporter) return;
    
    try {
      const recipients = this.config.email.defaultRecipients;
      const subject = this.formatEmailSubject(event);
      const html = this.formatEmailBody(event);
      
      await this.emailTransporter.sendMail({
        from: this.config.email.smtp.auth.user,
        to: recipients.join(', '),
        subject,
        html
      });
      
      this.logger.log(`‚úÖ Notification email envoy√©e: ${event.type}`);
    } catch (error: any) {
      this.logger.error(`‚ùå Erreur lors de l'envoi de la notification email: ${error.message}`);
    }
  }
  
  /**
   * Formate l'objet de l'email
   */
  private formatEmailSubject(event: NotificationEvent): string {
    let prefix;
    
    // D√©terminer le pr√©fixe en fonction du type d'√©v√©nement
    if (event.type.includes('completed')) {
      prefix = '[MCP] ‚úÖ Migration r√©ussie';
    } else if (event.type.includes('partial')) {
      prefix = '[MCP] ‚ö†Ô∏è Migration partielle';
    } else if (event.type.includes('failed')) {
      prefix = '[MCP] ‚ùå Migration √©chou√©e';
    } else if (event.type.includes('qa:ok')) {
      prefix = '[MCP] ‚úÖ QA valid√©e';
    } else if (event.type.includes('qa:partial')) {
      prefix = '[MCP] ‚ö†Ô∏è QA partiellement valid√©e';
    } else if (event.type.includes('qa:failed')) {
      prefix = '[MCP] ‚ùå QA √©chou√©e';
    } else {
      prefix = '[MCP] Notification';
    }
    
    // Obtenir le nom du fichier √† partir du chemin complet
    const sourceFileName = event.sourceFile ? path.basename(event.sourceFile) : 'N/A';
    
    return `${prefix} : ${sourceFileName}`;
  }
  
  /**
   * Formate le corps de l'email en HTML
   */
  private formatEmailBody(event: NotificationEvent): string {
    // Obtenir le nom du fichier √† partir du chemin complet
    const sourceFileName = event.sourceFile ? path.basename(event.sourceFile) : 'N/A';
    const targetFileNames = event.targetFiles ? Object.values(event.targetFiles).map(f => path.basename(f)) : [];
    
    let html = `
      <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
        <h1 style="color: #333; border-bottom: 1px solid #ddd; padding-bottom: 10px;">
    `;
    
    // D√©terminer l'ic√¥ne et le titre en fonction du type d'√©v√©nement
    if (event.type.includes('completed')) {
      html += `üöÄ Migration r√©ussie : ${sourceFileName}`;
    } else if (event.type.includes('partial')) {
      html += `‚ö†Ô∏è Migration partielle : ${sourceFileName}`;
    } else if (event.type.includes('failed')) {
      html += `‚ùå Migration √©chou√©e : ${sourceFileName}`;
    } else if (event.type.includes('qa:ok')) {
      html += `‚úÖ QA valid√©e : ${sourceFileName}`;
    } else if (event.type.includes('qa:partial')) {
      html += `‚ö†Ô∏è QA partiellement valid√©e : ${sourceFileName}`;
    } else if (event.type.includes('qa:failed')) {
      html += `‚ùå QA √©chou√©e : ${sourceFileName}`;
    } else {
      html += `üîî Notification MCP : ${sourceFileName}`;
    }
    
    html += `
        </h1>
        <div style="margin-bottom: 20px;">
          <p><strong>Source :</strong> ${sourceFileName}</p>
    `;
    
    // Ajouter les fichiers cibles s'ils existent
    if (targetFileNames.length > 0) {
      html += `
          <p><strong>Composants :</strong> ${targetFileNames.join(', ')}</p>
      `;
    }
    
    // Ajouter les statuts QA et SEO s'ils existent
    if (event.qaStatus) {
      let qaIcon;
      switch (event.qaStatus) {
        case 'OK': qaIcon = '‚úÖ'; break;
        case 'Partial': qaIcon = '‚ö†Ô∏è'; break;
        case 'Failed': qaIcon = '‚ùå'; break;
        default: qaIcon = '‚ùî';
      }
      html += `
          <p><strong>QA :</strong> ${qaIcon} ${event.qaStatus}</p>
      `;
    }
    
    if (event.seoStatus) {
      let seoIcon;
      switch (event.seoStatus) {
        case 'OK': seoIcon = '‚úÖ'; break;
        case 'Partial': seoIcon = '‚ö†Ô∏è'; break;
        case 'Failed': seoIcon = '‚ùå'; break;
        default: seoIcon = '‚ùî';
      }
      html += `
          <p><strong>SEO :</strong> ${seoIcon} ${event.seoStatus}</p>
      `;
    }
    
    // Ajouter le score QA s'il existe
    if (event.score !== undefined) {
      html += `
          <p><strong>Score QA :</strong> ${event.score}/100</p>
      `;
    }
    
    // Ajouter l'URL de la PR si elle existe
    if (event.prUrl) {
      html += `
          <p><strong>PR :</strong> <a href="${event.prUrl}" target="_blank">Voir la Pull Request</a></p>
      `;
    }
    
    html += `
        </div>
    `;
    
    // Ajouter l'erreur si elle existe
    if (event.error) {
      let errorMessage;
      if (typeof event.error === 'string') {
        errorMessage = event.error;
      } else if (event.error.message) {
        errorMessage = event.error.message;
      } else {
        errorMessage = JSON.stringify(event.error);
      }
      
      html += `
        <div style="margin-bottom: 20px; background-color: #f8d7da; padding: 15px; border-radius: 5px; color: #721c24;">
          <h3 style="margin-top: 0;">Erreur</h3>
          <pre style="background-color: #f5f5f5; padding: 10px; border-radius: 3px; white-space: pre-wrap;">${errorMessage}</pre>
        </div>
      `;
    }
    
    // Ajouter les tags s'ils existent
    if (event.tags && event.tags.length > 0) {
      html += `
        <div style="margin-top: 20px;">
          <p><strong>Tags :</strong> ${event.tags.join(', ')}</p>
        </div>
      `;
    }
    
    html += `
        <div style="margin-top: 30px; font-size: 12px; color: #777; border-top: 1px solid #ddd; padding-top: 10px;">
          <p>Cet email a √©t√© envoy√© automatiquement par le syst√®me MCP (Model Context Protocol).</p>
          <p>Date : ${new Date().toLocaleString()}</p>
        </div>
      </div>
    `;
    
    return html;
  }
  
  /**
   * Envoie une notification Discord
   */
  private async sendDiscordNotification(event: NotificationEvent) {
    if (!this.config.discord.enabled || !this.config.discord.webhook) return;
    
    try {
      const { embeds, content } = this.formatDiscordMessage(event);
      
      await axios.post(this.config.discord.webhook, {
        content,
        embeds,
        username: 'MCP Notifier',
        avatar_url: 'https://remix.run/img/og.1.jpg' // Logo Remix
      });
      
      this.logger.log(`‚úÖ Notification Discord envoy√©e: ${event.type}`);
    } catch (error: any) {
      this.logger.error(`‚ùå Erreur lors de l'envoi de la notification Discord: ${error.message}`);
    }
  }
  
  /**
   * Formate un message Discord avec embeds
   */
  private formatDiscordMessage(event: NotificationEvent): { content: string; embeds: any[] } {
    let color, title, emoji;
    
    // D√©terminer la couleur et le titre en fonction du type d'√©v√©nement
    if (event.type.includes('completed')) {
      color = 0x4CAF50; // Vert
      title = 'MIGRATION R√âUSSIE';
      emoji = 'üöÄ';
    } else if (event.type.includes('partial')) {
      color = 0xFFC107; // Jaune
      title = 'MIGRATION PARTIELLE';
      emoji = '‚ö†Ô∏è';
    } else if (event.type.includes('failed')) {
      color = 0xF44336; // Rouge
      title = 'MIGRATION √âCHOU√âE';
      emoji = '‚ùå';
    } else if (event.type.includes('qa:ok')) {
      color = 0x4CAF50; // Vert
      title = 'QA VALID√âE';
      emoji = '‚úÖ';
    } else if (event.type.includes('qa:partial')) {
      color = 0xFFC107; // Jaune
      title = 'QA PARTIELLEMENT VALID√âE';
      emoji = '‚ö†Ô∏è';
    } else if (event.type.includes('qa:failed')) {
      color = 0xF44336; // Rouge
      title = 'QA √âCHOU√âE';
      emoji = '‚ùå';
    } else {
      color = 0x2196F3; // Bleu
      title = 'NOTIFICATION MCP';
      emoji = 'üîî';
    }
    
    // Obtenir le nom du fichier √† partir du chemin complet
    const sourceFileName = event.sourceFile ? path.basename(event.sourceFile) : 'N/A';
    const targetFileNames = event.targetFiles ? Object.values(event.targetFiles).map(f => path.basename(f)) : [];
    
    // Texte de base
    const content = `${emoji} **${title}** : ${sourceFileName}`;
    
    // Construire l'embed
    const embed = {
      color,
      title: `${emoji} ${title} : ${sourceFileName}`,
      timestamp: new Date().toISOString(),
      fields: [
        {
          name: 'Source',
          value: `\`${sourceFileName}\``,
          inline: true
        }
      ],
      footer: {
        text: 'MCP Notifier'
      }
    };
    
    // Ajouter les fichiers cibles s'ils existent
    if (targetFileNames.length > 0) {
      embed.fields.push({
        name: 'Composants',
        value: targetFileNames.map(f => `\`${f}\``).join(', '),
        inline: true
      });
    }
    
    // Ajouter les statuts QA et SEO s'ils existent
    if (event.qaStatus) {
      let qaIcon;
      switch (event.qaStatus) {
        case 'OK': qaIcon = '‚úÖ'; break;
        case 'Partial': qaIcon = '‚ö†Ô∏è'; break;
        case 'Failed': qaIcon = '‚ùå'; break;
        default: qaIcon = '‚ùî';
      }
      embed.fields.push({
        name: 'QA',
        value: `${qaIcon} ${event.qaStatus}`,
        inline: true
      });
    }
    
    if (event.seoStatus) {
      let seoIcon;
      switch (event.seoStatus) {
        case 'OK': seoIcon = '‚úÖ'; break;
        case 'Partial': seoIcon = '‚ö†Ô∏è'; break;
        case 'Failed': seoIcon = '‚ùå'; break;
        default: seoIcon = '‚ùî';
      }
      embed.fields.push({
        name: 'SEO',
        value: `${seoIcon} ${event.seoStatus}`,
        inline: true
      });
    }
    
    // Ajouter le score QA s'il existe
    if (event.score !== undefined) {
      embed.fields.push({
        name: 'Score QA',
        value: `${event.score}/100`,
        inline: true
      });
    }
    
    // Ajouter l'URL de la PR si elle existe
    if (event.prUrl) {
      embed.fields.push({
        name: 'PR',
        value: `[Voir la Pull Request](${event.prUrl})`,
        inline: true
      });
    }
    
    // Ajouter l'erreur si elle existe
    if (event.error) {
      let errorMessage;
      if (typeof event.error === 'string') {
        errorMessage = event.error;
      } else if (event.error.message) {
        errorMessage = event.error.message;
      } else {
        errorMessage = JSON.stringify(event.error);
      }
      
      embed.fields.push({
        name: 'Erreur',
        value: `\`\`\`${errorMessage}\`\`\``,
        inline: false
      });
    }
    
    // Ajouter les tags s'ils existent
    if (event.tags && event.tags.length > 0) {
      embed.fields.push({
        name: 'Tags',
        value: event.tags.join(', '),
        inline: false
      });
    }
    
    return { content, embeds: [embed] };
  }
  
  /**
   * Envoie une notification webhook
   */
  private async sendWebhookNotification(event: NotificationEvent) {
    if (!this.config.webhook.enabled || !this.config.webhook.url) return;
    
    try {
      await axios.post(this.config.webhook.url, {
        event: event.type,
        data: event,
        timestamp: new Date().toISOString()
      });
      
      this.logger.log(`‚úÖ Notification webhook envoy√©e: ${event.type}`);
    } catch (error: any) {
      this.logger.error(`‚ùå Erreur lors de l'envoi de la notification webhook: ${error.message}`);
    }
  }
  
  /**
   * Envoie manuellement une notification
   */
  public async notify(event: NotificationEvent) {
    try {
      // Assurer que l'horodatage est d√©fini
      if (!event.timestamp) {
        event.timestamp = new Date().toISOString();
      }
      
      // Mettre √† jour le manifeste si n√©cessaire
      if (event.migrationId) {
        await this.updateManifest(event);
      }
      
      // Envoyer les notifications
      await this.sendNotifications(event);
      
      return true;
    } catch (error: any) {
      this.logger.error(`‚ùå Erreur lors de l'envoi manuel de notification: ${error.message}`);
      return false;
    }
  }
  
  /**
   * Arr√™te proprement le notifier
   */
  public async stop() {
    try {
      if (this.redisClient) {
        await this.redisClient.quit();
        this.logger.log('üîå D√©connexion de Redis');
      }
      
      this.logger.log('üëã MCPNotifier arr√™t√©');
    } catch (error: any) {
      this.logger.error(`‚ùå Erreur lors de l'arr√™t de MCPNotifier: ${error.message}`);
    }
  }
}

/**
 * Fonction d'aide pour cr√©er une instance du notifier
 */
export function createNotifier(config: NotifierConfig): MCPNotifier {
  return new MCPNotifier(config);
}

// Ex√©cution autonome si appel√© directement
if (require.main === module) {
  const configPath = process.argv[2] || path.join(process.cwd(), 'config', 'notifier.json');
  
  console.log(`üìã Chargement de la configuration depuis ${configPath}`);
  
  try {
    const config = fs.readJsonSync(configPath);
    const notifier = createNotifier(config);
    
    // G√©rer l'arr√™t propre
    process.on('SIGINT', async () => {
      console.log('üõë Signal d\'interruption re√ßu');
      await notifier.stop();
      process.exit(0);
    });
    
    console.log('‚úÖ MCPNotifier d√©marr√©');
  } catch (error: any) {
    console.error(`‚ùå Erreur: ${error.message}`);
    process.exit(1);
  }
}

















import { BusinessAgent } from '@workspaces/cahier-des-charge/src/core/interfaces/business';






















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































import { AnalyzerAgent } from '@workspaces/cahier-des-charge/src/core/interfaces/business';



























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































