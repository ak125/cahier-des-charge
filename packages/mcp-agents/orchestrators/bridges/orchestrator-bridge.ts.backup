// Fichier adapt√© pour la nouvelle architecture √† trois couches
import { AbstractOrchestratorAgent, OrchestratorConfig } from '../../core/abstract-orchestrator-agent';
import { AgentContext } from '../../core/mcp-agent';

import { Client as TemporalClient } from "@temporalio/client";
import { Queue, Worker, QueueEvents } from "bullmq";
import { Logger } from "@nestjs/common";
import axios from "axios";
import Redis from "ioredis";
import * as path from "path";
import * as fs from "fs";
import * as express from "express";
import { createBullBoard } from "@bull-board/api";
import { BullMQAdapter } from "@bull-board/api/bullMQAdapter";
import { ExpressAdapter } from "@bull-board/express";
import { MetricsService } from "./metrics-service";
import { WorkflowVersioner } from "../src/temporal/workflow-versioner";
import { 
  NotificationService, 
  NotificationChannel, 
  NotificationType,
  NotificationConfig 
} from "./notification-service";

/**
 * Configuration du pont d'orchestration
 */
export interface OrchestratorBridgeConfig {
  redisUrl: string;
  temporalAddress: string;
  n8nWebhookUrl: string;
  queueNames: string[];
  statusFilePath?: string;
  temporalUIAddress?: string;
  n8nUIAddress?: string;
  dashboardPort?: number;
  metricsEnabled?: boolean;
  metricsFilePath?: string;
  enableMetrics?: boolean;
  workflowVersionsPath?: string;
  enableWorkflowVersioning?: boolean;
  notification?: {
    enabled: boolean;
    config?: NotificationConfig;
  };
}

/**
 * OrchestratorBridge - Pont d'int√©gration entre Temporal.io, BullMQ et n8n
 * 
 * Cette classe permet une communication bidirectionnelle entre:
 * - Temporal.io pour les workflows de longue dur√©e
 * - BullMQ pour les files d'attente et jobs distribu√©s
 * - n8n pour les triggers externes et webhooks
 */
export class OrchestratorBridge {
  private readonly logger = new Logger('OrchestratorBridge');
  private temporalClient: TemporalClient;
  private redisClient: Redis;
  private bullMQQueues: Record<string, Queue> = {};
  private bullMQEvents: Record<string, QueueEvents> = {};
  private n8nWebhookUrl: string;
  private dashboardServer: any;
  private metricsService: MetricsService | null = null;
  private workflowVersioner: WorkflowVersioner | null = null;
  private notificationService: NotificationService | null = null;
  
  constructor(
    private readonly config: OrchestratorBridgeConfig
  ) {
    this.n8nWebhookUrl = config.n8nWebhookUrl;
    
    // Initialisation du service de m√©triques si activ√©
    if (config.enableMetrics) {
      this.metricsService = new MetricsService({
        metricsFilePath: config.metricsFilePath || path.join(process.cwd(), 'metrics.json'),
        autoSave: true,
        saveIntervalMs: 30000 // Sauvegarde toutes les 30 secondes
      });
    }
    
    // Initialisation du gestionnaire de versions si activ√©
    if (config.enableWorkflowVersioning) {
      this.workflowVersioner = new WorkflowVersioner({
        versionsFilePath: config.workflowVersionsPath || path.join(process.cwd(), 'workflow-versions.json')
      });
    }
    
    // Initialisation du service de notification si activ√©
    if (config.notification?.enabled) {
      // Configuration par d√©faut si aucune n'est fournie
      const defaultNotificationConfig: NotificationConfig = {
        channels: {
          [NotificationChannel.CONSOLE]: {},
          [NotificationChannel.FILE]: {
            filePath: path.join(process.cwd(), 'logs', 'notifications.log')
          }
        },
        defaults: {
          channels: [NotificationChannel.CONSOLE, NotificationChannel.FILE],
          type: NotificationType.INFO,
          throttleMs: 60000 // 1 minute
        }
      };
      
      this.notificationService = new NotificationService(
        config.notification.config || defaultNotificationConfig
      );
    }
  }
  
  /**
   * Initialise la connexion aux diff√©rents syst√®mes
   */
  async initialize() {
    this.logger.log('üîÑ Initialisation du pont d\'orchestration...');
    
    // Connexion √† Temporal
    this.temporalClient = await TemporalClient.connect({
      address: this.config.temporalAddress,
    });
    this.logger.log('‚úÖ Connect√© √† Temporal Server');
    
    // Connexion √† Redis
    this.redisClient = new Redis(this.config.redisUrl);
    this.logger.log('‚úÖ Connect√© √† Redis');
    
    // Initialisation des files d'attente BullMQ
    for (const queueName of this.config.queueNames) {
      this.bullMQQueues[queueName] = new Queue(queueName, {
        connection: { host: new URL(this.config.redisUrl).hostname }
      });
      
      // √âv√©nements BullMQ pour synchro avec Temporal et n8n
      this.bullMQEvents[queueName] = new QueueEvents(queueName, {
        connection: { host: new URL(this.config.redisUrl).hostname }
      });
      
      // √âcoute des √©v√©nements de compl√©tion
      this.bullMQEvents[queueName].on('completed', async ({ jobId, returnvalue }) => {
        try {
          const job = await this.bullMQQueues[queueName].getJob(jobId);
          if (job) {
            // Publier statut vers n8n
            await this.notifyN8N('job.completed', {
              queueName,
              jobId,
              data: job.data,
              result: JSON.parse(returnvalue),
              timestamp: new Date().toISOString()
            });
            
            // V√©rifier si un workflow Temporal est associ√©
            const temporalWorkflowId = job.data.temporalWorkflowId;
            if (temporalWorkflowId) {
              // Signaler au workflow Temporal
              const handle = this.temporalClient.workflow.getHandle(temporalWorkflowId);
              await handle.signal('bullMQJobCompleted', {
                queueName,
                jobId,
                result: JSON.parse(returnvalue)
              });
              this.logger.log(`‚úì Signal envoy√© au workflow Temporal ${temporalWorkflowId}`);
            }
            
            // Mise √† jour du statut global
            await this.updateGlobalStatus({
              type: 'job.completed',
              queueName,
              jobId,
              timestamp: new Date().toISOString(),
              data: {
                result: JSON.parse(returnvalue),
                duration: job.finishedOn ? job.finishedOn - job.processedOn : undefined
              }
            });
            
            // Collecter des m√©triques
            if (this.metricsService) {
              this.metricsService.incrementCounter('jobs_completed_total', 1, { queue: queueName });
              
              // Mesurer le temps d'ex√©cution
              if (job.finishedOn && job.processedOn) {
                const durationMs = job.finishedOn - job.processedOn;
                this.metricsService.observeHistogram('job_duration_milliseconds', durationMs, { 
                  queue: queueName,
                  job_type: job.name || 'unknown'
                });
              }
            }

            // Envoyer une notification de r√©ussite
            if (this.notificationService && job.data.temporalWorkflowId) {
              await this.notificationService.success(
                `Job ${job.name || 'Unnamed'} #${jobId} termin√© avec succ√®s`,
                `Le job associ√© au workflow ${job.data.temporalWorkflowId} a √©t√© compl√©t√© avec succ√®s.`,
                {
                  metadata: {
                    queueName,
                    jobId,
                    workflowId: job.data.temporalWorkflowId,
                    duration: job.finishedOn && job.processedOn ? `${job.finishedOn - job.processedOn}ms` : 'N/A'
                  }
                }
              );
            }
          }
        } catch (error) {
          this.logger.error(`Erreur lors du traitement de la compl√©tion du job ${jobId}`, error);
        }
      });
      
      // √âcoute des √©v√©nements d'√©chec
      this.bullMQEvents[queueName].on('failed', async ({ jobId, failedReason }) => {
        try {
          const job = await this.bullMQQueues[queueName].getJob(jobId);
          if (job) {
            // Publier statut vers n8n
            await this.notifyN8N('job.failed', {
              queueName,
              jobId,
              data: job.data,
              error: failedReason,
              timestamp: new Date().toISOString()
            });
            
            // V√©rifier si un workflow Temporal est associ√©
            const temporalWorkflowId = job.data.temporalWorkflowId;
            if (temporalWorkflowId) {
              // Signaler au workflow Temporal
              const handle = this.temporalClient.workflow.getHandle(temporalWorkflowId);
              await handle.signal('bullMQJobFailed', {
                queueName,
                jobId,
                error: failedReason
              });
              this.logger.log(`‚úó Signal d'√©chec envoy√© au workflow Temporal ${temporalWorkflowId}`);
            }
            
            // Mise √† jour du statut global
            await this.updateGlobalStatus({
              type: 'job.failed',
              queueName,
              jobId,
              timestamp: new Date().toISOString(),
              data: {
                error: failedReason,
                attempts: job.attemptsMade,
                duration: job.finishedOn ? job.finishedOn - job.processedOn : undefined
              }
            });
            
            // Collecter des m√©triques
            if (this.metricsService) {
              this.metricsService.incrementCounter('jobs_failed_total', 1, { queue: queueName });
              this.metricsService.incrementCounter('jobs_failed_by_type', 1, { 
                queue: queueName,
                job_type: job.name || 'unknown',
                error_type: this.categorizeError(failedReason)
              });
            }

            // Envoyer une notification d'√©chec
            if (this.notificationService) {
              const notificationType = job.attemptsMade >= job.opts.attempts
                ? NotificationType.ERROR
                : NotificationType.WARNING;
              
              await this.notificationService.notify({
                title: `Job ${job.name || 'Unnamed'} #${jobId} a √©chou√©`,
                message: failedReason,
                type: notificationType,
                metadata: {
                  queueName,
                  jobId,
                  workflowId: job.data.temporalWorkflowId,
                  attempts: `${job.attemptsMade}/${job.opts.attempts || 1}`
                }
              });
            }
          }
        } catch (error) {
          this.logger.error(`Erreur lors du traitement de l'√©chec du job ${jobId}`, error);
        }
      });
      
      // √âcouter les ajouts de jobs
      this.bullMQEvents[queueName].on('added', async ({ jobId }) => {
        if (this.metricsService) {
          this.metricsService.incrementCounter('jobs_added_total', 1, { queue: queueName });
          
          // Mettre √† jour la jauge du nombre de jobs en attente
          try {
            const waitingCount = await this.bullMQQueues[queueName].getWaitingCount();
            this.metricsService.setGauge('jobs_waiting', waitingCount, { queue: queueName });
          } catch (error) {
            // Ignore les erreurs
          }
        }
      });
    }
    
    this.logger.log('‚úÖ Pont d\'orchestration initialis√© avec succ√®s');
    return this;
  }
  
  /**
   * D√©marre un workflow Temporal et cr√©e un job BullMQ associ√©
   */
  async startTemporalWorkflowWithBullMQTracking(options: {
    workflowType: string;
    workflowArgs: any[];
    workflowId?: string;
    taskQueue: string;
    bullMQQueue: string;
    bullMQJobData: any;
    notifyN8N?: boolean;
  }) {
    const { workflowType, workflowArgs, taskQueue, bullMQQueue, bullMQJobData, notifyN8N = true } = options;
    
    const workflowId = options.workflowId || `${workflowType}-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`;
    
    this.logger.log(`üöÄ D√©marrage du workflow ${workflowType} avec ID ${workflowId}`);
    
    try {
      // D√©marrer le workflow Temporal
      const handle = await this.temporalClient.workflow.start(workflowType, {
        args: workflowArgs,
        taskQueue,
        workflowId,
      });
      
      // Collecter des m√©triques
      if (this.metricsService) {
        this.metricsService.incrementCounter('workflows_started_total', 1, { 
          workflow_type: workflowType,
          task_queue: taskQueue
        });
      }
      
      // Cr√©er un job BullMQ pour suivre le workflow
      const jobData = {
        ...bullMQJobData,
        temporalWorkflowId: workflowId,
        temporalRunId: handle.firstExecutionRunId,
        startTime: new Date().toISOString()
      };
      
      const job = await this.bullMQQueues[bullMQQueue].add(
        `track-${workflowType}`, 
        jobData, 
        {
          attempts: 3,
          backoff: {
            type: 'exponential',
            delay: 5000
          }
        }
      );
      
      // Notifier n8n si demand√©
      if (notifyN8N) {
        await this.notifyN8N('workflow.started', {
          workflowType,
          workflowId,
          runId: handle.firstExecutionRunId,
          bullMQJobId: job.id,
          timestamp: new Date().toISOString(),
          data: jobData
        });
      }
      
      // Mise √† jour du statut global
      await this.updateGlobalStatus({
        type: 'workflow.started',
        workflowId,
        workflowType,
        timestamp: new Date().toISOString(),
        data: {
          runId: handle.firstExecutionRunId,
          bullMQJobId: job.id,
          taskQueue
        }
      });

      // Notifier le d√©marrage d'un workflow
      if (this.notificationService) {
        await this.notificationService.info(
          `Workflow ${workflowType} d√©marr√©`,
          `Un nouveau workflow ${workflowType} avec ID ${workflowId} a √©t√© d√©marr√©.`,
          {
            metadata: {
              workflowId,
              runId: handle.firstExecutionRunId,
              bullMQJobId: job.id,
              taskQueue
            }
          }
        );
      }
      
      return {
        workflowId,
        runId: handle.firstExecutionRunId,
        bullMQJobId: job.id
      };
    } catch (error) {
      // Collecter des m√©triques sur les erreurs
      if (this.metricsService) {
        this.metricsService.incrementCounter('workflows_start_failed_total', 1, { 
          workflow_type: workflowType,
          task_queue: taskQueue,
          error_type: this.categorizeError(error.message)
        });
      }
      
      this.logger.error(`Erreur lors du d√©marrage du workflow ${workflowType}`, error);

      // Notifier l'√©chec de d√©marrage
      if (this.notificationService) {
        await this.notificationService.error(
          `√âchec du d√©marrage du workflow ${workflowType}`,
          error.message,
          {
            metadata: {
              workflowType,
              taskQueue,
              error: error.stack
            }
          }
        );
      }
      
      throw error;
    }
  }
  
  /**
   * D√©marre un workflow Temporal avec une version sp√©cifique et cr√©e un job BullMQ associ√©
   */
  async startVersionedWorkflow(options: {
    workflowType: string;
    workflowArgs: any[];
    workflowVersion?: string;
    workflowId?: string;
    taskQueue?: string;
    bullMQQueue: string;
    bullMQJobData: any;
    notifyN8N?: boolean;
  }) {
    const { 
      workflowType, 
      workflowArgs, 
      workflowVersion = 'latest',
      bullMQQueue, 
      bullMQJobData, 
      notifyN8N = true 
    } = options;
    
    if (!this.workflowVersioner) {
      throw new Error("Le syst√®me de versionnement des workflows n'est pas activ√©. Utilisez enableWorkflowVersioning: true dans la configuration.");
    }
    
    // D√©terminer la file d'attente √† utiliser pour la version sp√©cifi√©e
    const taskQueue = options.taskQueue || this.workflowVersioner.getTaskQueueForVersion(workflowType, workflowVersion);
    
    if (!taskQueue) {
      throw new Error(`Aucune file d'attente trouv√©e pour le workflow ${workflowType} version ${workflowVersion}`);
    }
    
    const workflowId = options.workflowId || `${workflowType}-v${workflowVersion}-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`;
    
    this.logger.log(`üöÄ D√©marrage du workflow ${workflowType} version ${workflowVersion} avec ID ${workflowId}`);
    
    try {
      // Obtenir la version exacte si 'latest' est sp√©cifi√©
      let actualVersion = workflowVersion;
      let buildId: string | undefined;
      
      if (workflowVersion === 'latest') {
        const latestVersion = this.workflowVersioner.getLatestVersion(workflowType);
        if (!latestVersion) {
          throw new Error(`Aucune version trouv√©e pour le workflow ${workflowType}`);
        }
        actualVersion = latestVersion.version;
        buildId = latestVersion.buildId;
      } else {
        const specificVersion = this.workflowVersioner.getVersion(workflowType, workflowVersion);
        if (!specificVersion) {
          throw new Error(`Version ${workflowVersion} non trouv√©e pour le workflow ${workflowType}`);
        }
        buildId = specificVersion.buildId;
      }
      
      // D√©marrer le workflow Temporal avec la version sp√©cifi√©e
      const handle = await this.temporalClient.workflow.start(workflowType, {
        args: workflowArgs,
        taskQueue,
        workflowId,
        ...(buildId ? { buildId } : {})
      });
      
      // Collecter des m√©triques
      if (this.metricsService) {
        this.metricsService.incrementCounter('workflows_started_total', 1, { 
          workflow_type: workflowType,
          workflow_version: actualVersion,
          task_queue: taskQueue
        });
      }
      
      // Cr√©er un job BullMQ pour suivre le workflow
      const jobData = {
        ...bullMQJobData,
        temporalWorkflowId: workflowId,
        temporalRunId: handle.firstExecutionRunId,
        startTime: new Date().toISOString(),
        workflowVersion: actualVersion
      };
      
      const job = await this.bullMQQueues[bullMQQueue].add(
        `track-${workflowType}-v${actualVersion}`, 
        jobData, 
        {
          attempts: 3,
          backoff: {
            type: 'exponential',
            delay: 5000
          }
        }
      );
      
      // Notifier n8n si demand√©
      if (notifyN8N) {
        await this.notifyN8N('workflow.started', {
          workflowType,
          workflowId,
          runId: handle.firstExecutionRunId,
          bullMQJobId: job.id,
          workflowVersion: actualVersion,
          timestamp: new Date().toISOString(),
          data: jobData
        });
      }
      
      // Mise √† jour du statut global
      await this.updateGlobalStatus({
        type: 'workflow.started',
        workflowId,
        workflowType,
        workflowVersion: actualVersion,
        timestamp: new Date().toISOString(),
        data: {
          runId: handle.firstExecutionRunId,
          bullMQJobId: job.id,
          taskQueue,
          buildId
        }
      });
      
      return {
        workflowId,
        runId: handle.firstExecutionRunId,
        bullMQJobId: job.id,
        workflowVersion: actualVersion,
        taskQueue
      };
    } catch (error) {
      // Collecter des m√©triques sur les erreurs
      if (this.metricsService) {
        this.metricsService.incrementCounter('workflows_start_failed_total', 1, { 
          workflow_type: workflowType,
          workflow_version: workflowVersion,
          task_queue: taskQueue || 'unknown',
          error_type: this.categorizeError(error.message)
        });
      }
      
      this.logger.error(`Erreur lors du d√©marrage du workflow ${workflowType} version ${workflowVersion}`, error);
      throw error;
    }
  }
  
  /**
   * G√®re les erreurs de workflow Temporal avec diff√©rentes strat√©gies de reprise
   * @param options Options de gestion des erreurs
   */
  async setupTemporalErrorHandling(options: {
    taskQueue: string;
    retryOptions?: {
      maxAttempts: number;
      initialInterval: number; // en ms
      backoffCoefficient: number;
      maximumInterval?: number; // en ms
      nonRetryableErrors?: string[];
    };
    notifyOnFailure?: boolean;
  }) {
    const { taskQueue, retryOptions, notifyOnFailure = true } = options;
    
    // Param√®tres par d√©faut pour les reprises
    const defaultRetryOptions = {
      maxAttempts: 3,
      initialInterval: 1000, // 1 seconde
      backoffCoefficient: 2, // augmentation exponentielle
      maximumInterval: 60000, // 1 minute maximum
      nonRetryableErrors: ['ValidationError', 'ConfigurationError']
    };
    
    const finalRetryOptions = { ...defaultRetryOptions, ...retryOptions };
    
    // Cr√©er un worker sp√©cial pour surveiller les √©checs de workflow
    const failureMonitorHandle = await this.temporalClient.workflow.getHandle('__failureMonitor__');
    
    // Cr√©er un worker pour observer les √©v√©nements Temporal
    this.logger.log(`üîç Configuration de la gestion des erreurs pour la file d'attente "${taskQueue}"`);

    // Mettre en place une routine pour v√©rifier p√©riodiquement les workflows √©chou√©s
    setInterval(async () => {
      try {
        // Recherche des workflows en √©chec dans la file d'attente sp√©cifi√©e
        const failedWorkflows = await this.temporalClient.workflow.list({
          query: `TaskQueue='${taskQueue}' AND ExecutionStatus='Failed'`
        });
        
        for await (const workflow of failedWorkflows) {
          // V√©rifier si le workflow a d√©j√† √©t√© trait√©
          if (await this.isWorkflowAlreadyHandled(workflow.execution.workflowId)) {
            continue;
          }
          
          // Obtenir les d√©tails de l'√©chec
          const description = await this.temporalClient.workflow.describe(workflow.execution);
          this.logger.warn(`‚ùå Workflow en √©chec d√©tect√©: ${workflow.execution.workflowId}`, {
            workflowId: workflow.execution.workflowId,
            taskQueue,
            error: description.status.failure?.message || 'Erreur inconnue'
          });
          
          // V√©rifier si on doit r√©essayer
          const failureType = this.getFailureType(description.status.failure);
          const shouldRetry = !finalRetryOptions.nonRetryableErrors.includes(failureType);
          
          if (shouldRetry && description.status.historyLength < finalRetryOptions.maxAttempts) {
            // Calculer le d√©lai de reprise
            const attempt = description.status.historyLength;
            const delayMs = Math.min(
              finalRetryOptions.initialInterval * Math.pow(finalRetryOptions.backoffCoefficient, attempt - 1),
              finalRetryOptions.maximumInterval || Number.MAX_SAFE_INTEGER
            );
            
            this.logger.log(`‚è±Ô∏è Programmation d'une reprise du workflow ${workflow.execution.workflowId} dans ${delayMs}ms (tentative ${attempt})`);
            
            // Programmer la reprise
            setTimeout(async () => {
              try {
                // Red√©marrer le workflow avec les m√™mes arguments
                const handle = await this.temporalClient.workflow.start(workflow.type.name, {
                  taskQueue,
                  workflowId: `retry-${workflow.execution.workflowId}-${Date.now()}`,
                  memo: {
                    originalWorkflowId: workflow.execution.workflowId,
                    retryAttempt: attempt,
                    retryReason: description.status.failure?.message
                  }
                });
                
                this.logger.log(`üîÑ Workflow ${workflow.type.name} red√©marr√© avec ID ${handle.workflowId}`);
                
                // Mise √† jour du statut global
                await this.updateGlobalStatus({
                  type: 'workflow.retry',
                  workflowId: handle.workflowId,
                  originalWorkflowId: workflow.execution.workflowId,
                  workflowType: workflow.type.name,
                  timestamp: new Date().toISOString(),
                  data: {
                    attempt,
                    reason: description.status.failure?.message,
                    delay: delayMs
                  }
                });
              } catch (error) {
                this.logger.error(`Erreur lors de la reprise du workflow ${workflow.execution.workflowId}`, error);
              }
            }, delayMs);

            // Notifier la reprise planifi√©e
            if (this.notificationService) {
              await this.notificationService.warning(
                `Reprise planifi√©e pour workflow en √©chec`,
                `Le workflow ${workflow.execution.workflowId} sera repris dans ${delayMs}ms (tentative ${attempt})`,
                {
                  metadata: {
                    workflowId: workflow.execution.workflowId,
                    workflowType: workflow.type.name,
                    error: description.status.failure?.message,
                    attempt: attempt,
                    maxAttempts: finalRetryOptions.maxAttempts
                  }
                }
              );
            }
          } else {
            this.logger.warn(`‚ùå Le workflow ${workflow.execution.workflowId} ne sera pas repris:`, {
              reason: !shouldRetry ? `Type d'erreur non repris: ${failureType}` : `Nombre maximum de tentatives atteint: ${finalRetryOptions.maxAttempts}`
            });
            
            // Envoyer une notification finale d'√©chec
            if (notifyOnFailure) {
              await this.notifyN8N('workflow.failure', {
                workflowId: workflow.execution.workflowId,
                workflowType: workflow.type.name,
                timestamp: new Date().toISOString(),
                error: description.status.failure?.message,
                stackTrace: description.status.failure?.stackTrace,
                attempts: description.status.historyLength,
                finalFailure: true
              });
            }
            
            // Mise √† jour du statut global pour un √©chec final
            await this.updateGlobalStatus({
              type: 'workflow.finalFailure',
              workflowId: workflow.execution.workflowId,
              workflowType: workflow.type.name,
              timestamp: new Date().toISOString(),
              data: {
                error: description.status.failure?.message,
                attempts: description.status.historyLength
              }
            });

            // Notifier l'√©chec d√©finitif
            if (this.notificationService) {
              await this.notificationService.critical(
                `√âchec d√©finitif du workflow ${workflow.execution.workflowId}`,
                `Le workflow ${workflow.type.name} a √©chou√© de mani√®re d√©finitive apr√®s ${description.status.historyLength} tentatives.`,
                {
                  metadata: {
                    workflowId: workflow.execution.workflowId,
                    workflowType: workflow.type.name,
                    error: description.status.failure?.message,
                    stackTrace: description.status.failure?.stackTrace,
                    attempts: description.status.historyLength,
                    reason: !shouldRetry 
                      ? `Type d'erreur non repris: ${failureType}` 
                      : `Nombre maximum de tentatives atteint: ${finalRetryOptions.maxAttempts}`
                  }
                }
              );
            }
          }
          
          // Marquer le workflow comme trait√©
          await this.markWorkflowAsHandled(workflow.execution.workflowId);
        }
      } catch (error) {
        this.logger.error('Erreur lors de la surveillance des workflows en √©chec', error);
      }
    }, 30000); // V√©rifier toutes les 30 secondes
    
    this.logger.log(`‚úÖ Gestion des erreurs configur√©e pour la file d'attente "${taskQueue}"`);
  }
  
  /**
   * V√©rifie si un workflow a d√©j√† √©t√© trait√© par le m√©canisme de gestion des erreurs
   * @param workflowId L'ID du workflow √† v√©rifier
   * @returns true si le workflow a d√©j√† √©t√© trait√©, false sinon
   */
  private async isWorkflowAlreadyHandled(workflowId: string): Promise<boolean> {
    const key = `handled:${workflowId}`;
    const result = await this.redisClient.get(key);
    return result === '1';
  }
  
  /**
   * Marque un workflow comme trait√© par le m√©canisme de gestion des erreurs
   * @param workflowId L'ID du workflow √† marquer
   */
  private async markWorkflowAsHandled(workflowId: string): Promise<void> {
    const key = `handled:${workflowId}`;
    // Expiration apr√®s 24 heures pour nettoyer la base Redis
    await this.redisClient.set(key, '1', 'EX', 86400);
  }
  
  /**
   * Extrait le type d'erreur d'un objet failure Temporal
   * @param failure L'objet failure de Temporal
   * @returns Le type d'erreur sous forme de cha√Æne
   */
  private getFailureType(failure: any): string {
    if (!failure) return 'UnknownError';
    
    // Tenter d'extraire le type d'erreur depuis le message
    const errorTypeMatch = failure.message?.match(/^([A-Za-z]+Error):/);
    if (errorTypeMatch) return errorTypeMatch[1];
    
    // Fallback sur le type d'application
    return failure.applicationFailureInfo?.type || 'ApplicationError';
  }
  
  /**
   * Envoie une notification √† n8n via un webhook
   */
  private async notifyN8N(event: string, payload: any) {
    if (!this.n8nWebhookUrl) return;
    
    try {
      await axios.post(`${this.n8nWebhookUrl}/${event}`, payload, {
        headers: {
          'Content-Type': 'application/json'
        }
      });
      this.logger.log(`üì§ Notification n8n envoy√©e: ${event}`);
    } catch (error) {
      this.logger.error(`Erreur lors de la notification n8n (${event})`, error);
    }
  }
  
  /**
   * √âcoute les signaux de n8n et les transmet √† Temporal/BullMQ
   */
  async listenToN8NSignals(webHandler: any, port: number = 3456) {
    // Configurer un mini serveur pour recevoir des signaux de n8n
    webHandler.post('/n8n-signal/:signalType', async (req: any, res: any) => {
      const { signalType } = req.params;
      const payload = req.body;
      
      this.logger.log(`üì• Signal n8n re√ßu: ${signalType}`);
      
      try {
        if (payload.workflowId) {
          // Signal vers Temporal
          const handle = this.temporalClient.workflow.getHandle(payload.workflowId);
          await handle.signal(signalType, payload);
          this.logger.log(`‚úì Signal transmis au workflow Temporal ${payload.workflowId}`);
        }
        
        if (payload.bullMQQueue && payload.jobData) {
          // Cr√©ation d'un job BullMQ
          const queue = this.bullMQQueues[payload.bullMQQueue];
          if (queue) {
            const job = await queue.add(signalType, payload.jobData);
            this.logger.log(`‚úì Job cr√©√© dans la file BullMQ ${payload.bullMQQueue}: ${job.id}`);
          }
        }
        
        // Mise √† jour du statut global
        await this.updateGlobalStatus({
          type: 'n8n.signal',
          signalType,
          timestamp: new Date().toISOString(),
          data: payload
        });
        
        res.status(200).json({ success: true, message: 'Signal trait√© avec succ√®s' });
      } catch (error) {
        this.logger.error(`Erreur lors du traitement du signal n8n ${signalType}`, error);
        res.status(500).json({ success: false, error: error.message });
      }
    });
    
    // D√©marrer le serveur
    webHandler.listen(port, () => {
      this.logger.log(`üöÄ Serveur d'√©coute des signaux n8n d√©marr√© sur le port ${port}`);
    });
  }
  
  /**
   * Cr√©e et d√©marre un tableau de bord unifi√© pour monitorer Temporal, BullMQ et n8n
   * @param port Port d'√©coute du serveur web
   * @returns L'instance du serveur web
   */
  async createDashboardServer(port: number = 3500): Promise<any> {
    const app = express();
    
    // Configuration du tableau de bord BullMQ
    const serverAdapter = new ExpressAdapter();
    serverAdapter.setBasePath('/bull-dashboard');
    
    const bullBoard = createBullBoard({
      queues: Object.values(this.bullMQQueues).map(queue => new BullMQAdapter(queue)),
      serverAdapter
    });
    
    app.use('/bull-dashboard', serverAdapter.getRouter());
    
    // Page d'accueil avec liens vers les diff√©rents tableaux de bord
    app.get('/', (req, res) => {
      res.send(`
        <html>
          <head>
            <title>Tableau de bord d'orchestration</title>
            <style>
              body { font-family: Arial, sans-serif; margin: 0; padding: 20px; }
              h1 { color: #333; }
              .dashboard-container { display: flex; flex-wrap: wrap; gap: 20px; }
              .dashboard-card { border: 1px solid #ddd; border-radius: 8px; padding: 15px; width: 300px; }
              .dashboard-card h2 { margin-top: 0; color: #0066cc; }
              .button { display: inline-block; background: #0066cc; color: white; padding: 8px 16px; text-decoration: none; border-radius: 4px; margin-top: 10px; }
              .stats { margin-top: 20px; background: #f5f5f5; padding: 15px; border-radius: 8px; }
            </style>
          </head>
          <body>
            <h1>Tableau de bord d'orchestration unifi√©</h1>
            <div class="dashboard-container">
              <div class="dashboard-card">
                <h2>BullMQ</h2>
                <p>Gestion des files d'attente et des t√¢ches distribu√©es</p>
                <a class="button" href="/bull-dashboard">Ouvrir BullMQ Dashboard</a>
              </div>
              <div class="dashboard-card">
                <h2>Temporal</h2>
                <p>Gestion des workflows durables de longue dur√©e</p>
                <a class="button" href="${this.config.temporalUIAddress || 'http://localhost:8088'}" target="_blank">Ouvrir Temporal UI</a>
              </div>
              <div class="dashboard-card">
                <h2>n8n</h2>
                <p>Automatisation et orchestration des workflows</p>
                <a class="button" href="${this.config.n8nUIAddress || 'http://localhost:5678'}" target="_blank">Ouvrir n8n</a>
              </div>
            </div>
            
            <div class="stats">
              <h2>Statistiques globales</h2>
              <div id="stats">Chargement des statistiques...</div>
            </div>
            
            <script>
              // Charger les statistiques via AJAX
              async function loadStats() {
                const response = await fetch('/api/statistics');
                const stats = await response.json();
                document.getElementById('stats').innerHTML = \`
                  <ul>
                    <li>Workflows d√©marr√©s: \${stats.workflowsStarted}</li>
                    <li>Workflows termin√©s: \${stats.workflowsCompleted}</li>
                    <li>Workflows en √©chec: \${stats.workflowsFailed}</li>
                    <li>Jobs trait√©s: \${stats.jobsProcessed}</li>
                    <li>Jobs termin√©s: \${stats.jobsCompleted}</li>
                    <li>Jobs en √©chec: \${stats.jobsFailed}</li>
                    <li>Derni√®re mise √† jour: \${new Date(stats.lastUpdated).toLocaleString()}</li>
                  </ul>
                \`;
              }
              
              // Charger les statistiques toutes les 5 secondes
              loadStats();
              setInterval(loadStats, 5000);
            </script>
          </body>
        </html>
      `);
    });
    
    // API pour r√©cup√©rer les statistiques
    app.get('/api/statistics', (req, res) => {
      if (!this.config.statusFilePath || !fs.existsSync(this.config.statusFilePath)) {
        return res.json({
          workflowsStarted: 0,
          workflowsCompleted: 0,
          workflowsFailed: 0,
          jobsProcessed: 0,
          jobsCompleted: 0,
          jobsFailed: 0,
          lastUpdated: new Date().toISOString()
        });
      }
      
      const statusData = JSON.parse(fs.readFileSync(this.config.statusFilePath, 'utf8'));
      res.json(statusData.statistics || {
        workflowsStarted: 0,
        workflowsCompleted: 0,
        workflowsFailed: 0,
        jobsProcessed: 0,
        jobsCompleted: 0,
        jobsFailed: 0,
        lastUpdated: new Date().toISOString()
      });
    });
    
    // API pour r√©cup√©rer les √©v√©nements r√©cents
    app.get('/api/events', (req, res) => {
      if (!this.config.statusFilePath || !fs.existsSync(this.config.statusFilePath)) {
        return res.json([]);
      }
      
      const statusData = JSON.parse(fs.readFileSync(this.config.statusFilePath, 'utf8'));
      res.json(statusData.events || []);
    });
    
    // API pour r√©cup√©rer les versions des workflows
    app.get('/api/workflow-versions', (req, res) => {
      if (!this.workflowVersioner) {
        return res.json({});
      }
      
      const result: Record<string, any> = {};
      const workflowTypes = Object.keys(this.workflowVersioner['versions']);
      
      workflowTypes.forEach(workflowType => {
        result[workflowType] = this.workflowVersioner?.getAllVersions(workflowType);
      });
      
      res.json(result);
    });
    
    // API pour r√©cup√©rer les versions d'un workflow sp√©cifique
    app.get('/api/workflow-versions/:workflowType', (req, res) => {
      if (!this.workflowVersioner) {
        return res.json([]);
      }
      
      const { workflowType } = req.params;
      const versions = this.workflowVersioner.getAllVersions(workflowType);
      
      res.json(versions);
    });
    
    // Exposer les m√©triques si le service est activ√©
    if (this.metricsService) {
      this.exposeMetricsEndpoint(app);
    }
    
    // D√©marrer le serveur
    this.dashboardServer = app.listen(port, () => {
      this.logger.log(`üöÄ Tableau de bord d'orchestration d√©marr√© sur http://localhost:${port}`);
    });
    
    return this.dashboardServer;
  }
  
  /**
   * Enregistre une nouvelle version d'un workflow
   */
  registerWorkflowVersion(
    workflowType: string,
    version: string,
    taskQueue: string,
    buildId: string,
    compatibleWith: string[] = [],
    metadata: Record<string, any> = {}
  ): void {
    if (!this.workflowVersioner) {
      throw new Error("Le syst√®me de versionnement des workflows n'est pas activ√©");
    }
    
    try {
      this.workflowVersioner.registerVersion(
        workflowType,
        version,
        taskQueue,
        buildId,
        compatibleWith,
        metadata
      );
      
      this.logger.log(`‚úÖ Version ${version} enregistr√©e pour le workflow ${workflowType}`);
      
      // Exposer les versions dans le tableau de bord si disponible
      if (this.dashboardServer) {
        this.logger.log(`‚ÑπÔ∏è Le tableau de bord a √©t√© mis √† jour avec la nouvelle version du workflow`);
      }

      // Notifier l'enregistrement d'une nouvelle version
      if (this.notificationService) {
        this.notificationService.success(
          `Nouvelle version ${version} pour ${workflowType}`,
          `Une nouvelle version du workflow ${workflowType} a √©t√© enregistr√©e.`,
          {
            metadata: {
              workflowType,
              version,
              taskQueue,
              buildId,
              compatibleWith: compatibleWith || []
            }
          }
        );
      }
    } catch (error) {
      this.logger.error(`Erreur lors de l'enregistrement de la version ${version} du workflow ${workflowType}`, error);
      
      // Notifier l'√©chec d'enregistrement
      if (this.notificationService) {
        this.notificationService.error(
          `√âchec de l'enregistrement de la version ${version} de ${workflowType}`,
          error.message,
          {
            metadata: {
              workflowType,
              version,
              taskQueue,
              error: error.stack
            }
          }
        );
      }
      
      throw error;
    }
  }
  
  /**
   * R√©cup√®re toutes les versions d'un workflow
   */
  getWorkflowVersions(workflowType: string): any[] {
    if (!this.workflowVersioner) {
      throw new Error("Le syst√®me de versionnement des workflows n'est pas activ√©");
    }
    
    return this.workflowVersioner.getAllVersions(workflowType);
  }
  
  /**
   * Met √† jour le fichier de statut global
   */
  private async updateGlobalStatus(statusUpdate: any) {
    if (!this.config.statusFilePath) return;
    
    try {
      // Lire le fichier status.json actuel
      let statusData = { events: [] };
      
      if (fs.existsSync(this.config.statusFilePath)) {
        const fileContent = fs.readFileSync(this.config.statusFilePath, 'utf8');
        statusData = JSON.parse(fileContent);
      }
      
      // Ajouter l'√©v√©nement au d√©but pour avoir les plus r√©cents en premier
      statusData.events.unshift({
        id: `evt-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`,
        ...statusUpdate
      });
      
      // Limiter √† 1000 √©v√©nements max
      if (statusData.events.length > 1000) {
        statusData.events = statusData.events.slice(0, 1000);
      }
      
      // Mettre √† jour les statistiques globales
      this.updateStatusStatistics(statusData);
      
      // √âcrire dans le fichier
      fs.writeFileSync(this.config.statusFilePath, JSON.stringify(statusData, null, 2));
    } catch (error) {
      this.logger.error('Erreur lors de la mise √† jour du fichier de statut', error);
    }
  }
  
  /**
   * Met √† jour les statistiques dans l'objet de statut
   */
  private updateStatusStatistics(statusData: any) {
    if (!statusData.statistics) {
      statusData.statistics = {
        workflowsStarted: 0,
        workflowsCompleted: 0,
        workflowsFailed: 0,
        jobsProcessed: 0,
        jobsCompleted: 0,
        jobsFailed: 0,
        lastUpdated: new Date().toISOString()
      };
    }
    
    // Mettre √† jour les compteurs selon le dernier √©v√©nement
    const lastEvent = statusData.events[0];
    
    if (lastEvent.type === 'workflow.started') {
      statusData.statistics.workflowsStarted++;
    } else if (lastEvent.type === 'workflow.completed') {
      statusData.statistics.workflowsCompleted++;
    } else if (lastEvent.type === 'workflow.failed') {
      statusData.statistics.workflowsFailed++;
    } else if (lastEvent.type === 'job.completed') {
      statusData.statistics.jobsCompleted++;
      statusData.statistics.jobsProcessed++;
    } else if (lastEvent.type === 'job.failed') {
      statusData.statistics.jobsFailed++;
      statusData.statistics.jobsProcessed++;
    }
    
    statusData.statistics.lastUpdated = new Date().toISOString();
  }
  
  /**
   * Expose les m√©triques au format Prometheus
   */
  exposeMetricsEndpoint(app: any, path: string = '/metrics'): void {
    if (!this.metricsService) {
      this.logger.warn('Service de m√©triques non activ√©, impossible d\'exposer les m√©triques');
      return;
    }
    
    app.get(path, (req: any, res: any) => {
      res.set('Content-Type', 'text/plain');
      res.send(this.metricsService.getPrometheusFormat());
    });
    
    this.logger.log(`‚úÖ Endpoint de m√©triques expos√© sur ${path}`);
  }
  
  /**
   * Cat√©gorise un message d'erreur en type d'erreur g√©n√©ral
   * @param errorMessage Message d'erreur √† cat√©goriser
   */
  private categorizeError(errorMessage: string): string {
    if (!errorMessage) return 'unknown';
    
    if (errorMessage.includes('timeout')) return 'timeout';
    if (errorMessage.includes('connection')) return 'connection';
    if (errorMessage.includes('permission') || errorMessage.includes('unauthorized')) return 'permission';
    if (errorMessage.includes('not found')) return 'not_found';
    if (errorMessage.includes('validation')) return 'validation';
    
    return 'other';
  }
  
  /**
   * Termine proprement les connexions
   */
  async shutdown() {
    this.logger.log('üõë Arr√™t du pont d\'orchestration...');
    
    // Fermer le service de m√©triques
    if (this.metricsService) {
      this.metricsService.shutdown();
      this.logger.log('‚úì Service de m√©triques arr√™t√©');
    }
    
    // Fermer le serveur de tableau de bord s'il existe
    if (this.dashboardServer) {
      await new Promise((resolve) => {
        this.dashboardServer.close(resolve);
      });
      this.logger.log('‚úì Serveur du tableau de bord ferm√©');
    }
    
    // Fermer les connexions BullMQ
    for (const [name, queue] of Object.entries(this.bullMQQueues)) {
      await queue.close();
      this.logger.log(`‚úì File d'attente ${name} ferm√©e`);
    }
    
    for (const [name, events] of Object.entries(this.bullMQEvents)) {
      await events.close();
      this.logger.log(`‚úì √âv√©nements ${name} ferm√©s`);
    }
    
    // Fermer Redis
    await this.redisClient.quit();
    this.logger.log('‚úì Connexion Redis ferm√©e');
    
    this.logger.log('‚úì Pont d\'orchestration arr√™t√© avec succ√®s');
  }

  /**
   * Configure les alertes automatiques bas√©es sur les m√©triques
   * @param thresholds Seuils pour les alertes
   */
  setupAutomaticAlerts(thresholds: {
    maxJobWaitTime?: number;  // En millisecondes
    maxJobsInQueue?: number;
    maxFailureRate?: number;  // En pourcentage (0-100)
    minWorkerCount?: number;
  } = {}): void {
    if (!this.notificationService) {
      this.logger.warn('Service de notification non activ√©, impossible de configurer les alertes automatiques');
      return;
    }
    
    // Valeurs par d√©faut pour les seuils
    const defaults = {
      maxJobWaitTime: 300000,   // 5 minutes
      maxJobsInQueue: 100,
      maxFailureRate: 10,       // 10%
      minWorkerCount: 1
    };
    
    const alertConfig = { ...defaults, ...thresholds };
    
    // V√©rifier p√©riodiquement les m√©triques pour g√©n√©rer des alertes
    setInterval(async () => {
      try {
        // V√©rifier pour chaque queue
        for (const queueName of this.config.queueNames) {
          const queue = this.bullMQQueues[queueName];
          if (!queue) continue;
          
          // 1. V√©rifier le nombre de jobs en attente
          const waitingCount = await queue.getWaitingCount();
          if (waitingCount > alertConfig.maxJobsInQueue) {
            await this.notificationService.warning(
              `File d'attente ${queueName} surcharg√©e`,
              `Il y a ${waitingCount} jobs en attente dans la file ${queueName}, ce qui d√©passe le seuil de ${alertConfig.maxJobsInQueue}.`,
              {
                metadata: {
                  queueName,
                  waitingCount,
                  threshold: alertConfig.maxJobsInQueue
                }
              }
            );
          }
          
          // 2. V√©rifier le temps d'attente des jobs
          const waiting = await queue.getJobs(['waiting'], 0, 1, true);
          if (waiting.length > 0) {
            const oldestJob = waiting[0];
            const waitTime = Date.now() - oldestJob.timestamp;
            if (waitTime > alertConfig.maxJobWaitTime) {
              await this.notificationService.warning(
                `Temps d'attente excessif dans ${queueName}`,
                `Le job le plus ancien attend depuis ${waitTime / 1000} secondes, ce qui d√©passe le seuil de ${alertConfig.maxJobWaitTime / 1000} secondes.`,
                {
                  metadata: {
                    queueName,
                    jobId: oldestJob.id,
                    waitTime: `${waitTime / 1000} secondes`,
                    threshold: `${alertConfig.maxJobWaitTime / 1000} secondes`
                  }
                }
              );
            }
          }
          
          // 3. V√©rifier le taux d'√©chec
          const failedCount = await queue.getFailedCount();
          const completedCount = await queue.getCompletedCount();
          const totalProcessed = failedCount + completedCount;
          
          if (totalProcessed > 0) {
            const failureRate = (failedCount / totalProcessed) * 100;
            if (failureRate > alertConfig.maxFailureRate) {
              await this.notificationService.error(
                `Taux d'√©chec √©lev√© dans ${queueName}`,
                `Le taux d'√©chec dans la file ${queueName} est de ${failureRate.toFixed(2)}%, ce qui d√©passe le seuil de ${alertConfig.maxFailureRate}%.`,
                {
                  metadata: {
                    queueName,
                    failureRate: `${failureRate.toFixed(2)}%`,
                    failedCount,
                    completedCount,
                    threshold: `${alertConfig.maxFailureRate}%`
                  }
                }
              );
            }
          }
        }
        
        // 4. V√©rifier les workflows Temporal (si le client est disponible)
        if (this.temporalClient) {
          try {
            // V√©rifier les workflows avec timeout
            const timedOutWorkflows = await this.temporalClient.workflow.list({
              query: 'ExecutionStatus=\'TimedOut\'',
              pageSize: 10
            });
            
            let timedOutCount = 0;
            for await (const wf of timedOutWorkflows) {
              timedOutCount++;
              if (timedOutCount <= 5) { // Limiter les notifications pour √©viter le spam
                await this.notificationService.error(
                  `Workflow ${wf.execution.workflowId} a expir√©`,
                  `Le workflow ${wf.type.name} avec ID ${wf.execution.workflowId} a expir√©.`,
                  {
                    metadata: {
                      workflowId: wf.execution.workflowId,
                      workflowType: wf.type.name,
                      runId: wf.execution.runId
                    }
                  }
                );
              }
            }
            
            if (timedOutCount > 5) {
              await this.notificationService.warning(
                `Plusieurs workflows ont expir√©`,
                `${timedOutCount} workflows ont expir√©. V√©rifiez l'interface Temporal pour plus de d√©tails.`
              );
            }
          } catch (err) {
            this.logger.error('Erreur lors de la v√©rification des workflows expir√©s', err);
          }
        }
      } catch (error) {
        this.logger.error('Erreur lors de la v√©rification des m√©triques pour les alertes', error);
      }
    }, 60000); // V√©rifier toutes les minutes
    
    this.logger.log('‚úÖ Alertes automatiques configur√©es');
  }
}

// Cr√©e et exporte une fonction pour initialiser facilement le pont
export async function createOrchestratorBridge(config: OrchestratorBridgeConfig) {
  const bridge = new OrchestratorBridge(config);
  return await bridge.initialize();
}

export default OrchestratorBridge;