/**
 * Classe abstraite pour les agents d'analyse
 * Ces agents analysent du code, des configurations ou des donn√©es
 * Date: 16 avril 2025
 */

import { AbstractAgent } from './abstract-agent';
import { AgentContext, AgentResult } from './interfaces';
import { BaseAgent } from './interfaces/base-agent';
import { BusinessAgent } from './interfaces/business';
import * as path from 'path';
import * as fs from 'fs-extra';
import { Logger } from '../utils/logger';

/**
 * Configuration sp√©cifique aux agents d'analyse
 */
export interface AnalyzerConfig {
  inputPath?: string;           // Chemin du fichier ou r√©pertoire √† analyser
  outputDir: string;            // R√©pertoire de sortie pour les rapports
  reportFormat?: 'json' | 'md' | 'html' | 'csv' | 'pdf'; // Format de sortie des rapports
  generateReport?: boolean;     // Indique si un rapport doit √™tre g√©n√©r√©
  reportName?: string;          // Nom du rapport
  thresholds?: {               // Seuils pour les m√©triques
    [key: string]: number;     // Nom de la m√©trique -> valeur du seuil
  };
  verbose?: boolean;           // Mode verbeux
  excludePatterns?: string[];  // Patterns √† exclure
  includePatterns?: string[];  // Patterns √† inclure
  maxDepth?: number;           // Profondeur max d'analyse
  timeout?: number;            // Timeout en ms
}

/**
 * Repr√©sente un probl√®me identifi√© lors de l'analyse
 */
export interface AnalysisIssue {
  type: string;                // Type de probl√®me (validation, security, performance, etc.)
  severity: "info" | "warning" | "error" | "critical"; // Gravit√© du probl√®me
  message: string;             // Message descriptif
  code?: string;               // Code d'identification ou r√©f√©rence
  location?: {                 // Emplacement du probl√®me
    file?: string;            // Chemin du fichier
    line?: number;            // Num√©ro de ligne
    column?: number;          // Num√©ro de colonne
    offset?: number;          // D√©calage dans le fichier
  } | string;                  // Ou cha√Æne simple pour compatibilit√©
  suggestion?: string;         // Suggestion de correction
}

/**
 * Repr√©sente un r√©sultat d'analyse 
 */
export interface AnalysisResult {
  metrics: {                   // M√©triques collect√©es
    [key: string]: number | string | boolean; // Nom de la m√©trique -> valeur
  };
  issues: AnalysisIssue[];     // Probl√®mes identifi√©s
  suggestions: string[];       // Suggestions d'am√©lioration
  metadata: Record<string, any>; // M√©tadonn√©es
  timestamp?: string;          // Timestamp de l'analyse
  executionTimeMs?: number;    // Temps d'ex√©cution en ms
  passedChecks?: number;       // Nombre de v√©rifications r√©ussies
  failedChecks?: number;       // Nombre de v√©rifications √©chou√©es
  score?: number;              // Score global (0-100)
}

/**
 * Classe abstraite pour les agents d'analyse
 */
export abstract class AbstractAnalyzerAgent<TConfig extends AnalyzerConfig = AnalyzerConfig> implements BaseAgent, BusinessAgent {
  // Propri√©t√©s d'identit√© de l'agent
  public abstract readonly id: string;
  public abstract readonly name: string;
  public abstract readonly version: string;
  public abstract readonly description: string;
  
  // Configuration de l'analyseur
  protected config: TConfig;
  
  // R√©sultat de l'analyse
  protected analysisResult: AnalysisResult = {
    metrics: {},
    issues: [],
    suggestions: [],
    metadata: {}
  };
  
  // Contenu du fichier ou des donn√©es √† analyser
  protected filePath?: string;
  protected fileContent?: string;
  protected files: Map<string, string> = new Map();
  
  // Logger pour l'agent
  protected logger: Logger;
  
  // Erreurs, avertissements et artefacts g√©n√©r√©s
  protected errors: Error[] = [];
  protected warnings: string[] = [];
  protected artifacts: string[] = [];
  
  /**
   * Constructeur de l'agent d'analyse
   * @param config Configuration de l'agent
   */
  constructor(config: Partial<TConfig>) {
    // Initialiser la configuration avec les valeurs par d√©faut et celles fournies
    this.config = {
      outputDir: './output',
      reportFormat: 'md',
      generateReport: true,
      verbose: false
    } as unknown as TConfig;
    
    // Fusionner avec la configuration fournie
    Object.assign(this.config, config);
    
    // Cr√©er un logger pour cet agent
    this.logger = new Logger(this.constructor.name, {
      outputToFile: true,
      logFilePath: path.join(this.config.outputDir, `${this.constructor.name}.log`),
      verbose: this.config.verbose
    });
  }
  
  /**
   * Initialisation de l'agent avec le contexte d'ex√©cution
   */
  public async initialize(context: AgentContext): Promise<void> {
    this.logger.info(`Initialisation de l'agent ${this.name}`);
    
    // Mise √† jour de la configuration √† partir du contexte
    const contextConfig = context.getConfig<Partial<TConfig>>();
    Object.assign(this.config, contextConfig);
    
    // Cr√©er le r√©pertoire de sortie s'il n'existe pas
    if (this.config.outputDir) {
      await fs.ensureDir(this.config.outputDir);
    }
    
    // Charger le fichier sp√©cifi√© si pr√©sent
    if (this.config.inputPath) {
      await this.loadInput(this.config.inputPath);
    }
    
    // Pr√©paration sp√©cifique de l'agent (m√©thode optionnelle)
    if (this.prepare) {
      await this.prepare();
    }
  }
  
  /**
   * Ex√©cute l'agent d'analyse
   */
  public async execute(context: AgentContext): Promise<void> {
    this.logger.info(`Ex√©cution de l'analyse avec l'agent ${this.name} v${this.version}`);
    
    const startTime = Date.now();
    
    try {
      // Ex√©cuter l'analyse (m√©thode abstraite √† impl√©menter par les sous-classes)
      await this.analyze();
      
      // Collecter les m√©triques globales
      this.analysisResult.timestamp = new Date().toISOString();
      this.analysisResult.executionTimeMs = Date.now() - startTime;
      this.analysisResult.passedChecks = this.getPassedChecksCount();
      this.analysisResult.failedChecks = this.analysisResult.issues.filter(
        i => i.severity === 'error' || i.severity === 'critical'
      ).length;
      
      // Calculer le score si pas d√©j√† d√©fini
      if (this.analysisResult.score === undefined) {
        this.analysisResult.score = this.calculateScore();
      }
      
      // G√©n√©rer le rapport si configur√©
      if (this.config.generateReport) {
        const reportPath = await this.generateReport();
        if (reportPath) {
          this.artifacts.push(reportPath);
        }
      }
      
      this.logger.info(`Analyse termin√©e en ${this.analysisResult.executionTimeMs}ms avec un score de ${this.analysisResult.score}/100`);
    } catch (error: any) {
      this.logger.error(`Erreur lors de l'analyse: ${error.message}`);
      this.errors.push(error instanceof Error ? error : new Error(String(error)));
    }
  }
  
  /**
   * M√©thode abstraite d'analyse √† impl√©menter par les sous-classes
   */
  protected abstract analyze(): Promise<void>;
  
  /**
   * Charge les donn√©es √† analyser
   * @param inputPath Chemin du fichier ou r√©pertoire √† analyser
   */
  protected async loadInput(inputPath: string): Promise<void> {
    try {
      const stats = await fs.stat(inputPath);
      
      if (stats.isFile()) {
        // Charger un fichier unique
        this.filePath = inputPath;
        this.fileContent = await fs.readFile(inputPath, 'utf-8');
        this.files.set(inputPath, this.fileContent);
        this.logger.debug(`Fichier charg√©: ${inputPath}`);
      } else if (stats.isDirectory()) {
        // Charger un r√©pertoire
        const files = await this.findFiles(inputPath);
        await Promise.all(files.map(async (file) => {
          try {
            const content = await fs.readFile(file, 'utf-8');
            this.files.set(file, content);
          } catch (err) {
            this.logger.warn(`Impossible de lire le fichier ${file}: ${err}`);
          }
        }));
        
        this.logger.debug(`${this.files.size} fichiers charg√©s depuis le r√©pertoire ${inputPath}`);
      } else {
        throw new Error(`Le chemin sp√©cifi√© n'est ni un fichier ni un r√©pertoire: ${inputPath}`);
      }
    } catch (error: any) {
      this.logger.error(`Erreur lors du chargement des donn√©es: ${error.message}`);
      throw new Error(`√âchec du chargement des donn√©es: ${error.message}`);
    }
  }
  
  /**
   * Trouve tous les fichiers dans un r√©pertoire selon les patterns d'inclusion/exclusion
   * @param directory R√©pertoire √† explorer
   */
  private async findFiles(directory: string): Promise<string[]> {
    // TODO: Impl√©menter la recherche de fichiers r√©cursive avec inclusion/exclusion
    return []; // Placeholder
  }
  
  /**
   * G√©n√®re un rapport bas√© sur les r√©sultats d'analyse
   * @returns Chemin du rapport g√©n√©r√©
   */
  protected async generateReport(): Promise<string | undefined> {
    if (this.config.generateReport === false) {
      this.logger.debug('G√©n√©ration de rapport d√©sactiv√©e');
      return undefined;
    }
    
    try {
      // Cr√©er le r√©pertoire de sortie s'il n'existe pas
      await fs.ensureDir(this.config.outputDir);
      
      // D√©terminer le nom du fichier
      const reportName = this.config.reportName || `${this.id}-report`;
      const timestamp = new Date().toISOString().replace(/:/g, '-').slice(0, 19);
      const fileName = `${reportName}-${timestamp}.${this.config.reportFormat}`;
      const filePath = path.join(this.config.outputDir, fileName);
      
      // G√©n√©rer le contenu du rapport selon le format
      let content: string;
      
      switch (this.config.reportFormat) {
        case 'json':
          content = this.generateJsonReport();
          break;
        case 'html':
          content = this.generateHtmlReport();
          break;
        case 'csv':
          content = this.generateCsvReport();
          break;
        case 'pdf':
          // La g√©n√©ration de PDF est g√©n√©ralement plus complexe et peut n√©cessiter des d√©pendances externes
          throw new Error('Format PDF non pris en charge pour l\'instant');
        case 'md':
        default:
          content = this.generateMarkdownReport();
          break;
      }
      
      // √âcrire le rapport dans le fichier
      await fs.writeFile(filePath, content);
      
      this.logger.info(`Rapport g√©n√©r√©: ${filePath}`);
      return filePath;
    } catch (error: any) {
      this.logger.error(`Erreur lors de la g√©n√©ration du rapport: ${error.message}`);
      return undefined;
    }
  }
  
  /**
   * G√©n√®re un rapport au format JSON
   */
  protected generateJsonReport(): string {
    return JSON.stringify({
      agent: {
        id: this.id,
        name: this.name,
        version: this.version
      },
      timestamp: this.analysisResult.timestamp,
      input: this.filePath || this.config.inputPath,
      result: this.analysisResult,
      errors: this.errors.map(err => err.message),
      warnings: this.warnings
    }, null, 2);
  }
  
  /**
   * G√©n√®re un rapport au format Markdown
   */
  protected generateMarkdownReport(): string {
    let markdown = `# Rapport d'analyse - ${this.name} v${this.version}\n\n`;
    
    // Informations g√©n√©rales
    markdown += `## Informations g√©n√©rales\n\n`;
    markdown += `- **Date d'analyse**: ${this.analysisResult.timestamp}\n`;
    markdown += `- **Score**: ${this.analysisResult.score}/100\n`;
    markdown += `- **Fichier analys√©**: ${this.filePath || this.config.inputPath || 'N/A'}\n`;
    markdown += `- **Dur√©e d'ex√©cution**: ${this.analysisResult.executionTimeMs}ms\n\n`;
    
    // M√©triques
    markdown += `## M√©triques\n\n`;
    markdown += `| M√©trique | Valeur |\n|----------|--------|\n`;
    
    for (const [key, value] of Object.entries(this.analysisResult.metrics)) {
      markdown += `| ${key} | ${value} |\n`;
    }
    
    markdown += `\n`;
    
    // Probl√®mes
    markdown += `## Probl√®mes d√©tect√©s (${this.analysisResult.issues.length})\n\n`;
    
    if (this.analysisResult.issues.length === 0) {
      markdown += `Aucun probl√®me d√©tect√©.\n\n`;
    } else {
      // Regrouper les probl√®mes par s√©v√©rit√©
      const issuesBySeverity = {
        critical: this.analysisResult.issues.filter(i => i.severity === 'critical'),
        error: this.analysisResult.issues.filter(i => i.severity === 'error'),
        warning: this.analysisResult.issues.filter(i => i.severity === 'warning'),
        info: this.analysisResult.issues.filter(i => i.severity === 'info')
      };
      
      // Afficher les probl√®mes critiques en premier
      for (const [severity, issues] of Object.entries(issuesBySeverity)) {
        if (issues.length > 0) {
          markdown += `### ${severity.charAt(0).toUpperCase() + severity.slice(1)} (${issues.length})\n\n`;
          
          for (const issue of issues) {
            markdown += `#### ${issue.code}: ${issue.message}\n\n`;
            
            if (issue.location && typeof issue.location !== 'string') {
              markdown += `- **Fichier**: ${issue.location.file}\n`;
              if (issue.location.line !== undefined) {
                markdown += `- **Ligne**: ${issue.location.line}\n`;
              }
            } else if (typeof issue.location === 'string') {
              markdown += `- **Fichier**: ${issue.location}\n`;
            }
            
            if (issue.suggestion) {
              markdown += `- **Suggestion**: ${issue.suggestion}\n`;
            }
            
            markdown += `\n`;
          }
        }
      }
    }
    
    // Suggestions
    if (this.analysisResult.suggestions.length > 0) {
      markdown += `## Suggestions d'am√©lioration\n\n`;
      
      for (const suggestion of this.analysisResult.suggestions) {
        markdown += `- ${suggestion}\n`;
      }
      
      markdown += `\n`;
    }
    
    // Erreurs d'ex√©cution
    if (this.errors.length > 0) {
      markdown += `## Erreurs d'ex√©cution\n\n`;
      
      for (const error of this.errors) {
        markdown += `- ${error.message}\n`;
      }
      
      markdown += `\n`;
    }
    
    return markdown;
  }
  
  /**
   * G√©n√®re un rapport au format HTML
   */
  protected generateHtmlReport(): string {
    // G√©n√©ration d'un rapport HTML basique
    let html = `
<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Rapport d'analyse - ${this.name}</title>
  <style>
    body { font-family: Arial, sans-serif; line-height: 1.6; color: #333; max-width: 1200px; margin: 0 auto; padding: 20px; }
    h1 { color: #2c3e50; border-bottom: 2px solid #3498db; padding-bottom: 10px; }
    h2 { color: #2c3e50; border-bottom: 1px solid #bdc3c7; padding-bottom: 5px; margin-top: 30px; }
    h3 { color: #2c3e50; }
    table { border-collapse: collapse; width: 100%; margin-bottom: 20px; }
    th, td { text-align: left; padding: 12px; border-bottom: 1px solid #ddd; }
    th { background-color: #f2f2f2; }
    tr:hover { background-color: #f5f5f5; }
    .info { background-color: #d1ecf1; border-radius: 4px; padding: 10px; }
    .warning { background-color: #fff3cd; border-radius: 4px; padding: 10px; }
    .error { background-color: #f8d7da; border-radius: 4px; padding: 10px; }
    .critical { background-color: #dc3545; color: white; border-radius: 4px; padding: 10px; }
    .score-container { display: flex; align-items: center; gap: 10px; }
    .score-circle { width: 100px; height: 100px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 24px; font-weight: bold; }
  </style>
</head>
<body>
  <h1>Rapport d'analyse - ${this.name} v${this.version}</h1>
  
  <div class="score-container">
    <div class="score-circle" style="background-color: ${this.getScoreColor(this.analysisResult.score || 0)}; color: white;">
      ${this.analysisResult.score}/100
    </div>
    <div>
      <p><strong>Date:</strong> ${this.analysisResult.timestamp}</p>
      <p><strong>Fichier analys√©:</strong> ${this.filePath || this.config.inputPath || 'N/A'}</p>
      <p><strong>Dur√©e d'ex√©cution:</strong> ${this.analysisResult.executionTimeMs}ms</p>
    </div>
  </div>
  
  <h2>M√©triques</h2>
  <table>
    <tr>
      <th>M√©trique</th>
      <th>Valeur</th>
    </tr>`;
    
    for (const [key, value] of Object.entries(this.analysisResult.metrics)) {
      html += `
    <tr>
      <td>${key}</td>
      <td>${value}</td>
    </tr>`;
    }
    
    html += `
  </table>
  
  <h2>Probl√®mes d√©tect√©s (${this.analysisResult.issues.length})</h2>`;
    
    if (this.analysisResult.issues.length === 0) {
      html += `
  <p>Aucun probl√®me d√©tect√©.</p>`;
    } else {
      // Regrouper les probl√®mes par s√©v√©rit√©
      const issuesBySeverity = {
        critical: this.analysisResult.issues.filter(i => i.severity === 'critical'),
        error: this.analysisResult.issues.filter(i => i.severity === 'error'),
        warning: this.analysisResult.issues.filter(i => i.severity === 'warning'),
        info: this.analysisResult.issues.filter(i => i.severity === 'info')
      };
      
      // Afficher les probl√®mes par s√©v√©rit√©
      for (const [severity, issues] of Object.entries(issuesBySeverity)) {
        if (issues.length > 0) {
          html += `
  <h3>${severity.charAt(0).toUpperCase() + severity.slice(1)} (${issues.length})</h3>`;
          
          for (const issue of issues) {
            html += `
  <div class="${severity}">
    <h4>${issue.code}: ${issue.message}</h4>`;
            
            if (issue.location && typeof issue.location !== 'string') {
              html += `
    <p><strong>Fichier:</strong> ${issue.location.file}`;
              if (issue.location.line !== undefined) {
                html += `, <strong>Ligne:</strong> ${issue.location.line}`;
              }
              html += `</p>`;
            } else if (typeof issue.location === 'string') {
              html += `
    <p><strong>Fichier:</strong> ${issue.location}</p>`;
            }
            
            if (issue.suggestion) {
              html += `
    <p><strong>Suggestion:</strong> ${issue.suggestion}</p>`;
            }
            
            html += `
  </div>`;
          }
        }
      }
    }
    
    // Suggestions
    if (this.analysisResult.suggestions.length > 0) {
      html += `
  <h2>Suggestions d'am√©lioration</h2>
  <ul>`;
      
      for (const suggestion of this.analysisResult.suggestions) {
        html += `
    <li>${suggestion}</li>`;
      }
      
      html += `
  </ul>`;
    }
    
    // Erreurs d'ex√©cution
    if (this.errors.length > 0) {
      html += `
  <h2>Erreurs d'ex√©cution</h2>
  <ul>`;
      
      for (const error of this.errors) {
        html += `
    <li>${error.message}</li>`;
      }
      
      html += `
  </ul>`;
    }
    
    html += `
</body>
</html>`;
    
    return html;
  }
  
  /**
   * G√©n√®re un rapport au format CSV
   */
  protected generateCsvReport(): string {
    let csv = 'Type,Code,Severity,Message,File,Line,Column,Suggestion\n';
    
    // Ajouter les probl√®mes
    for (const issue of this.analysisResult.issues) {
      const row = [
        'issue',
        issue.code || '',
        issue.severity,
        `"${issue.message.replace(/"/g, '""')}"`,
        typeof issue.location === 'string' ? issue.location : issue.location?.file || '',
        typeof issue.location === 'string' ? '' : issue.location?.line || '',
        typeof issue.location === 'string' ? '' : issue.location?.column || '',
        issue.suggestion ? `"${issue.suggestion.replace(/"/g, '""')}"` : ''
      ];
      
      csv += row.join(',') + '\n';
    }
    
    // Ajouter les suggestions
    for (const suggestion of this.analysisResult.suggestions) {
      const row = [
        'suggestion',
        '',
        'info',
        `"${suggestion.replace(/"/g, '""')}"`,
        '',
        '',
        '',
        ''
      ];
      
      csv += row.join(',') + '\n';
    }
    
    // Ajouter les erreurs
    for (const error of this.errors) {
      const row = [
        'error',
        '',
        'error',
        `"${error.message.replace(/"/g, '""')}"`,
        '',
        '',
        '',
        ''
      ];
      
      csv += row.join(',') + '\n';
    }
    
    return csv;
  }
  
  /**
   * Utilitaire pour normaliser un AnalysisIssue afin d'assurer que location est toujours un objet ou undefined
   */
  protected normalizeIssue(issue: AnalysisIssue): AnalysisIssue {
    if (!issue.location) {
      return issue;
    }
    
    // Si location est une cha√Æne, la convertir en objet
    if (typeof issue.location === 'string') {
      return {
        ...issue,
        location: {
          file: issue.location
        }
      };
    }
    
    return issue;
  }

  /**
   * Ajoute un probl√®me au r√©sultat d'analyse
   * @param issue Probl√®me √† ajouter
   */
  protected addIssue(issue: AnalysisIssue): void {
    // Normaliser l'issue avant de l'ajouter
    const normalizedIssue = this.normalizeIssue(issue);
    this.analysisResult.issues.push(normalizedIssue);
    
    const severity = normalizedIssue.severity === 'critical' ? 'üî¥' :
                     normalizedIssue.severity === 'error' ? 'üü†' :
                     normalizedIssue.severity === 'warning' ? 'üü°' : 'üîµ';
    
    const location = normalizedIssue.location ? 
      (typeof normalizedIssue.location === 'string' ? 
        normalizedIssue.location : 
        `${normalizedIssue.location.file}${normalizedIssue.location.line ? `:${normalizedIssue.location.line}` : ''}`) : 
      'N/A';
    
    this.logger.debug(`${severity} Probl√®me d√©tect√©: [${normalizedIssue.code}] ${normalizedIssue.message} (${location})`);
  }
  
  /**
   * Ajoute une suggestion au r√©sultat d'analyse
   * @param suggestion Suggestion √† ajouter
   */
  protected addSuggestion(suggestion: string): void {
    this.analysisResult.suggestions.push(suggestion);
    this.logger.debug(`üí° Suggestion: ${suggestion}`);
  }
  
  /**
   * Ajoute une m√©trique au r√©sultat d'analyse
   * @param key Cl√© de la m√©trique
   * @param value Valeur de la m√©trique
   */
  protected addMetric(key: string, value: number | string | boolean): void {
    this.analysisResult.metrics[key] = value;
  }
  
  /**
   * Ajoute une erreur √† la liste
   * @param error Erreur √† ajouter
   */
  protected addError(error: Error | string): void {
    const err = typeof error === 'string' ? new Error(error) : error;
    this.errors.push(err);
    this.logger.error(err.message);
  }
  
  /**
   * Ajoute un avertissement √† la liste
   * @param warning Message d'avertissement
   */
  protected addWarning(warning: string): void {
    this.warnings.push(warning);
    this.logger.warn(warning);
  }
  
  /**
   * Retourne le nombre de v√©rifications r√©ussies
   * (par d√©faut, la somme des probl√®mes de type info)
   */
  protected getPassedChecksCount(): number {
    // Par d√©faut, on compte les probl√®mes de type info comme des v√©rifications r√©ussies
    return this.analysisResult.issues.filter(i => i.severity === 'info').length;
  }
  
  /**
   * Calcule le score global (0-100) bas√© sur les probl√®mes d√©tect√©s
   */
  protected calculateScore(): number {
    // Poids par s√©v√©rit√© pour le calcul du score
    const weights = {
      info: 0,
      warning: 1,
      error: 10,
      critical: 25
    };
    
    // Calculer la somme pond√©r√©e des probl√®mes
    let weightedSum = 0;
    let totalChecks = 1; // √âviter la division par z√©ro
    
    for (const issue of this.analysisResult.issues) {
      weightedSum += weights[issue.severity] || 0;
      totalChecks++;
    }
    
    // Calculer le score (invers√© car plus de probl√®mes = score plus bas)
    // La formule est adaptable selon les besoins
    const maxPossibleScore = totalChecks * weights.critical;
    const normalizedScore = 1 - (weightedSum / maxPossibleScore);
    
    // Convertir en score sur 100 et arrondir
    return Math.round(normalizedScore * 100);
  }
  
  /**
   * Retourne une couleur en fonction du score
   * @param score Score entre 0 et 100
   */
  protected getScoreColor(score: number): string {
    if (score >= 90) return '#27ae60'; // Vert
    if (score >= 75) return '#2ecc71'; // Vert clair
    if (score >= 60) return '#f1c40f'; // Jaune
    if (score >= 40) return '#e67e22'; // Orange
    return '#e74c3c'; // Rouge
  }
  
  /**
   * Nettoie les ressources utilis√©es par l'agent
   */
  public async cleanup(): Promise<void> {
    this.logger.info(`Nettoyage de l'agent ${this.name}`);
    
    // R√©initialiser l'√©tat pour future utilisation
    this.files.clear();
    this.fileContent = undefined;
    
    // Les erreurs et avertissements sont conserv√©s pour la tra√ßabilit√©
  }
  
  /**
   * Retourne les agents dont celui-ci d√©pend
   */
  public getDependencies(): string[] {
    return []; // Par d√©faut, aucune d√©pendance
  }
  
  /**
   * Traite la demande d'ex√©cution et retourne le r√©sultat
   */
  public async process(): Promise<AgentResult> {
    const startTime = Date.now();
    
    try {
      // Cr√©er un contexte minimal si n√©cessaire
      const context: AgentContext = {
        getConfig: () => this.config,
        logger: this.logger
      };
      
      // Initialiser l'agent
      await this.initialize(context);
      
      // Ex√©cuter l'analyse
      await this.execute(context);
      
      // Nettoyer les ressources
      await this.cleanup();
      
      // Construire le r√©sultat
      const result: AgentResult = {
        success: this.errors.length === 0,
        message: `Analyse termin√©e avec un score de ${this.analysisResult.score}/100`,
        data: this.analysisResult,
        errors: this.errors.length > 0 ? this.errors : undefined,
        warnings: this.warnings.length > 0 ? this.warnings : undefined,
        artifacts: this.artifacts.length > 0 ? this.artifacts : undefined,
        metrics: {
          score: this.analysisResult.score,
          issues: this.analysisResult.issues.length,
          critical: this.analysisResult.issues.filter(i => i.severity === 'critical').length,
          errors: this.analysisResult.issues.filter(i => i.severity === 'error').length,
          warnings: this.analysisResult.issues.filter(i => i.severity === 'warning').length,
          info: this.analysisResult.issues.filter(i => i.severity === 'info').length,
          executionTimeMs: Date.now() - startTime
        },
        executionTimeMs: Date.now() - startTime,
        timestamp: new Date().toISOString()
      };
      
      return result;
    } catch (error: any) {
      const errorObj = error instanceof Error ? error : new Error(String(error));
      this.errors.push(errorObj);
      
      return {
        success: false,
        message: `√âchec de l'analyse: ${errorObj.message}`,
        errors: [errorObj],
        warnings: this.warnings.length > 0 ? this.warnings : undefined,
        executionTimeMs: Date.now() - startTime,
        timestamp: new Date().toISOString()
      };
    }
  }
  
  /**
   * R√©cup√®re l'√©tat actuel de l'agent business
   */
  async getState(): Promise<Record<string, any>> {
    return {
      status: 'active',
      timestamp: new Date().toISOString()
    };
  }

  /**
   * Pr√©paration sp√©cifique de l'agent avant l'analyse
   * M√©thode optionnelle √† impl√©menter dans les sous-classes
   */
  protected prepare?(): Promise<void>;
}





































































































































































































































































































































































































































































































































































































































































































































































































































