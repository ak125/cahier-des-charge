// Fichier adapt√© pour la nouvelle architecture √† trois couches
import { Agent, AgentResult, AgentStatus, AgentHealthState } from '../core/interfaces/base-agent';
import { ValidatorAgent, ValidatorConfig, ValidationRule, ValidationResult, ValidationViolation } from '../core/interfaces/validator-agent';
import { BusinessAgent } from '../core/interfaces/business';
import { AgentContext } from '../core/mcp-agent';
import * as fs from 'fs-extra';
import * as path from 'path';
import { Logger } from '../utils/logger';

/**
 * Classe abstraite pour les agents de validation
 * Fournit une impl√©mentation de base des m√©thodes communes aux validateurs
 */
export abstract class AbstractValidatorAgent<TConfig extends ValidatorConfig = ValidatorConfig> implements ValidatorAgent<TConfig>, BusinessAgent {
  /**
   * Identifiant unique de l'agent
   */
  public abstract id: string;

  /**
   * Version de l'agent
   */
  public abstract version: string;

  /**
   * Nom descriptif de l'agent
   */
  public abstract name: string;

  /**
   * Description des fonctionnalit√©s de l'agent
   */
  public abstract description: string;

  /**
   * Chemin du fichier ou des donn√©es √† valider
   */
  public filePath?: string;

  /**
   * Contenu du fichier ou des donn√©es √† valider
   */
  public fileContent?: string;

  /**
   * Configuration du validateur
   */
  public config: TConfig;

  /**
   * R√®gles de validation utilis√©es par l'agent
   */
  public rules: ValidationRule[] = [];

  /**
   * R√©sultat de la derni√®re validation
   */
  public validationResult?: ValidationResult;

  /**
   * Erreurs rencontr√©es pendant la validation
   */
  public errors: Error[] = [];

  /**
   * Avertissements g√©n√©r√©s pendant la validation
   */
  public warnings: string[] = [];

  /**
   * Artefacts g√©n√©r√©s (chemins de fichiers)
   */
  public artifacts: string[] = [];

  /**
   * Logger utilis√© par l'agent
   */
  protected logger: Logger;

  /**
   * √âtat de sant√© de l'agent
   */
  private _status: AgentStatus = {
    health: AgentHealthState.STOPPED,
    successCount: 0,
    failureCount: 0
  };

  /**
   * Constructeur
   * @param filePath Chemin du fichier √† valider (optionnel)
   * @param config Configuration du validateur
   */
  constructor(filePath?: string, config?: Partial<TConfig>) {
    this.filePath = filePath;
    this.config = {
      threshold: 80, // Score minimal par d√©faut
      minSeverity: 'warning', // S√©v√©rit√© minimale √† reporter par d√©faut
      strictMode: false, // Mode strict d√©sactiv√© par d√©faut
      outputDir: './validation-reports',
      ...(config || {})
    } as TConfig;
    
    this.logger = new Logger(this.getName() || 'AbstractValidatorAgent');
  }

  /**
   * Initialise l'agent avec ses d√©pendances et configuration
   */
  public async initialize(): Promise<void> {
    this._status.health = AgentHealthState.STARTING;
    
    // Charge les donn√©es si un chemin est fourni mais que le contenu n'est pas encore charg√©
    if (this.filePath && !this.fileContent) {
      await this.loadData();
    }
    
    // Charge les r√®gles de validation par d√©faut
    await this.loadDefaultRules();

    this._status.health = AgentHealthState.HEALTHY;
    this.logger.info(`Agent ${this.getName()} (v${this.getVersion()}) initialis√© avec ${this.rules.length} r√®gles`);
  }

  /**
   * Ex√©cute l'agent et retourne le r√©sultat
   */
  public async process(): Promise<AgentResult> {
    const startTime = Date.now();
    this._status.lastRun = new Date();
    
    try {
      // Initialiser si ce n'est pas d√©j√† fait
      if (this._status.health === AgentHealthState.STOPPED) {
        await this.initialize();
      }
      
      // Ex√©cuter la validation
      this.validationResult = await this.validate();
      
      // G√©n√©rer le rapport de validation
      const reportPath = await this.generateReport();
      if (reportPath) {
        this.artifacts.push(reportPath);
      }
      
      const endTime = Date.now();
      this._status.lastRunDuration = endTime - startTime;
      
      // Mise √† jour des statistiques de succ√®s/√©chec
      if (this.isValid()) {
        this._status.successCount = (this._status.successCount || 0) + 1;
      } else {
        this._status.failureCount = (this._status.failureCount || 0) + 1;
      }
      
      // Pr√©parer la r√©ponse avec les r√©sultats de la validation
      return {
        success: this.errors.length === 0 && this.isValid(),
        message: this.isValid() 
          ? `Validation r√©ussie avec un score de ${this.validationResult.score}%`
          : `Validation √©chou√©e avec un score de ${this.validationResult.score}% (seuil: ${this.config.threshold}%)`,
        data: {
          validationResult: this.validationResult,
          isValid: this.isValid(),
          score: this.validationResult.score
        },
        errors: this.errors,
        warnings: this.warnings,
        artifacts: this.artifacts,
        metrics: {
          executionTime: endTime - startTime,
          score: this.validationResult.score,
          totalChecks: this.validationResult.stats.totalChecks,
          passedChecks: this.validationResult.stats.passedChecks,
          failedChecks: this.validationResult.stats.failedChecks,
          errorCount: this.validationResult.stats.errorCount,
          warningCount: this.validationResult.stats.warningCount
        }
      };
    } catch (error) {
      const endTime = Date.now();
      this._status.lastRunDuration = endTime - startTime;
      this._status.failureCount = (this._status.failureCount || 0) + 1;
      this._status.health = AgentHealthState.DEGRADED;
      
      const errorObj = error instanceof Error ? error : new Error(String(error));
      this.errors.push(errorObj);
      
      this.logger.error(`Erreur lors de l'ex√©cution du validateur: ${errorObj.message}`);
      
      return {
        success: false,
        message: `√âchec de la validation: ${errorObj.message}`,
        errors: [errorObj],
        warnings: this.warnings
      };
    }
  }

  /**
   * Renvoie le statut actuel de l'agent
   */
  public getStatus(): AgentStatus {
    return { ...this._status };
  }

  /**
   * Nettoie les ressources utilis√©es par l'agent
   */
  public async cleanup(): Promise<void> {
    // Lib√©rer les ressources potentiellement utilis√©es par le validateur
    this.fileContent = undefined;
    this._status.health = AgentHealthState.STOPPED;
    this.logger.info(`Agent ${this.getName()} nettoy√©`);
  }

  /**
   * Renvoie les agents dont celui-ci d√©pend
   * √Ä surcharger dans les classes d√©riv√©es selon leurs d√©pendances
   */
  public getDependencies(): string[] {
    return [];
  }

  /**
   * Renvoie le nom de l'agent
   * Par d√©faut utilise le nom de la classe
   */
  public getName(): string {
    return this.name || this.constructor.name;
  }

  /**
   * Renvoie la version de l'agent
   * √Ä surcharger dans les classes d√©riv√©es
   */
  public getVersion(): string {
    return this.version || '1.0.0';
  }

  /**
   * Charge les donn√©es √† valider
   */
  public async loadData(): Promise<void> {
    if (!this.filePath) {
      throw new Error('Aucun chemin de fichier √† valider sp√©cifi√©');
    }
    
    try {
      // V√©rifier si le fichier existe
      if (!await fs.pathExists(this.filePath)) {
        throw new Error(`Le fichier ${this.filePath} n'existe pas`);
      }
      
      // Charger le contenu du fichier
      this.fileContent = await fs.readFile(this.filePath, 'utf-8');
      this.logger.debug(`Fichier √† valider charg√©: ${this.filePath}`);
    } catch (error: any) {
      const errorMessage = error.message || String(error);
      const newError = new Error(`Erreur lors du chargement des donn√©es √† valider: ${errorMessage}`);
      this.errors.push(newError);
      throw newError;
    }
  }

  /**
   * Charge les r√®gles de validation par d√©faut
   * √Ä surcharger dans les classes d√©riv√©es pour d√©finir les r√®gles sp√©cifiques
   */
  protected async loadDefaultRules(): Promise<void> {
    // Cette m√©thode doit √™tre impl√©ment√©e par les classes d√©riv√©es pour charger les r√®gles sp√©cifiques
  }

  /**
   * Effectue la validation selon les r√®gles d√©finies
   * √Ä impl√©menter dans les classes d√©riv√©es
   */
  public abstract validate(): Promise<ValidationResult>;

  /**
   * Ajoute une r√®gle de validation
   */
  public addRule(rule: ValidationRule): void {
    // V√©rifier si la r√®gle existe d√©j√† (par son id)
    const existingRuleIndex = this.rules.findIndex(r => r.id === rule.id);
    
    if (existingRuleIndex >= 0) {
      // Mettre √† jour la r√®gle existante
      this.rules[existingRuleIndex] = { ...rule };
      this.logger.debug(`R√®gle de validation mise √† jour: ${rule.id}`);
    } else {
      // Ajouter la nouvelle r√®gle
      this.rules.push({ ...rule });
      this.logger.debug(`R√®gle de validation ajout√©e: ${rule.id}`);
    }
  }

  /**
   * Active ou d√©sactive une r√®gle de validation
   */
  public setRuleEnabled(ruleId: string, enabled: boolean): void {
    const ruleIndex = this.rules.findIndex(rule => rule.id === ruleId);
    
    if (ruleIndex >= 0) {
      this.rules[ruleIndex].enabled = enabled;
      this.logger.debug(`R√®gle ${ruleId} ${enabled ? 'activ√©e' : 'd√©sactiv√©e'}`);
    } else {
      this.logger.warn(`Impossible de ${enabled ? 'activer' : 'd√©sactiver'} la r√®gle ${ruleId}: r√®gle non trouv√©e`);
    }
  }

  /**
   * G√©n√®re un rapport de validation
   */
  public async generateReport(format: string = 'json'): Promise<string> {
    if (!this.validationResult) {
      throw new Error('Aucun r√©sultat de validation disponible');
    }
    
    // S'assurer que le r√©pertoire de sortie existe
    await fs.ensureDir(this.config.outputDir!);
    
    const fileName = `${path.basename(this.filePath || 'validation')}-${this.getName()}-${new Date().toISOString().replace(/[:.]/g, '-')}`;
    const filePath = path.join(this.config.outputDir!, `${fileName}.${format}`);
    
    try {
      let content: string;
      
      if (format === 'json') {
        const reportObj = {
          agent: {
            name: this.getName(),
            version: this.getVersion(),
            id: this.id
          },
          target: this.filePath,
          timestamp: new Date().toISOString(),
          configuration: {
            threshold: this.config.threshold,
            strictMode: this.config.strictMode,
            minSeverity: this.config.minSeverity
          },
          result: {
            isValid: this.isValid(),
            score: this.validationResult.score,
            violationCount: this.validationResult.violations.length,
            statistics: this.validationResult.stats
          },
          violations: this.validationResult.violations,
          errors: this.errors.map(err => err.message),
          warnings: this.warnings
        };
        content = JSON.stringify(reportObj, null, 2);
      } else if (format === 'md') {
        content = this.generateMarkdownReport();
      } else {
        throw new Error(`Format de rapport non support√©: ${format}`);
      }
      
      await fs.writeFile(filePath, content, 'utf-8');
      this.logger.info(`Rapport de validation g√©n√©r√©: ${filePath}`);
      
      return filePath;
    } catch (error: any) {
      const errorMessage = error.message || String(error);
      this.warnings.push(`Erreur lors de la g√©n√©ration du rapport: ${errorMessage}`);
      return '';
    }
  }

  /**
   * G√©n√®re un rapport au format Markdown
   */
  protected generateMarkdownReport(): string {
    if (!this.validationResult) {
      throw new Error('Aucun r√©sultat de validation disponible');
    }
    
    let md = `# Rapport de validation: ${path.basename(this.filePath || 'unknown')}\n\n`;
    md += `G√©n√©r√© par: ${this.getName()} v${this.getVersion()}\n`;
    md += `Date: ${new Date().toISOString()}\n\n`;
    
    // R√©sum√© de la validation
    md += `## R√©sum√©\n\n`;
    md += `- **Statut**: ${this.isValid() ? '‚úÖ Valide' : '‚ùå Invalide'}\n`;
    md += `- **Score**: ${this.validationResult.score}% (seuil: ${this.config.threshold}%)\n`;
    md += `- **V√©rifications**: ${this.validationResult.stats.passedChecks}/${this.validationResult.stats.totalChecks} r√©ussies\n`;
    md += `- **Violations**: ${this.validationResult.violations.length} (${this.validationResult.stats.errorCount} erreurs, ${this.validationResult.stats.warningCount} avertissements, ${this.validationResult.stats.infoCount} infos)\n\n`;
    
    // Afficher les violations
    if (this.validationResult.violations.length > 0) {
      md += `## Violations\n\n`;
      
      // Grouper les violations par s√©v√©rit√©
      const violationsBySeverity: Record<string, ValidationViolation[]> = {
        error: [],
        warning: [],
        info: []
      };
      
      this.validationResult.violations.forEach(violation => {
        violationsBySeverity[violation.severity].push(violation);
      });
      
      // Erreurs
      if (violationsBySeverity.error.length > 0) {
        md += `### ‚ùå Erreurs (${violationsBySeverity.error.length})\n\n`;
        violationsBySeverity.error.forEach(violation => {
          md += `- **[${violation.ruleId}]**: ${violation.message}\n`;
          if (violation.location && violation.location.file) {
            md += `  - *${violation.location.file}${violation.location.line ? `:${violation.location.line}` : ''}*\n`;
          }
          if (violation.recommendation) {
            md += `  - üí° ${violation.recommendation}\n`;
          }
          md += '\n';
        });
      }
      
      // Avertissements
      if (violationsBySeverity.warning.length > 0) {
        md += `### ‚ö†Ô∏è Avertissements (${violationsBySeverity.warning.length})\n\n`;
        violationsBySeverity.warning.forEach(violation => {
          md += `- **[${violation.ruleId}]**: ${violation.message}\n`;
          if (violation.location && violation.location.file) {
            md += `  - *${violation.location.file}${violation.location.line ? `:${violation.location.line}` : ''}*\n`;
          }
          if (violation.recommendation) {
            md += `  - üí° ${violation.recommendation}\n`;
          }
          md += '\n';
        });
      }
      
      // Infos
      if (violationsBySeverity.info.length > 0) {
        md += `### ‚ÑπÔ∏è Informations (${violationsBySeverity.info.length})\n\n`;
        violationsBySeverity.info.forEach(violation => {
          md += `- **[${violation.ruleId}]**: ${violation.message}\n`;
          if (violation.location && violation.location.file) {
            md += `  - *${violation.location.file}${violation.location.line ? `:${violation.location.line}` : ''}*\n`;
          }
          if (violation.recommendation) {
            md += `  - üí° ${violation.recommendation}\n`;
          }
          md += '\n';
        });
      }
    }
    
    // Afficher les erreurs d'ex√©cution
    if (this.errors.length > 0) {
      md += `## Erreurs d'ex√©cution\n\n`;
      this.errors.forEach(err => {
        md += `- ${err.message}\n`;
      });
      md += '\n';
    }
    
    // Afficher les avertissements d'ex√©cution
    if (this.warnings.length > 0) {
      md += `## Avertissements d'ex√©cution\n\n`;
      this.warnings.forEach(warning => {
        md += `- ${warning}\n`;
      });
      md += '\n';
    }
    
    return md;
  }

  /**
   * D√©termine si les r√©sultats de la validation sont conformes au seuil configur√©
   */
  public isValid(): boolean {
    if (!this.validationResult) {
      return false;
    }
    
    // En mode strict, on v√©rifie aussi qu'il n'y a aucune violation de type 'error'
    if (this.config.strictMode && this.validationResult.stats.errorCount > 0) {
      return false;
    }
    
    // Sinon, on v√©rifie juste le score par rapport au seuil
    return this.validationResult.isValid && this.validationResult.score >= (this.config.threshold || 0);
  }
}
































































































































































































































































































































































































































































































