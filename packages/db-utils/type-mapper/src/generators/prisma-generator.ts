/**
 * Module de génération de schéma Prisma
 */
import { 
  TableMappingResult, 
  EnumType,
  PrismaSchemaOptions
} from '../types';

/**
 * Classe pour générer un schéma Prisma à partir des informations de mapping
 */
export class PrismaGenerator {
  /**
   * Génère un schéma Prisma à partir des résultats de mapping et des énumérations détectées
   * @param tables Tables mappées
   * @param enums Énumérations détectées
   * @param options Options de génération
   */
  public generateSchema(
    tables: TableMappingResult[], 
    enums: EnumType[],
    options: PrismaSchemaOptions = {}
  ): string {
    const {
      datasourceProvider = 'postgresql',
      datasourceUrl = process.env.DATABASE_URL || 'postgresql://postgres:postgres@localhost:5432/postgres',
      useEnumTypes = true,
      mapTableNames = true,
      includeComments = true,
    } = options;
    
    let schema = this.generateHeader(datasourceProvider, datasourceUrl);
    
    // Générer les types énumérés
    if (useEnumTypes && enums.length > 0) {
      schema += '\n// Enum types\n';
      
      enums.forEach(enumType => {
        schema += this.generateEnumType(enumType);
      });
      
      schema += '\n';
    }
    
    // Générer les modèles
    schema += '\n// Models\n';
    
    tables.forEach(table => {
      schema += this.generateModel(table, enums, { 
        mapTableNames,
        includeComments,
        useEnumTypes
      });
    });
    
    return schema;
  }
  
  /**
   * Génère l'en-tête du schéma avec les datasources et générateurs
   */
  private generateHeader(provider: string, url: string): string {
    return `// This schema was generated by @projet/db-utils-type-mapper
// Manual edits may be overwritten - make sure to back up this file

datasource db {
  provider = "${provider}"
  url      = "${url}"
}

generator client {
  provider = "prisma-client-js"
}

`;
  }
  
  /**
   * Génère un type énuméré pour Prisma
   */
  private generateEnumType(enumType: EnumType): string {
    const name = this.toPascalCase(enumType.name);
    
    let enumDefinition = `enum ${name} {\n`;
    
    // Ajouter chaque valeur de l'énumération
    enumType.values.forEach(value => {
      // Normaliser la valeur pour qu'elle soit valide en Prisma
      const normalizedValue = this.normalizeEnumValue(value);
      enumDefinition += `  ${normalizedValue}\n`;
    });
    
    enumDefinition += '}\n';
    
    return enumDefinition;
  }
  
  /**
   * Normalise une valeur d'énumération pour qu'elle soit valide en Prisma
   * Les valeurs d'énumération en Prisma ne peuvent contenir que des lettres,
   * chiffres et underscores, et ne peuvent pas commencer par un chiffre
   */
  private normalizeEnumValue(value: string): string {
    // Remplacer les caractères non autorisés par des underscores
    let normalized = value
      .replace(/[^a-zA-Z0-9_]/g, '_')
      .replace(/_+/g, '_')
      .replace(/^_|_$/g, '');
    
    // Si la valeur commence par un chiffre, ajouter un préfixe
    if (/^\d/.test(normalized)) {
      normalized = `V_${normalized}`;
    }
    
    return normalized;
  }
  
  /**
   * Génère un modèle Prisma à partir d'une table mappée
   */
  private generateModel(
    table: TableMappingResult,
    enums: EnumType[],
    options: {
      mapTableNames: boolean;
      includeComments: boolean;
      useEnumTypes: boolean;
    }
  ): string {
    const { mapTableNames, includeComments, useEnumTypes } = options;
    
    // Nom du modèle
    const modelName = mapTableNames 
      ? this.toPascalCase(table.prismaModel) 
      : table.prismaModel;
    
    let modelDefinition = `model ${modelName} {\n`;
    
    // Ajouter chaque champ du modèle
    table.columns.forEach(column => {
      const fieldName = this.toCamelCase(column.prismaField);
      let fieldType = column.prismaType;
      
      // Si le type est une énumération et que les types enum sont activés
      if (useEnumTypes) {
        // Vérifier si cette colonne correspond à une énumération détectée
        const matchingEnum = enums.find(
          e => e.originalColumn && 
          e.originalColumn.table === table.mysqlName && 
          e.originalColumn.column === column.mysqlName
        );
        
        if (matchingEnum) {
          fieldType = this.toPascalCase(matchingEnum.name);
        }
      }
      
      // Gérer la nullabilité
      const nullable = column.nullable ? '?' : '';
      
      // Construire les attributs
      const attributes: string[] = [];
      
      // Attribut db pour spécifier le nom d'origine de la colonne
      if (fieldName !== column.mysqlName) {
        attributes.push(`@map("${column.mysqlName}")`);
      }
      
      // Attribut pour le type PostgreSQL spécifique
      if (column.postgresType) {
        attributes.push(`@db.${column.postgresType}`);
      }
      
      // Ajouter d'autres attributs selon les besoins...
      
      // Construire la ligne de champ
      let fieldLine = `  ${fieldName} ${fieldType}${nullable}`;
      
      if (attributes.length > 0) {
        fieldLine += ` ${attributes.join(' ')}`;
      }
      
      // Ajouter un commentaire si demandé et disponible
      if (includeComments && column.comment) {
        fieldLine += ` // ${column.comment}`;
      }
      
      modelDefinition += `${fieldLine}\n`;
    });
    
    // Ajouter les relations (à implémenter si nécessaire)
    
    // Ajouter les contraintes et indexes
    if (table.indexes && table.indexes.length > 0) {
      modelDefinition += '\n  // Indexes\n';
      
      table.indexes.forEach(index => {
        const fields = index.columns.map(c => this.toCamelCase(c));
        const fieldsStr = fields.map(f => `"${f}"`).join(', ');
        
        if (index.unique) {
          modelDefinition += `  @@unique([${fieldsStr}], name: "${index.postgresName}")\n`;
        } else {
          modelDefinition += `  @@index([${fieldsStr}], name: "${index.postgresName}")\n`;
        }
      });
    }
    
    // Ajouter l'attribut de mappage de table si le nom du modèle diffère du nom de la table
    if (mapTableNames && modelName !== table.mysqlName) {
      modelDefinition += `\n  @@map("${table.mysqlName}")\n`;
    }
    
    // Fermer la définition du modèle
    modelDefinition += '}\n\n';
    
    return modelDefinition;
  }
  
  /**
   * Convertit une chaîne en format PascalCase
   */
  private toPascalCase(str: string): string {
    return str
      // Diviser par les underscores, espaces et tirets
      .replace(/[_\s-]+(.)?/g, (_, c) => c ? c.toUpperCase() : '')
      // Assurer que le premier caractère est en majuscule
      .replace(/^(.)/, (_, c) => c.toUpperCase());
  }
  
  /**
   * Convertit une chaîne en format camelCase
   */
  private toCamelCase(str: string): string {
    return str
      // Diviser par les underscores, espaces et tirets
      .replace(/[_\s-]+(.)?/g, (_, c) => c ? c.toUpperCase() : '')
      // Assurer que le premier caractère est en minuscule
      .replace(/^(.)/, (_, c) => c.toLowerCase());
  }
}