// Ce fichier contient les modèles Prisma suggérés basés sur l'analyse de votre schéma SQL actuel
// Générés automatiquement par le SQL Analyzer le 2025-04-12

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Types personnalisés
enum UserStatus {
  ACTIVE
  INACTIVE
  SUSPENDED
  DELETED
}

enum OrderStatus {
  PENDING
  PROCESSING
  COMPLETED
  CANCELLED
  REFUNDED
}

enum PaymentMethod {
  CREDIT_CARD
  PAYPAL
  BANK_TRANSFER
  CRYPTO
}

// Modèles principaux
model User {
  id              BigInt     @id @default(autoincrement())
  email           String     @unique
  username        String?
  passwordHash    String
  firstName       String?
  lastName        String?
  status          UserStatus @default(ACTIVE)
  balance         Decimal    @db.Decimal(10, 2) // Converti de FLOAT pour plus de précision
  createdAt       DateTime   @default(now()) @db.Timestamptz(6)
  updatedAt       DateTime?  @updatedAt @db.Timestamptz(6)
  lastLoginAt     DateTime?  @db.Timestamptz(6)
  verifiedAt      DateTime?  @db.Timestamptz(6)
  profileImageUrl String?
  isAdmin         Boolean    @default(false) @map("is_admin")
  
  // Relations
  orders          Order[]
  paymentMethods  PaymentMethod[]
  addresses       Address[]
  reviews         Review[]
  wishlistItems   WishlistItem[]
  profile         Profile?
  sessions        Session[]
  
  // Indices recommandés
  @@index([email, status], name: "idx_users_email_status")
  
  // Contraintes personnalisées (implémentées au niveau application ou via migrations SQL)
  // CHECK (char_length(email) > 5 AND email LIKE '%@%.%')
  @@map("users")
}

model Product {
  id              Int       @id @default(autoincrement())
  name            String
  description     String?   @db.Text
  price           Decimal   @db.Decimal(10, 2) // Converti de FLOAT pour plus de précision
  stockQuantity   Int       @default(0)
  sku             String    @unique
  attributes      Json?     // Converti de TEXT à JSONB
  isActive        Boolean   @default(true)
  createdAt       DateTime  @default(now()) @db.Timestamptz(6)
  updatedAt       DateTime  @updatedAt @db.Timestamptz(6)
  categoryId      Int
  
  // Relations
  category        Category  @relation(fields: [categoryId], references: [id])
  orderItems      OrderItem[]
  reviews         Review[]
  wishlistItems   WishlistItem[]
  
  // Indices recommandés
  @@index([name], type: Gin, name: "idx_products_name_gin") // Index GIN pour recherche textuelle
  @@index([categoryId], name: "idx_products_category_id")
  @@index([price], name: "idx_products_price")
  
  // Contraintes personnalisées
  // CHECK (price >= 0)
}

model Order {
  id              Int         @id @default(autoincrement())
  userId          Int
  status          OrderStatus @default(PENDING)
  totalAmount     Decimal     @db.Decimal(10, 2) // Converti de FLOAT pour plus de précision
  shippingAddress String?     @db.Text
  createdAt       DateTime    @default(now()) @db.Timestamptz(6)
  updatedAt       DateTime    @updatedAt @db.Timestamptz(6)
  completedAt     DateTime?   @db.Timestamptz(6)
  
  // Relations
  user            User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  orderItems      OrderItem[]
  paymentTransactions PaymentTransaction[]
  
  // Indices recommandés
  @@index([userId], name: "idx_orders_user_id")
  @@index([status], name: "idx_orders_status")
  @@index([createdAt], name: "idx_orders_created_at")
  
  // Contraintes personnalisées
  // CHECK (totalAmount > 0)
}

model OrderItem {
  id              Int       @id @default(autoincrement())
  orderId         Int
  productId       Int
  quantity        Int
  unitPrice       Decimal   @db.Decimal(10, 2) // Converti de FLOAT pour plus de précision
  
  // Relations
  order           Order     @relation(fields: [orderId], references: [id], onDelete: Cascade)
  product         Product   @relation(fields: [productId], references: [id])
  
  // Indices recommandés
  @@index([orderId], name: "idx_order_items_order_id")
  @@index([productId], name: "idx_order_items_product_id")
  
  // Contraintes personnalisées
  // CHECK (quantity > 0)
  // CHECK (unitPrice >= 0)
}

model Category {
  id              Int       @id @default(autoincrement())
  name            String
  description     String?   @db.Text
  parentId        Int?
  path            String?   // Nouvel attribut pour la hiérarchie
  createdAt       DateTime  @default(now()) @db.Timestamptz(6)
  updatedAt       DateTime  @updatedAt @db.Timestamptz(6)
  
  // Relations
  parent          Category? @relation("CategoryHierarchy", fields: [parentId], references: [id])
  children        Category[] @relation("CategoryHierarchy")
  products        Product[]
  
  // Indices recommandés
  @@index([parentId], name: "idx_categories_parent_id")
  @@index([path], type: Gist, name: "idx_categories_path_gist") // Pour les requêtes hiérarchiques
}

model PaymentTransaction {
  id              Int       @id @default(autoincrement())
  orderId         Int
  method          PaymentMethod
  amount          Decimal   @db.Decimal(10, 2) // Converti de FLOAT pour plus de précision
  status          String
  reference       String?
  paymentDetails  String?   // À considérer pour chiffrement
  createdAt       DateTime  @default(now()) @db.Timestamptz(6)
  
  // Relations
  order           Order     @relation(fields: [orderId], references: [id], onDelete: Cascade)
  
  // Indices recommandés
  @@index([orderId], name: "idx_payment_transactions_order_id")
  @@index([status], name: "idx_payment_transactions_status")
  
  // Contraintes personnalisées
  // CHECK (amount > 0)
}

model Address {
  id              Int       @id @default(autoincrement())
  userId          Int
  type            String    // "SHIPPING" ou "BILLING"
  streetAddress   String
  city            String
  state           String?
  postalCode      String
  country         String
  isDefault       Boolean   @default(false)
  
  // Relations
  user            User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // Indices recommandés
  @@index([userId], name: "idx_addresses_user_id")
}

model Review {
  id              Int       @id @default(autoincrement())
  userId          Int
  productId       Int
  rating          Int
  comment         String?   @db.Text
  createdAt       DateTime  @default(now()) @db.Timestamptz(6)
  
  // Relations
  user            User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  product         Product   @relation(fields: [productId], references: [id], onDelete: Cascade)
  
  // Indices recommandés
  @@index([productId], name: "idx_reviews_product_id")
  @@index([userId], name: "idx_reviews_user_id")
  
  // Contraintes personnalisées
  // CHECK (rating BETWEEN 1 AND 5)
  
  // Contrainte d'unicité pour empêcher les avis multiples
  @@unique([userId, productId], name: "user_product_unique")
}

model WishlistItem {
  id              Int       @id @default(autoincrement())
  userId          Int
  productId       Int
  addedAt         DateTime  @default(now()) @db.Timestamptz(6)
  
  // Relations
  user            User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  product         Product   @relation(fields: [productId], references: [id], onDelete: Cascade)
  
  // Indices recommandés
  @@index([userId], name: "idx_wishlist_items_user_id")
  
  // Contrainte d'unicité
  @@unique([userId, productId], name: "user_product_wishlist_unique")
}

// Table de logs avec ajout d'une clé primaire (manquante dans MySQL)
model LogEntry {
  id              Int       @id @default(autoincrement()) // Ajouté pour Prisma
  level           String
  message         String    @db.Text
  context         Json?     // Converti de TEXT à JSONB
  createdAt       DateTime  @default(now()) @db.Timestamptz(6)
  
  // Indices recommandés
  @@index([level], name: "idx_log_entries_level")
  @@index([createdAt], name: "idx_log_entries_created_at")
  
  // Pour PostgreSQL : partitionnement par date recommandé
  // Cette table sera partitionnée via des migrations SQL personnalisées
}

model Profile {
  id        BigInt    @id @default(autoincrement())
  userId    BigInt    @unique @map("user_id")
  fullName  String?   @map("full_name")
  address   String?
  phone     String?
  avatarUrl String?   @map("avatar_url")
  createdAt DateTime  @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt DateTime? @updatedAt @map("updated_at") @db.Timestamptz(6)

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("profiles")
}

model Session {
  id           String    @id
  userId       BigInt?   @map("user_id")
  token        String    @unique
  ipAddress    String?   @map("ip_address") @db.VarChar(45)
  userAgent    String?   @map("user_agent")
  payload      Json      @db.JsonB
  lastActivity DateTime  @map("last_activity") @db.Timestamptz(6)
  createdAt    DateTime  @default(now()) @map("created_at") @db.Timestamptz(6)
  expiresAt    DateTime  @map("expires_at") @db.Timestamptz(6)

  // Relations
  user User? @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([expiresAt])
  @@map("sessions")
}