#!/usr/bin/env node

/**
 * Script qui configure la surveillance post-d√©ploiement pour s'assurer que l'application
 * fonctionne correctement apr√®s le d√©ploiement.
 */

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');
const yargs = require('yargs/yargs');
const { hideBin } = require('yargs/helpers');

// Analyse des arguments de ligne de commande
const argv = yargs(hideBin(process.argv))
    .option('env', {
        alias: 'e',
        description: 'Environnement surveill√©',
        type: 'string',
        default: 'dev'
    })
    .option('duration', {
        alias: 'd',
        description: 'Dur√©e de surveillance en minutes',
        type: 'number',
        default: 60
    })
    .option('interval', {
        alias: 'i',
        description: 'Intervalle entre les v√©rifications en secondes',
        type: 'number',
        default: 30
    })
    .help()
    .alias('help', '?')
    .argv;

/**
 * Fonction principale
 */
async function main() {
    try {
        console.log(`üîç Configuration de la surveillance post-d√©ploiement pour l'environnement: ${argv.env}`);

        // Identifier les derniers d√©ploiements
        const deployments = findRecentDeployments(argv.env);
        if (deployments.length === 0) {
            console.warn('‚ö†Ô∏è Aucun d√©ploiement r√©cent trouv√© pour la surveillance.');
            return;
        }

        const latestDeployment = deployments[0];
        console.log(`üìä D√©ploiement surveill√©: ${latestDeployment.version} (${latestDeployment.timestamp})`);

        // Cr√©er une configuration de surveillance
        const monitoringConfig = {
            deploymentId: latestDeployment.version,
            environment: argv.env,
            startTime: new Date().toISOString(),
            duration: argv.duration * 60, // en secondes
            interval: argv.interval,
            endpoints: [
                {
                    url: `https://app-${argv.env}.exemple.com/health`,
                    responseTimeThreshold: 500,
                    successStatusCodes: [200]
                },
                {
                    url: `https://app-${argv.env}.exemple.com/api/status`,
                    responseTimeThreshold: 800,
                    successStatusCodes: [200]
                },
                {
                    url: `https://app-${argv.env}.exemple.com/`,
                    responseTimeThreshold: 1200,
                    successStatusCodes: [200]
                }
            ],
            metricsToMonitor: [
                {
                    name: "cpu_usage",
                    query: "process_cpu_usage{service='app-" + argv.env + "'}",
                    thresholdValue: 80,
                    thresholdType: "max"
                },
                {
                    name: "memory_usage",
                    query: "process_resident_memory_bytes{service='app-" + argv.env + "'} / 1024 / 1024",
                    thresholdValue: 512,
                    thresholdType: "max"
                },
                {
                    name: "http_error_rate",
                    query: "sum(rate(http_requests_total{status=~'5..', service='app-" + argv.env + "'}[5m])) / sum(rate(http_requests_total{service='app-" + argv.env + "'}[5m])) * 100",
                    thresholdValue: 1,
                    thresholdType: "max"
                },
                {
                    name: "response_time_p95",
                    query: "histogram_quantile(0.95, sum(rate(http_request_duration_seconds_bucket{service='app-" + argv.env + "'}[5m])) by (le))",
                    thresholdValue: 2,
                    thresholdType: "max"
                }
            ],
            notificationChannels: [
                {
                    type: "slack",
                    channel: "#deployments-" + argv.env
                },
                {
                    type: "email",
                    recipients: ["ops@exemple.com", "dev-lead@exemple.com"]
                }
            ],
            alertRules: [
                {
                    name: "HighErrorRate",
                    query: "sum(rate(http_requests_total{status=~'5..', service='app-" + argv.env + "'}[5m])) / sum(rate(http_requests_total{service='app-" + argv.env + "'}[5m])) * 100 > 5",
                    for: "2m",
                    severity: "critical",
                    description: "Taux d'erreur HTTP √©lev√© d√©tect√©"
                },
                {
                    name: "SlowResponses",
                    query: "histogram_quantile(0.95, sum(rate(http_request_duration_seconds_bucket{service='app-" + argv.env + "'}[5m])) by (le)) > 3",
                    for: "3m",
                    severity: "warning",
                    description: "Temps de r√©ponse anormalement lents d√©tect√©s"
                }
            ],
            autoRollbackThresholds: {
                errorRate: 10, // Pourcentage
                responseTime: 5000, // Millisecondes
                availabilityLoss: 95 // Pourcentage minimum requis
            }
        };

        // Cr√©er le r√©pertoire de configuration si n√©cessaire
        const monitoringDir = path.join(process.cwd(), 'monitoring', 'post-deploy');
        if (!fs.existsSync(monitoringDir)) {
            fs.mkdirSync(monitoringDir, { recursive: true });
        }

        // √âcrire la configuration
        const configPath = path.join(monitoringDir, `post-deploy-${argv.env}-${latestDeployment.version}.json`);
        fs.writeFileSync(configPath, JSON.stringify(monitoringConfig, null, 2));

        console.log(`üìù Configuration de surveillance √©crite dans: ${configPath}`);

        // Configurer les alertes dans Prometheus/AlertManager
        console.log('‚öôÔ∏è Configuration des alertes dans le syst√®me de monitoring...');
        setupAlertRules(argv.env, monitoringConfig);

        // Cr√©er une t√¢che cron pour la v√©rification continue
        console.log('üïí Configuration de la t√¢che de surveillance continue...');
        setupMonitoringTask(argv.env, configPath, argv.duration, argv.interval);

        console.log(`‚úÖ Surveillance post-d√©ploiement configur√©e pour ${argv.duration} minutes avec v√©rification toutes les ${argv.interval} secondes.`);

    } catch (error) {
        console.error('‚ùå Erreur lors de la configuration de la surveillance post-d√©ploiement:', error);
        process.exit(1);
    }
}

/**
 * Trouve les d√©ploiements r√©cents pour un environnement donn√©
 */
function findRecentDeployments(env) {
    try {
        // Dans un environnement r√©el, cette fonction interrogerait votre syst√®me de d√©ploiement
        // Pour cet exemple, nous simulons une liste de d√©ploiements

        const configDir = path.join(process.cwd(), 'config', 'deployments');
        if (!fs.existsSync(configDir)) {
            return [];
        }

        // Chercher les fichiers de configuration de d√©ploiement pour cet environnement
        const deploymentFiles = fs.readdirSync(configDir)
            .filter(file => file.startsWith(`canary-${env}`) || file.startsWith(`deploy-${env}`))
            .filter(file => file.endsWith('.json'));

        if (deploymentFiles.length === 0) {
            return [];
        }

        // Transformer les fichiers en objets de d√©ploiement
        return deploymentFiles.map(file => {
            try {
                const filePath = path.join(configDir, file);
                const content = JSON.parse(fs.readFileSync(filePath, 'utf8'));
                return {
                    file,
                    version: content.version,
                    timestamp: content.timestamp,
                    commitSha: content.commitSha
                };
            } catch (e) {
                console.warn(`Impossible de lire le fichier de d√©ploiement ${file}:`, e.message);
                return null;
            }
        })
            .filter(Boolean)
            .sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));

    } catch (error) {
        console.error('Erreur lors de la recherche des d√©ploiements:', error);
        return [];
    }
}

/**
 * Configure les r√®gles d'alerte dans le syst√®me de monitoring
 */
function setupAlertRules(env, config) {
    // Cette fonction simule la configuration des alertes dans Prometheus/AlertManager
    // Dans un environnement r√©el, vous utiliseriez l'API ou des fichiers de configuration

    const alertRulesDir = path.join(process.cwd(), 'monitoring', 'prometheus', 'rules');
    if (!fs.existsSync(alertRulesDir)) {
        fs.mkdirSync(alertRulesDir, { recursive: true });
    }

    // G√©n√©rer le fichier de r√®gles pour ce d√©ploiement
    const alertRules = {
        groups: [
            {
                name: `post-deploy-alerts-${env}-${config.deploymentId}`,
                rules: config.alertRules.map(rule => ({
                    alert: rule.name,
                    expr: rule.query,
                    for: rule.for,
                    labels: {
                        severity: rule.severity,
                        environment: env,
                        deployment: config.deploymentId
                    },
                    annotations: {
                        description: rule.description,
                        summary: `[${env.toUpperCase()}] ${rule.name} - ${rule.description}`
                    }
                }))
            }
        ]
    };

    const alertRulesPath = path.join(alertRulesDir, `post-deploy-${env}-${config.deploymentId}.yml`);

    // Dans un environnement r√©el, vous utiliseriez une biblioth√®que pour g√©n√©rer du YAML
    fs.writeFileSync(alertRulesPath, JSON.stringify(alertRules, null, 2));

    console.log(`üìã R√®gles d'alerte g√©n√©r√©es: ${alertRulesPath}`);
}

/**
 * Configure une t√¢che de surveillance continue
 */
function setupMonitoringTask(env, configPath, duration, interval) {
    // Cette fonction simule la cr√©ation d'une t√¢che de surveillance continue
    // Dans un environnement r√©el, vous utiliseriez un syst√®me de t√¢ches comme cron, Kubernetes Jobs, etc.

    const monitoringScriptDir = path.join(process.cwd(), 'scripts', 'monitoring');
    if (!fs.existsSync(monitoringScriptDir)) {
        fs.mkdirSync(monitoringScriptDir, { recursive: true });
    }

    // Cr√©er un script d'ex√©cution pour la t√¢che de surveillance
    const scriptContent = `#!/bin/bash
# Script de surveillance post-d√©ploiement g√©n√©r√© automatiquement
# Environnement: ${env}
# Dur√©e: ${duration} minutes
# Intervalle: ${interval} secondes

CONFIG_PATH="${configPath}"
DURATION_SECONDS=$((${duration} * 60))
INTERVAL_SECONDS=${interval}
START_TIME=$(date +%s)
END_TIME=$((START_TIME + DURATION_SECONDS))

echo "[$(date)] D√©marrage de la surveillance post-d√©ploiement pour l'environnement ${env}"
echo "[$(date)] Configuration: $CONFIG_PATH"
echo "[$(date)] Dur√©e: ${duration} minutes (jusqu'√† $(date -d @$END_TIME))"

while [ $(date +%s) -lt $END_TIME ]; do
  echo "[$(date)] Ex√©cution de la v√©rification de sant√©..."
  
  # Ex√©cuter la v√©rification
  pnpm tsx agents/monitoring/monitoring-check.ts --config=$CONFIG_PATH --check
  
  # Enregistrer le r√©sultat
  RESULT=$?
  if [ $RESULT -ne 0 ]; then
    echo "[$(date)] ‚ö†Ô∏è V√©rification √©chou√©e avec le code de sortie: $RESULT"
    
    # Incr√©menter le compteur d'√©checs
    FAILURE_COUNT=$((FAILURE_COUNT + 1))
    
    # Si trop d'√©checs cons√©cutifs, d√©clencher une alerte
    if [ $FAILURE_COUNT -ge 3 ]; then
      echo "[$(date)] üö® Trop d'√©checs cons√©cutifs, d√©clenchement d'une alerte!"
      pnpm tsx agents/notifier.ts --event=deploy-health-check-failed --env=${env} --config=$CONFIG_PATH
    fi
  else
    echo "[$(date)] ‚úÖ V√©rification r√©ussie"
    FAILURE_COUNT=0
  fi
  
  # Attendre l'intervalle avant la prochaine v√©rification
  echo "[$(date)] Attente de $INTERVAL_SECONDS secondes avant la prochaine v√©rification..."
  sleep $INTERVAL_SECONDS
done

echo "[$(date)] ‚úÖ Surveillance post-d√©ploiement termin√©e pour l'environnement ${env}"

# G√©n√©rer un rapport final
echo "[$(date)] G√©n√©ration du rapport final..."
pnpm tsx agents/monitoring/generate-monitoring-report.ts --config=$CONFIG_PATH --output=reports/post-deploy-${env}-$(date +%Y%m%d-%H%M%S).json

echo "[$(date)] üìä Surveillance termin√©e. Consultez le rapport pour plus de d√©tails."
`;

    const scriptPath = path.join(monitoringScriptDir, `monitor-post-deploy-${env}.sh`);
    fs.writeFileSync(scriptPath, scriptContent);
    fs.chmodSync(scriptPath, '755'); // Rendre le script ex√©cutable

    console.log(`üìú Script de surveillance cr√©√©: ${scriptPath}`);

    // Dans un environnement r√©el, vous configureriez cette t√¢che √† ex√©cuter dans votre syst√®me
    console.log(`‚ÑπÔ∏è Pour d√©marrer manuellement la surveillance: ${scriptPath}`);
}

// Ex√©cution du script
main().catch(error => {
    console.error(error);
    process.exit(1);
});