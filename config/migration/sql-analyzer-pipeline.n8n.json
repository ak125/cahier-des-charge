{
  "name": "SQL Analyzer IA Pipeline",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "sql-analyzer",
        "options": {
          "responseMode": "responseNode"
        },
        "authentication": "basicAuth"
      },
      "name": "Webhook D√©clencheur",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [250, 300]
    },
    {
      "parameters": {
        "filePath": "={{ $json.auditIndexPath || './reports/sql_analyzer/audit_index.json' }}"
      },
      "name": "Charger Index d'Audit",
      "type": "n8n-nodes-base.readBinaryFile",
      "typeVersion": 1,
      "position": [450, 300]
    },
    {
      "parameters": {
        "dataType": "string",
        "value": "={{ $binary.data.toString('utf8') }}"
      },
      "name": "Parser JSON Audit",
      "type": "n8n-nodes-base.set",
      "typeVersion": 1,
      "position": [650, 300]
    },
    {
      "parameters": {
        "mode": "jsonToBinary",
        "sourceKey": "",
        "options": {
          "keepSource": true
        }
      },
      "name": "Convertir en JSON",
      "type": "n8n-nodes-base.moveData",
      "typeVersion": 1,
      "position": [850, 300]
    },
    {
      "parameters": {
        "functionCode": "// R√©cup√©rer le r√©pertoire de base\nconst outputDir = $input.item.json.outputDir || './reports/sql_analyzer';\n\n// Charger les fichiers r√©f√©renc√©s dans l'index d'audit\nconst auditIndex = $input.item.json;\nconst results = {\n  timestamp: auditIndex.timestamp,\n  database: auditIndex.database,\n  schemas: {},\n  reports: {},\n  prisma: {},\n  migrations: {}\n};\n\n// Fonction pour charger un fichier\nasync function loadFile(path) {\n  try {\n    const fullPath = `${outputDir}/${path}`;\n    const fs = require('fs');\n    if (!fs.existsSync(fullPath)) {\n      return null;\n    }\n    const content = fs.readFileSync(fullPath, 'utf8');\n    return path.endsWith('.json') ? JSON.parse(content) : content;\n  } catch (error) {\n    console.error(`Erreur lors du chargement du fichier ${path}:`, error);\n    return null;\n  }\n}\n\n// Charger les sch√©mas\nif (auditIndex.schema_file) {\n  results.schemas.raw = await loadFile(auditIndex.schema_file);\n}\nif (auditIndex.normalized_schema) {\n  results.schemas.normalized = await loadFile(auditIndex.normalized_schema);\n}\nif (auditIndex.type_map) {\n  results.schemas.typeMap = await loadFile(auditIndex.type_map);\n}\n\n// Charger les rapports\nif (auditIndex.reports && Array.isArray(auditIndex.reports)) {\n  for (const reportPath of auditIndex.reports) {\n    const reportName = reportPath.split('/').pop().replace('.md', '').replace('.json', '');\n    results.reports[reportName] = await loadFile(reportPath);\n  }\n}\n\n// Charger le mod√®le Prisma\nif (auditIndex.prisma_model) {\n  results.prisma.model = await loadFile(auditIndex.prisma_model);\n}\n\n// Charger le plan de migration\nif (auditIndex.migration_plan) {\n  results.migrations.plan = await loadFile(auditIndex.migration_plan);\n}\n\n// Extraire des m√©triques\nresults.metrics = {\n  tables: 0,\n  columns: 0,\n  relations: 0,\n  risks: { high: 0, medium: 0, low: 0 }\n};\n\n// Compter les tables et colonnes\nif (results.schemas.normalized) {\n  const tables = results.schemas.normalized.tables || [];\n  results.metrics.tables = tables.length;\n  \n  // Compter les colonnes et relations\n  let columnCount = 0;\n  let relationCount = 0;\n  \n  for (const table of tables) {\n    columnCount += (table.columns || []).length;\n    relationCount += (table.foreignKeys || []).length;\n  }\n  \n  results.metrics.columns = columnCount;\n  results.metrics.relations = relationCount;\n}\n\n// Calculer les risques\nif (results.reports.table_risks) {\n  const risks = results.reports.table_risks;\n  for (const table in risks) {\n    const risk = risks[table].risk || 'low';\n    results.metrics.risks[risk]++;\n  }\n}\n\nreturn {json: results};"
      },
      "name": "Collecter R√©sultats Audit",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [1050, 300]
    },
    {
      "parameters": {
        "content": "=## Rapport d'Analyse SQL IA pour `{{ $json.database }}`\n\n**Date d'analyse:** {{ $json.timestamp }}\n\n### üìä M√©triques\n- Tables: {{ $json.metrics.tables }}\n- Colonnes: {{ $json.metrics.columns }}\n- Relations: {{ $json.metrics.relations }}\n\n### ‚ö†Ô∏è Risques identifi√©s\n- Risques √©lev√©s: {{ $json.metrics.risks.high }}\n- Risques moyens: {{ $json.metrics.risks.medium }}\n- Risques faibles: {{ $json.metrics.risks.low }}\n\n### Prochaines √©tapes\n1. Examiner le rapport de dette technique complet\n2. Valider le mod√®le Prisma g√©n√©r√©\n3. Revoir le plan de migration\n",
        "options": {}
      },
      "name": "Cr√©er R√©sum√© Markdown",
      "type": "n8n-nodes-base.markdown",
      "typeVersion": 1,
      "position": [1250, 300]
    },
    {
      "parameters": {
        "chatId": "={{ $env.CHAT_ID }}",
        "text": "=üß† **Analyse SQL compl√©t√©e!**\n\n{{ $node[\"Cr√©er R√©sum√© Markdown\"].data[\"output\"] }}\n\nVous pouvez consulter les rapports complets dans:\n{{ $json.outputDir || './reports/sql_analyzer' }}",
        "options": {
          "parseMode": "Markdown"
        }
      },
      "name": "Notification Telegram",
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1,
      "position": [1450, 300],
      "credentials": {
        "telegramApi": {
          "id": "1",
          "name": "Telegram Account"
        }
      }
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}",
        "options": {}
      },
      "name": "R√©ponse HTTP",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [1450, 500]
    },
    {
      "parameters": {
        "conditions": {
          "string": [
            {
              "value1": "={{ Object.keys($json.reports).includes('sql_dette_technique') }}",
              "operation": "equal",
              "value2": "true"
            }
          ]
        }
      },
      "name": "V√©rifier Dette Technique",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [1250, 500]
    },
    {
      "parameters": {
        "functionCode": "// Analyser la dette technique\nconst rapport = $input.item.json.reports.sql_dette_technique || '';\nconst risques = $input.item.json.reports.table_risks || {};\n\n// Extraire les risques √©lev√©s\nconst risquesEleves = Object.entries(risques)\n  .filter(([_, data]) => data.risk === 'high')\n  .map(([table, data]) => ({\n    table,\n    score: data.score,\n    raisons: data.reasons\n  }));\n\n// Cr√©er les suggestions\nconst suggestions = [];\n\n// Suggestions pour les risques √©lev√©s\nif (risquesEleves.length > 0) {\n  suggestions.push({\n    titre: \"Tables √† risque √©lev√©\",\n    description: `${risquesEleves.length} tables ont un risque √©lev√© de probl√®mes lors de la migration`,\n    actions: risquesEleves.map(r => `Revoir la table ${r.table}: ${r.raisons.join(', ')}`)\n  });\n}\n\n// Suggestions pour les types\nif ($input.item.json.schemas.typeMap) {\n  const typesMap = $input.item.json.schemas.typeMap;\n  const typesSuggestions = [];\n  \n  // D√©tecter les types probl√©matiques\n  for (const [mysqlType, pgType] of Object.entries(typesMap)) {\n    if (pgType === '?') {\n      typesSuggestions.push(`D√©finir un type PostgreSQL pour le type MySQL ${mysqlType}`);\n    }\n  }\n  \n  if (typesSuggestions.length > 0) {\n    suggestions.push({\n      titre: \"Conversion de types\",\n      description: \"Certains types MySQL n'ont pas d'√©quivalent direct en PostgreSQL\",\n      actions: typesSuggestions\n    });\n  }\n}\n\n// Sugg√©rer les √©tapes de migration\nsuggestions.push({\n  titre: \"Plan de migration\",\n  description: \"√âtapes recommand√©es pour migrer vers PostgreSQL + Prisma\",\n  actions: [\n    \"1. Valider et ajuster le mod√®le Prisma g√©n√©r√©\",\n    \"2. Cr√©er un backup complet des donn√©es\",\n    \"3. Ex√©cuter le plan de migration par √©tapes\",\n    \"4. V√©rifier l'int√©grit√© des donn√©es migr√©es\",\n    \"5. Mettre √† jour les clients d'application\"\n  ]\n});\n\nreturn {\n  json: {\n    ...$input.item.json,\n    suggestions\n  }\n};"
      },
      "name": "G√©n√©rer Suggestions",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [1050, 500]
    },
    {
      "parameters": {
        "filePath": "={{ $json.outputDir + '/prisma_migration_suggestions.md' || './reports/sql_analyzer/prisma_migration_suggestions.md' }}",
        "options": {}
      },
      "name": "Sauvegarder Suggestions",
      "type": "n8n-nodes-base.writeBinaryFile",
      "typeVersion": 1,
      "position": [1250, 700]
    },
    {
      "parameters": {
        "dataType": "string",
        "value": "=# Suggestions de Migration vers Prisma + PostgreSQL\n\n## Points d'attention pour la migration\n\n{{#each suggestions}}\n### {{titre}}\n\n{{description}}\n\n{{#each actions}}\n- {{this}}\n{{/each}}\n\n{{/each}}\n\n## Impact sur l'application\n\nCette migration peut affecter les composants suivants de votre application:\n\n- API REST utilisant les mod√®les actuels\n- Requ√™tes SQL brutes dans le code PHP\n- ORM existant\n- Validation de formulaires li√©e au sch√©ma\n\n## Prochaines √©tapes recommand√©es\n\n1. **R√©viser le mod√®le Prisma**: V√©rifiez que le mod√®le Prisma g√©n√©r√© correspond √† vos besoins.\n2. **Tests de validation**: Cr√©ez des tests pour valider que la nouvelle structure fonctionne correctement.\n3. **Migration par phases**: Migrez progressivement par groupes de tables li√©es.\n4. **Adaptation du code**: Mettez √† jour le code de l'application pour utiliser le nouveau mod√®le de donn√©es.\n\n## Timeline sugg√©r√©e\n\n1. **Phase d'analyse** (termin√©e) - Comprendre le sch√©ma et g√©n√©rer le mod√®le Prisma\n2. **Phase de pr√©paration** (1-2 semaines) - R√©viser et ajuster le mod√®le, pr√©parer les tests\n3. **Phase de migration** (1-3 jours) - Ex√©cuter la migration de la base de donn√©es\n4. **Phase d'adaptation** (1-4 semaines) - Adapter le code de l'application aux nouveaux mod√®les\n5. **Phase de validation** (1 semaine) - Tests finaux et surveillance"
      },
      "name": "Pr√©parer Suggestions Markdown",
      "type": "n8n-nodes-base.set",
      "typeVersion": 1,
      "position": [1050, 700]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Cr√©er un rapport n8n int√©gr√©\nconst fs = require('fs');\nconst path = require('path');\n\n// R√©cup√©rer les donn√©es d'entr√©e\nconst item = $input.item.json;\nconst outputDir = item.outputDir || './reports/sql_analyzer';\n\n// Cr√©er un rapport HTML pour le tableau de bord\nconst reportPath = path.join(outputDir, 'dashboard_report.html');\n\n// G√©n√©rer le contenu HTML avec les statistiques et graphiques\nconst htmlContent = `<!DOCTYPE html>\n<html lang=\"fr\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Rapport d'analyse SQL - ${item.database}</title>\n    <style>\n        body { font-family: Arial, sans-serif; max-width: 1200px; margin: 0 auto; padding: 20px; }\n        h1, h2, h3 { color: #2c3e50; }\n        .card { background: #f8f9fa; border-radius: 5px; padding: 15px; margin-bottom: 20px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }\n        .metrics { display: flex; flex-wrap: wrap; gap: 15px; }\n        .metric-card { background: #fff; border-radius: 5px; padding: 15px; flex: 1; min-width: 200px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }\n        .metric-title { font-size: 0.9em; color: #7f8c8d; margin-bottom: 5px; }\n        .metric-value { font-size: 2em; font-weight: bold; color: #2980b9; }\n        .risks { display: flex; gap: 10px; }\n        .risk { padding: 10px; border-radius: 5px; flex: 1; text-align: center; color: white; }\n        .risk.high { background-color: #e74c3c; }\n        .risk.medium { background-color: #f39c12; }\n        .risk.low { background-color: #27ae60; }\n        .suggestion { margin-bottom: 15px; }\n        .code-block { background: #f1f1f1; padding: 10px; border-radius: 5px; font-family: monospace; white-space: pre-wrap; }\n    </style>\n</head>\n<body>\n    <h1>Rapport d'analyse SQL - Migration vers PostgreSQL/Prisma</h1>\n    \n    <div class=\"card\">\n        <h2>Informations g√©n√©rales</h2>\n        <p><strong>Base de donn√©es analys√©e:</strong> ${item.database}</p>\n        <p><strong>Date d'analyse:</strong> ${item.timestamp}</p>\n    </div>\n    \n    <div class=\"card\">\n        <h2>M√©triques</h2>\n        <div class=\"metrics\">\n            <div class=\"metric-card\">\n                <div class=\"metric-title\">Tables</div>\n                <div class=\"metric-value\">${item.metrics.tables}</div>\n            </div>\n            <div class=\"metric-card\">\n                <div class=\"metric-title\">Colonnes</div>\n                <div class=\"metric-value\">${item.metrics.columns}</div>\n            </div>\n            <div class=\"metric-card\">\n                <div class=\"metric-title\">Relations</div>\n                <div class=\"metric-value\">${item.metrics.relations}</div>\n            </div>\n        </div>\n    </div>\n    \n    <div class=\"card\">\n        <h2>Analyse de risques</h2>\n        <div class=\"risks\">\n            <div class=\"risk high\">\n                <h3>√âlev√©</h3>\n                <p>${item.metrics.risks.high}</p>\n            </div>\n            <div class=\"risk medium\">\n                <h3>Moyen</h3>\n                <p>${item.metrics.risks.medium}</p>\n            </div>\n            <div class=\"risk low\">\n                <h3>Faible</h3>\n                <p>${item.metrics.risks.low}</p>\n            </div>\n        </div>\n    </div>\n    \n    <div class=\"card\">\n        <h2>Suggestions</h2>\n        ${(item.suggestions || []).map(s => `\n            <div class=\"suggestion\">\n                <h3>${s.titre}</h3>\n                <p>${s.description}</p>\n                <ul>\n                    ${s.actions.map(a => `<li>${a}</li>`).join('')}\n                </ul>\n            </div>\n        `).join('')}\n    </div>\n    \n    <div class=\"card\">\n        <h2>Extrait du mod√®le Prisma</h2>\n        <div class=\"code-block\">${item.prisma?.model ? item.prisma.model.substring(0, 1000) + (item.prisma.model.length > 1000 ? '...' : '') : 'Mod√®le non disponible'}</div>\n    </div>\n    \n    <div class=\"card\">\n        <h2>Prochaines √©tapes</h2>\n        <ol>\n            <li>Examiner le rapport de dette technique complet: <code>${outputDir}/reports/sql_dette_technique.md</code></li>\n            <li>Valider le mod√®le Prisma g√©n√©r√©: <code>${outputDir}/prisma/prisma_models.suggestion.prisma</code></li>\n            <li>Revoir le plan de migration: <code>${outputDir}/migrations/migration_plan.sql</code></li>\n            <li>Ex√©cuter la migration lorsque tout est valid√©</li>\n        </ol>\n    </div>\n</body>\n</html>`;\n\n// √âcrire le fichier\ntry {\n  fs.writeFileSync(reportPath, htmlContent);\n  console.log(`Rapport HTML g√©n√©r√© avec succ√®s: ${reportPath}`);\n} catch (error) {\n  console.error(`Erreur lors de la g√©n√©ration du rapport HTML: ${error.message}`);\n}\n\n// Mettre √† jour les m√©triques pour le dashboard\nconst metricsPath = path.join('./dashboard/data', 'sql_analysis_metrics.json');\nlet metrics = [];\n\n// Charger les m√©triques existantes si elles existent\ntry {\n  if (fs.existsSync(metricsPath)) {\n    const metricsData = fs.readFileSync(metricsPath, 'utf8');\n    metrics = JSON.parse(metricsData);\n  }\n} catch (error) {\n  console.error(`Erreur lors du chargement des m√©triques: ${error.message}`);\n}\n\n// Ajouter les nouvelles m√©triques\nmetrics.push({\n  timestamp: item.timestamp,\n  database: item.database,\n  tables: item.metrics.tables,\n  columns: item.metrics.columns,\n  relations: item.metrics.relations,\n  risks: item.metrics.risks\n});\n\n// Limiter √† 10 entr√©es\nif (metrics.length > 10) {\n  metrics = metrics.slice(-10);\n}\n\n// Sauvegarder les m√©triques\ntry {\n  // Cr√©er le r√©pertoire si n√©cessaire\n  const dir = path.dirname(metricsPath);\n  if (!fs.existsSync(dir)) {\n    fs.mkdirSync(dir, { recursive: true });\n  }\n  \n  fs.writeFileSync(metricsPath, JSON.stringify(metrics, null, 2));\n  console.log(`M√©triques mises √† jour avec succ√®s: ${metricsPath}`);\n} catch (error) {\n  console.error(`Erreur lors de la sauvegarde des m√©triques: ${error.message}`);\n}\n\n// Retourner les donn√©es\nreturn {\n  ...item,\n  reportPath,\n  metricsPath\n};"
      },
      "name": "G√©n√©rer Dashboard HTML",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [650, 500]
    }
  ],
  "connections": {
    "Webhook D√©clencheur": {
      "main": [
        [
          {
            "node": "Charger Index d'Audit",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Charger Index d'Audit": {
      "main": [
        [
          {
            "node": "Parser JSON Audit",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parser JSON Audit": {
      "main": [
        [
          {
            "node": "Convertir en JSON",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Convertir en JSON": {
      "main": [
        [
          {
            "node": "Collecter R√©sultats Audit",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Collecter R√©sultats Audit": {
      "main": [
        [
          {
            "node": "Cr√©er R√©sum√© Markdown",
            "type": "main",
            "index": 0
          },
          {
            "node": "G√©n√©rer Dashboard HTML",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Cr√©er R√©sum√© Markdown": {
      "main": [
        [
          {
            "node": "Notification Telegram",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "G√©n√©rer Dashboard HTML": {
      "main": [
        [
          {
            "node": "G√©n√©rer Suggestions",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "G√©n√©rer Suggestions": {
      "main": [
        [
          {
            "node": "Pr√©parer Suggestions Markdown",
            "type": "main",
            "index": 0
          },
          {
            "node": "V√©rifier Dette Technique",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "V√©rifier Dette Technique": {
      "main": [
        [
          {
            "node": "R√©ponse HTTP",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Pr√©parer Suggestions Markdown": {
      "main": [
        [
          {
            "node": "Sauvegarder Suggestions",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1",
    "saveExecutionProgress": true,
    "saveManualExecutions": true,
    "callerPolicy": "workflowsFromSameOwner",
    "timezone": "Europe/Paris"
  },
  "id": "sql-analyzer-pipeline"
}
