{
  "name": "PHP Routes Migration Manager",
  "nodes": [
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "days",
              "minutesInterval": 1,
              "triggerAtTime": "09:00"
            }
          ]
        }
      },
      "id": "1b8710ae-c7e2-4eb4-a8e7-16efa7f9e5e0",
      "name": "Schedule",
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1,
      "position": [
        240,
        300
      ]
    },
    {
      "parameters": {
        "command": "cd /workspaces/cahier-des-charge && npx ts-node -r tsconfig-paths/register agents/migration/php-to-remix/php-router-audit.ts --htaccessPath=examples/.htaccess --outputPath=routing_patch.json --baseUrl=http://localhost:3001 --checkActive=true",
        "executeTimeout": 120
      },
      "id": "3a79cc2a-2a9b-4abf-9f37-e60e5fcd4b8d",
      "name": "Audit des routes PHP",
      "type": "n8n-nodes-base.executeCommand",
      "typeVersion": 1,
      "position": [
        460,
        300
      ]
    },
    {
      "parameters": {
        "filePath": "/workspaces/cahier-des-charge/routing_patch.json"
      },
      "id": "7c19c24d-94fd-4a9b-b58d-5c80a4ed1baa",
      "name": "Lire routing_patch.json",
      "type": "n8n-nodes-base.readBinaryFile",
      "typeVersion": 1,
      "position": [
        700,
        300
      ]
    },
    {
      "parameters": {
        "jsCode": "// Convertir le contenu binaire en JSON\nconst fileContent = Buffer.from(items[0].binary.data, 'base64').toString('utf-8');\nconst routingPatch = JSON.parse(fileContent);\n\n// Personnaliser les règles spécifiques\nconst customizedRules = routingPatch.map(rule => {\n  // Personnalisation selon des critères spécifiques\n  \n  // Pour les pages de fiches produit, ajouter des paramètres de requête spécifiques\n  if (rule.from.includes('fiche.php') || rule.from.includes('product.php')) {\n    rule.queryParams = rule.queryParams || [];\n    if (!rule.queryParams.includes('id')) rule.queryParams.push('id');\n    if (!rule.queryParams.includes('ref')) rule.queryParams.push('ref');\n    if (!rule.queryParams.includes('cat')) rule.queryParams.push('cat');\n  }\n  \n  // Pour les pages de catégories\n  if (rule.from.includes('categorie.php') || rule.from.includes('category.php')) {\n    rule.queryParams = rule.queryParams || [];\n    if (!rule.queryParams.includes('id')) rule.queryParams.push('id');\n    if (!rule.queryParams.includes('slug')) rule.queryParams.push('slug');\n  }\n  \n  // Pour les anciennes pages de recherche\n  if (rule.from.includes('search.php') || rule.from.includes('recherche.php')) {\n    rule.queryParams = rule.queryParams || [];\n    if (!rule.queryParams.includes('q')) rule.queryParams.push('q');\n    if (!rule.queryParams.includes('page')) rule.queryParams.push('page');\n  }\n  \n  // Mettre à jour les statuts de redirections pour les pages obsolètes\n  if (rule.from.includes('old-') || rule.from.includes('v1-') || \n      rule.from.includes('ancienne-') || rule.from.includes('promo')) {\n    rule.type = 'redirect';\n    rule.status = 301;\n  }\n  \n  // S'assurer que toutes les routes de type removed ont un statut 410\n  if (rule.type === 'removed' && rule.status !== 410) {\n    rule.status = 410;\n  }\n  \n  return rule;\n});\n\n// Ajouter des règles personnalisées qui n'existaient pas avant\nconst customRules = [\n  {\n    \"from\": \"/ancien-panier.php\",\n    \"to\": \"/cart\",\n    \"type\": \"redirect\",\n    \"status\": 301,\n    \"description\": \"Redirection de l'ancien panier vers la nouvelle page\"\n  },\n  {\n    \"from\": \"/mon-compte.php\",\n    \"to\": \"/account\",\n    \"type\": \"redirect\",\n    \"status\": 301,\n    \"description\": \"Redirection de l'ancienne page de compte\"\n  },\n  {\n    \"from\": \"/api.php\",\n    \"to\": \"/api\",\n    \"type\": \"rewrite\",\n    \"queryParams\": [\"*\"],\n    \"description\": \"Réécriture de l'ancienne API vers la nouvelle\"\n  }\n];\n\n// Vérifier si ces règles existent déjà\nfor (const customRule of customRules) {\n  const exists = customizedRules.some(r => r.from === customRule.from);\n  if (!exists) {\n    customizedRules.push(customRule);\n  }\n}\n\n// Retourner les règles personnalisées\nreturn [\n  {\n    json: {\n      routingRules: customizedRules,\n      totalRules: customizedRules.length,\n      timestamp: new Date().toISOString()\n    }\n  }\n];"
      },
      "id": "f8a7a40a-e8d1-4aa9-82c0-4b1b4da4da44",
      "name": "Personnaliser les règles",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [
        940,
        300
      ]
    },
    {
      "parameters": {
        "filePath": "/workspaces/cahier-des-charge/routing_patch.json",
        "options": {
          "append": false
        }
      },
      "id": "6ad5a0a5-fbfb-4c5f-b17f-f11e35a69e32",
      "name": "Sauvegarder routing_patch.json",
      "type": "n8n-nodes-base.writeBinaryFile",
      "typeVersion": 1,
      "position": [
        1180,
        300
      ]
    },
    {
      "parameters": {
        "command": "cd /workspaces/cahier-des-charge && pm2 restart all",
        "executeTimeout": 30
      },
      "id": "b789b1b7-7a96-4835-8487-bac68ac1cfcc",
      "name": "Redémarrer NestJS",
      "type": "n8n-nodes-base.executeCommand",
      "typeVersion": 1,
      "position": [
        1420,
        300
      ]
    },
    {
      "parameters": {
        "filePath": "/workspaces/cahier-des-charge/reports/php_routes_audit.md"
      },
      "id": "a9d18d7a-76f2-4c75-a4ba-63a5d9989d98",
      "name": "Lire le rapport d'audit",
      "type": "n8n-nodes-base.readBinaryFile",
      "typeVersion": 1,
      "position": [
        700,
        500
      ]
    },
    {
      "parameters": {
        "filePath": "/workspaces/cahier-des-charge/reports/missing_php_routes.md"
      },
      "id": "c2d85d5e-8b0d-44b7-a456-c26d05fd0548",
      "name": "Lire le rapport des routes manquantes",
      "type": "n8n-nodes-base.readBinaryFile",
      "typeVersion": 1,
      "position": [
        700,
        700
      ]
    },
    {
      "parameters": {
        "jsCode": "// Analyser les rapports pour générer un résumé\nconst auditReport = Buffer.from(items[0].binary.data, 'base64').toString('utf-8');\nconst missingRoutesReport = Buffer.from(items[1].binary.data, 'base64').toString('utf-8');\n\n// Extraire des informations clés des rapports\nconst auditStats = {};\nconst auditSummaryMatch = auditReport.match(/Routes PHP détectées\\*\\*: (\\d+)[\\s\\S]*Routes déjà mappées\\*\\*: (\\d+)[\\s\\S]*Routes à mapper\\*\\*: (\\d+)/);\n\nif (auditSummaryMatch) {\n  auditStats.detected = parseInt(auditSummaryMatch[1]);\n  auditStats.mapped = parseInt(auditSummaryMatch[2]);\n  auditStats.toMap = parseInt(auditSummaryMatch[3]);\n}\n\n// Extraire statistiques des routes manquantes\nconst missingStats = {};\nconst missingSummaryMatch = missingRoutesReport.match(/Total des routes uniques non mappées: \\*\\*(\\d+)\\*\\*/);\n\nif (missingSummaryMatch) {\n  missingStats.unmappedUnique = parseInt(missingSummaryMatch[1]);\n}\n\n// Générer un résumé pour les administrateurs\nconst summary = `# Résumé de la migration des routes PHP\n\n## Audit des routes (${new Date().toLocaleDateString()})\n\n### Statistiques générales\n- Routes PHP détectées: ${auditStats.detected || 'N/A'}\n- Routes déjà mappées: ${auditStats.mapped || 'N/A'}\n- Routes à mapper: ${auditStats.toMap || 'N/A'}\n- Routes uniques non mappées: ${missingStats.unmappedUnique || 'N/A'}\n\n### Prochaines actions\n1. Examiner le rapport détaillé des routes non mappées pour identifier les priorités\n2. Mettre à jour le fichier routing_patch.json manuellement si nécessaire\n3. Vérifier les journaux d'erreurs pour identifier des problèmes potentiels\n\n[Voir le rapport d'audit complet](/reports/php_routes_audit.md)\n[Voir le rapport des routes manquantes](/reports/missing_php_routes.md)\n`;\n\n// Créer une notification Slack ou par e-mail\nreturn [\n  {\n    json: {\n      type: 'email',\n      subject: `[Migration PHP] Rapport des routes (${new Date().toLocaleDateString()})`,\n      body: summary,\n      stats: {\n        ...auditStats,\n        ...missingStats\n      }\n    }\n  }\n];"
      },
      "id": "a76ee0c8-d1e3-49ad-9a7c-fed6b62e2e96",
      "name": "Analyser les rapports",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [
        940,
        600
      ]
    },
    {
      "parameters": {
        "fromEmail": "migration@example.com",
        "toEmail": "admin@example.com",
        "subject": "={{ $json.subject }}",
        "text": "={{ $json.body }}",
        "options": {}
      },
      "id": "2a08f1ef-8e1e-4bcf-bca2-bbf84bfde8c1",
      "name": "Envoyer le rapport par email",
      "type": "n8n-nodes-base.emailSend",
      "typeVersion": 1,
      "position": [
        1180,
        600
      ]
    },
    {
      "parameters": {
        "url": "=https://hooks.slack.com/services/XXXXXX/XXXXXX/XXXXXXXXXXXXXXXX",
        "options": {},
        "jsonParameters": true,
        "bodyParametersJson": "={ \"text\": \"Rapport quotidien des routes PHP\\n\\n- Routes détectées: {{ $json.stats.detected }}\\n- Routes mappées: {{ $json.stats.mapped }}\\n- Routes à mapper: {{ $json.stats.toMap }}\\n- Routes non mappées: {{ $json.stats.unmappedUnique }}\" }"
      },
      "id": "86a1e3a7-e7e7-46a0-af1f-cd97dde5a65b",
      "name": "Notifier sur Slack",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [
        1420,
        600
      ]
    },
    {
      "parameters": {
        "functionCode": "// Générer des tests automatisés pour les redirections PHP\nconst routingRules = items[0].json.routingRules;\nconst timestamp = new Date().toISOString().replace(/:/g, '-').replace(/\\..+/, '');\nconst testFilePath = `/workspaces/cahier-des-charge/src/test/php-redirections.${timestamp}.spec.ts`;\n\n// Générer le contenu du fichier de test\nlet testFileContent = `import { Test, TestingModule } from '@nestjs/testing';\\nimport { INestApplication } from '@nestjs/common';\\nimport * as request from 'supertest';\\nimport { AppModule } from '../app.module';\\n\\ndescribe('PHP Redirections (${timestamp})', () => {\\n  let app: INestApplication;\\n\\n  beforeAll(async () => {\\n    const moduleFixture: TestingModule = await Test.createTestingModule({\\n      imports: [AppModule],\\n    }).compile();\\n\\n    app = moduleFixture.createNestApplication();\\n    await app.init();\\n  });\\n\\n  afterAll(async () => {\\n    await app.close();\\n  });\\n\\n`;\n\n// Générer des tests pour chaque type de redirection\nconst redirectTests = routingRules\n  .filter(rule => rule.type === 'redirect')\n  .slice(0, 10); // Limiter à 10 tests pour les redirections\n\nif (redirectTests.length > 0) {\n  testFileContent += `  describe('Redirections (301/302)', () => {\\n`;\n  \n  redirectTests.forEach(rule => {\n    testFileContent += `    it('should redirect ${rule.from} to ${rule.to}', () => {\\n`;\n    testFileContent += `      return request(app.getHttpServer())\\n`;\n    testFileContent += `        .get('${rule.from}')\\n`;\n    testFileContent += `        .expect(${rule.status || 301})\\n`;\n    testFileContent += `        .expect('Location', '${rule.to}');\\n`;\n    testFileContent += `    });\\n\\n`;\n  });\n  \n  testFileContent += `  });\\n\\n`;\n}\n\n// Tests pour les pages supprimées (410 Gone)\nconst removedTests = routingRules\n  .filter(rule => rule.type === 'removed')\n  .slice(0, 5); // Limiter à 5 tests pour les pages supprimées\n\nif (removedTests.length > 0) {\n  testFileContent += `  describe('Removed pages (410 Gone)', () => {\\n`;\n  \n  removedTests.forEach(rule => {\n    testFileContent += `    it('should return 410 for ${rule.from}', () => {\\n`;\n    testFileContent += `      return request(app.getHttpServer())\\n`;\n    testFileContent += `        .get('${rule.from}')\\n`;\n    testFileContent += `        .expect(410);\\n`;\n    testFileContent += `    });\\n\\n`;\n  });\n  \n  testFileContent += `  });\\n\\n`;\n}\n\n// Tests pour les réécritures\nconst rewriteTests = routingRules\n  .filter(rule => rule.type === 'rewrite')\n  .slice(0, 5); // Limiter à 5 tests pour les réécritures\n\nif (rewriteTests.length > 0) {\n  testFileContent += `  describe('Rewrites', () => {\\n`;\n  \n  rewriteTests.forEach(rule => {\n    testFileContent += `    it('should rewrite ${rule.from} internally', () => {\\n`;\n    testFileContent += `      return request(app.getHttpServer())\\n`;\n    testFileContent += `        .get('${rule.from}')\\n`;\n    testFileContent += `        .expect(200);\\n`;\n    testFileContent += `    });\\n\\n`;\n  });\n  \n  testFileContent += `  });\\n\\n`;\n}\n\n// Test pour une route non mappée\ntestFileContent += `  describe('Non-mapped routes', () => {\\n`;\ntestFileContent += `    it('should handle non-mapped PHP route correctly', () => {\\n`;\ntestFileContent += `      return request(app.getHttpServer())\\n`;\ntestFileContent += `        .get('/nonexistent-route.php')\\n`;\ntestFileContent += `        .expect(302)\\n`;\ntestFileContent += `        .expect('Location', /\\/legacy-not-migrated\\?url=/);\\n`;\ntestFileContent += `    });\\n`;\ntestFileContent += `  });\\n`;\n\ntestFileContent += `});\\n`;\n\n// Créer un item avec le contenu du fichier de test\nreturn [\n  {\n    json: {\n      testFilePath,\n      testFileContent,\n      timestamp\n    }\n  }\n];"
      },
      "id": "f9e238e1-7d5d-47ba-8e90-ec1ffa1dc89c",
      "name": "Générer des tests automatisés",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        1180,
        100
      ]
    },
    {
      "parameters": {
        "filePath": "={{ $json.testFilePath }}",
        "options": {
          "append": false
        }
      },
      "id": "77e8ef93-0dc4-4999-a1c6-5aa5af3fce9b",
      "name": "Sauvegarder le fichier de test",
      "type": "n8n-nodes-base.writeBinaryFile",
      "typeVersion": 1,
      "position": [
        1420,
        100
      ]
    },
    {
      "parameters": {
        "command": "cd /workspaces/cahier-des-charge && mkdir -p src/test && npx jest src/test/php-redirections.{{ $json.timestamp }}.spec.ts --forceExit",
        "executeTimeout": 60
      },
      "id": "b31b3a3f-c24e-4f17-a3ca-3b1e7aba0c5e",
      "name": "Exécuter les tests",
      "type": "n8n-nodes-base.executeCommand",
      "typeVersion": 1,
      "position": [
        1660,
        100
      ]
    }
  ],
  "connections": {
    "Schedule": {
      "main": [
        [
          {
            "node": "Audit des routes PHP",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Audit des routes PHP": {
      "main": [
        [
          {
            "node": "Lire routing_patch.json",
            "type": "main",
            "index": 0
          },
          {
            "node": "Lire le rapport d'audit",
            "type": "main",
            "index": 0
          },
          {
            "node": "Lire le rapport des routes manquantes",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Lire routing_patch.json": {
      "main": [
        [
          {
            "node": "Personnaliser les règles",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Personnaliser les règles": {
      "main": [
        [
          {
            "node": "Sauvegarder routing_patch.json",
            "type": "main",
            "index": 0
          },
          {
            "node": "Générer des tests automatisés",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Sauvegarder routing_patch.json": {
      "main": [
        [
          {
            "node": "Redémarrer NestJS",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Lire le rapport d'audit": {
      "main": [
        [
          {
            "node": "Analyser les rapports",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Lire le rapport des routes manquantes": {
      "main": [
        [
          {
            "node": "Analyser les rapports",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Analyser les rapports": {
      "main": [
        [
          {
            "node": "Envoyer le rapport par email",
            "type": "main",
            "index": 0
          },
          {
            "node": "Notifier sur Slack",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Générer des tests automatisés": {
      "main": [
        [
          {
            "node": "Sauvegarder le fichier de test",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Sauvegarder le fichier de test": {
      "main": [
        [
          {
            "node": "Exécuter les tests",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  }
}