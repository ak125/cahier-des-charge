#!/usr/bin/env node
/**
 * type-audit-agent.ts
 * 
 * Agent 2 ‚Äî Audit des types SQL
 * 
 * Fonctionnalit√©s:
 * - Conversion intelligente MySQL ‚Üí PostgreSQL (TINYINT ‚Üí Boolean, INT(11) ‚Üí Integer, etc.)
 * - Ajustement des tailles de champs (r√©duction de VARCHAR(255) si usage d√©tect√© court)
 * - D√©tection et mapping automatique des √©num√©rations
 * - Identification des probl√®mes de typage et optimisations
 * 
 * Usage: ts-node type-audit-agent.ts <chemin-schema.json> [options]
 * Options:
 *   --deep-analysis     Active l'analyse profonde du contenu des champs (peut √™tre lent)
 *   --adjust-sizes      Ajuste les tailles des champs VARCHAR/CHAR/TEXT
 *   --detect-enums      D√©tecte automatiquement les √©num√©rations
 *   --output-dir=<dir>  Dossier de sortie (d√©faut: ./outputs)
 * 
 * Sorties g√©n√©r√©es:
 * - type_conversion_map.json    : Mappings MySQL ‚Üí PostgreSQL/Prisma
 * - field_typing_issues.md      : Probl√®mes de typage d√©tect√©s avec recommandations
 * - prisma_enum.suggestion.prisma : D√©finitions d'√©num√©rations pour Prisma
 * 
 * Date: 11 avril 2025
 */

import * as fs from 'fs';
import * as path from 'path';
import { program } from 'commander';

// Interfaces et types
interface MySQLSchema {
  name: string;
  tables: Record<string, TableInfo>;
  version?: string;
  characterSet?: string;
  collation?: string;
  metadata?: Record<string, any>;
  classificationStats?: Record<string, number>;
  sampleData?: Record<string, any[]>;
}

interface TableInfo {
  name: string;
  columns: Record<string, ColumnInfo>;
  primaryKey?: string[];
  indexes?: IndexInfo[];
  foreignKeys?: ForeignKeyInfo[];
  constraints?: ConstraintInfo[];
  tableType?: string;
  classificationReason?: string;
  relations?: RelationInfo[];
  comment?: string;
}

interface ColumnInfo {
  name: string;
  type: string;
  nullable: boolean;
  isPrimary?: boolean;
  isUnique?: boolean;
  autoIncrement?: boolean;
  defaultValue?: string | null;
  comment?: string;
  length?: number;
  precision?: number;
  scale?: number;
  originalType?: string;
  suggestedPostgresType?: string;
  suggestedPrismaType?: string;
  suggestedLength?: number;
  isEnum?: boolean;
  enumValues?: string[];
  isImplicitForeignKey?: boolean;
  extra?: string;
  references?: {
    table: string;
    column: string;
  };
}

interface IndexInfo {
  name: string;
  columns: string[];
  isUnique: boolean;
  type: string;
}

interface ForeignKeyInfo {
  name: string;
  columns: string[];
  referencedTable: string;
  referencedColumns: string[];
  onDelete?: string;
  onUpdate?: string;
}

interface ConstraintInfo {
  name: string;
  type: string;
  definition: string;
}

interface RelationInfo {
  sourceTable: string;
  sourceColumn: string;
  targetTable: string;
  targetColumn: string;
  type: string;
  isImplicit: boolean;
}

interface TypeMappingResult {
  schema: MySQLSchema;
  issues: Array<TypeIssue>;
  enums: Record<string, EnumDefinition>;
  typeConversionMap: Record<string, TypeConversionRule[]>;
  statistics: {
    totalFields: number;
    convertedTypes: number;
    optimizedSizes: number;
    enumsDetected: number;
    issuesFound: number;
  };
}

interface TypeIssue {
  tableName: string;
  columnName: string;
  originalType: string;
  suggestedType: string;
  severity: 'high' | 'medium' | 'low';
  reason: string;
  recommendation: string;
}

interface EnumDefinition {
  name: string;
  values: string[];
  source: {
    table: string;
    column: string;
  };
}

interface TypeConversionRule {
  mysqlType: string;
  postgresType: string;
  prismaType: string;
  examples: Array<{
    table: string;
    column: string;
  }>;
  reason: string;
  recommendation?: string;
}

// Configuration de la ligne de commande
program
  .version('1.0.0')
  .description('Agent 2 ‚Äî Audit des types SQL - Conversion MySQL ‚Üí PostgreSQL/Prisma')
  .argument('<schema-path>', 'Chemin vers le fichier JSON du sch√©ma MySQL')
  .option('--deep-analysis', 'Active l\'analyse profonde du contenu des champs (peut √™tre lent)')
  .option('--adjust-sizes', 'Ajuste les tailles des champs VARCHAR/CHAR/TEXT')
  .option('--detect-enums', 'D√©tecte automatiquement les √©num√©rations')
  .option('--output-dir <dir>', 'Dossier de sortie', './outputs')
  .parse(process.argv);

const options = program.opts();
const schemaPath = program.args[0];

// Classe principale pour l'audit des types
class TypeAuditor {
  // Mapping des types MySQL vers PostgreSQL/Prisma
  private typeMappingRules: Record<string, { postgresType: string; prismaType: string; needsLength?: boolean; needsPrecision?: boolean }> = {
    // Types num√©riques
    'TINYINT': { postgresType: 'SMALLINT', prismaType: 'Int' },
    'SMALLINT': { postgresType: 'SMALLINT', prismaType: 'Int' },
    'MEDIUMINT': { postgresType: 'INTEGER', prismaType: 'Int' },
    'INT': { postgresType: 'INTEGER', prismaType: 'Int' },
    'INTEGER': { postgresType: 'INTEGER', prismaType: 'Int' },
    'BIGINT': { postgresType: 'BIGINT', prismaType: 'BigInt' },
    'FLOAT': { postgresType: 'REAL', prismaType: 'Float' },
    'DOUBLE': { postgresType: 'DOUBLE PRECISION', prismaType: 'Float' },
    'DECIMAL': { postgresType: 'DECIMAL', prismaType: 'Decimal', needsPrecision: true },
    'NUMERIC': { postgresType: 'NUMERIC', prismaType: 'Decimal', needsPrecision: true },
    
    // Types date et heure
    'DATE': { postgresType: 'DATE', prismaType: 'DateTime' },
    'DATETIME': { postgresType: 'TIMESTAMP', prismaType: 'DateTime' },
    'TIMESTAMP': { postgresType: 'TIMESTAMP', prismaType: 'DateTime' },
    'TIME': { postgresType: 'TIME', prismaType: 'String' },
    'YEAR': { postgresType: 'SMALLINT', prismaType: 'Int' },
    
    // Types texte
    'CHAR': { postgresType: 'CHAR', prismaType: 'String', needsLength: true },
    'VARCHAR': { postgresType: 'VARCHAR', prismaType: 'String', needsLength: true },
    'TINYTEXT': { postgresType: 'TEXT', prismaType: 'String' },
    'TEXT': { postgresType: 'TEXT', prismaType: 'String' },
    'MEDIUMTEXT': { postgresType: 'TEXT', prismaType: 'String' },
    'LONGTEXT': { postgresType: 'TEXT', prismaType: 'String' },
    
    // Types binaires
    'BINARY': { postgresType: 'BYTEA', prismaType: 'Bytes' },
    'VARBINARY': { postgresType: 'BYTEA', prismaType: 'Bytes' },
    'TINYBLOB': { postgresType: 'BYTEA', prismaType: 'Bytes' },
    'BLOB': { postgresType: 'BYTEA', prismaType: 'Bytes' },
    'MEDIUMBLOB': { postgresType: 'BYTEA', prismaType: 'Bytes' },
    'LONGBLOB': { postgresType: 'BYTEA', prismaType: 'Bytes' },
    
    // Types sp√©ciaux
    'ENUM': { postgresType: 'TEXT', prismaType: 'Enum' },
    'SET': { postgresType: 'TEXT[]', prismaType: 'String[]' },
    'JSON': { postgresType: 'JSONB', prismaType: 'Json' },
    'BIT': { postgresType: 'BOOLEAN', prismaType: 'Boolean' },
    'BOOLEAN': { postgresType: 'BOOLEAN', prismaType: 'Boolean' },
    'BOOL': { postgresType: 'BOOLEAN', prismaType: 'Boolean' },
    'UUID': { postgresType: 'UUID', prismaType: 'String' }
  };

  // Tailles optimales sugg√©r√©es pour diff√©rents types de champs
  private suggestedFieldSizes: Record<string, number> = {
    'email': 100,
    'name': 100,
    'first_name': 50,
    'last_name': 50,
    'password': 60, // Taille standard pour bcrypt
    'hash': 64, // SHA-256
    'username': 50,
    'login': 50,
    'phone': 20,
    'phone_number': 20,
    'mobile': 20,
    'address': 150,
    'street': 100,
    'city': 50,
    'state': 30,
    'country': 50,
    'zip': 10,
    'postal_code': 10,
    'zipcode': 10,
    'title': 100,
    'description': 500,
    'url': 200,
    'uri': 200,
    'link': 200,
    'path': 200,
    'code': 20,
    'ref': 30,
    'reference': 50,
    'status': 20,
    'type': 30,
    'uuid': 36, // Format UUID standard
    'token': 100,
    'note': 1000,
    'comment': 1000,
    'ip': 45, // IPv6
    'ip_address': 45,
    'avatar': 200,
    'image': 200,
    'thumbnail': 200,
    'locale': 10,
    'language': 20,
    'currency': 3
  };

  // Patterns pour identifier les champs qui devraient √™tre des √©num√©rations
  private enumPatterns: Record<string, RegExp> = {
    'status': /^(active|inactive|pending|completed|cancelled|deleted|draft|published|archived|failed|success)$/i,
    'gender': /^(male|female|other|m|f|o)$/i,
    'payment_type': /^(credit_card|debit_card|paypal|bank_transfer|check|cash|crypto)$/i,
    'payment_method': /^(credit_card|debit_card|paypal|bank_transfer|check|cash|crypto)$/i,
    'role': /^(admin|user|guest|editor|manager|moderator|member|subscriber|customer|owner|superadmin)$/i,
    'visibility': /^(public|private|protected|draft|internal|external|hidden|visible)$/i,
    'priority': /^(high|medium|low|critical|urgent|normal)$/i,
    'category': /.+/i // Tout pattern pour les cat√©gories, mais v√©rifier les occurrences multiples
  };

  /**
   * Analyse le sch√©ma et effectue l'audit des types
   */
  async auditTypes(schemaPath: string, options: any): Promise<TypeMappingResult> {
    // Charger le sch√©ma JSON
    console.log(`üîç Chargement du sch√©ma depuis ${schemaPath}...`);
    const schema: MySQLSchema = JSON.parse(fs.readFileSync(schemaPath, 'utf8'));
    
    // Cr√©er une copie profonde pour √©viter de modifier l'original
    const auditedSchema: MySQLSchema = JSON.parse(JSON.stringify(schema));
    
    // Statistiques
    const stats = {
      totalFields: 0,
      convertedTypes: 0,
      optimizedSizes: 0,
      enumsDetected: 0,
      issuesFound: 0
    };
    
    // Structures pour stocker les r√©sultats
    const issues: TypeIssue[] = [];
    const enums: Record<string, EnumDefinition> = {};
    const typeConversionMap: Record<string, TypeConversionRule[]> = {};

    // Parcourir toutes les tables du sch√©ma
    console.log('üîÑ Analyse des types dans le sch√©ma...');
    
    Object.entries(auditedSchema.tables).forEach(([tableName, table]) => {
      Object.entries(table.columns).forEach(([columnName, column]) => {
        stats.totalFields++;
        
        // √âtape 1: Conversion du type MySQL vers PostgreSQL/Prisma
        this.convertColumnType(column, tableName, columnName, typeConversionMap);
        stats.convertedTypes++;
        
        // √âtape 2: D√©tection sp√©ciale des bool√©ens
        if (this.detectBoolean(column, tableName, columnName)) {
          issues.push({
            tableName,
            columnName,
            originalType: column.originalType || column.type,
            suggestedType: 'BOOLEAN',
            severity: 'medium',
            reason: 'TINYINT(1) d√©tect√© comme bool√©en',
            recommendation: 'Convertir en type Boolean dans Prisma et PostgreSQL'
          });
          stats.issuesFound++;
        }
        
        // √âtape 3: Optimisation des tailles de champs
        if (options.adjustSizes && this.shouldAdjustSize(column)) {
          const optimalSize = this.determineOptimalSize(columnName, column);
          if (optimalSize && optimalSize < (column.length || Infinity)) {
            column.suggestedLength = optimalSize;
            
            // Ajuster le type PostgreSQL
            if (column.suggestedPostgresType && column.suggestedPostgresType.includes('VARCHAR')) {
              column.suggestedPostgresType = `VARCHAR(${optimalSize})`;
            }
            
            issues.push({
              tableName,
              columnName,
              originalType: `${column.type}(${column.length})`,
              suggestedType: `${column.type}(${optimalSize})`,
              severity: 'low',
              reason: `Taille excessive (${column.length}) pour un champ ${columnName}`,
              recommendation: `R√©duire la taille √† ${optimalSize} caract√®res`
            });
            stats.optimizedSizes++;
            stats.issuesFound++;
          }
        }
        
        // √âtape 4: D√©tection d'√©num√©rations
        if (options.detectEnums) {
          const enumInfo = this.detectEnum(column, tableName, columnName);
          if (enumInfo) {
            const enumName = this.toPascalCase(enumInfo.name);
            column.isEnum = true;
            column.enumValues = enumInfo.values;
            column.suggestedPrismaType = enumName;
            
            enums[enumName] = {
              name: enumName,
              values: enumInfo.values,
              source: {
                table: tableName,
                column: columnName
              }
            };
            
            issues.push({
              tableName,
              columnName,
              originalType: column.originalType || column.type,
              suggestedType: `Enum (${enumName})`,
              severity: 'medium',
              reason: `Valeurs distinctes limit√©es d√©tect√©es: ${enumInfo.values.join(', ')}`,
              recommendation: `Utiliser un type √©num√©r√© (${enumName}) dans Prisma`
            });
            stats.enumsDetected++;
            stats.issuesFound++;
          }
        }
        
        // √âtape 5: D√©tecter d'autres probl√®mes de typage
        this.detectTypingIssues(column, tableName, columnName, issues);
      });
    });

    console.log(`‚úÖ Analyse termin√©e! Statistiques:`);
    console.log(`   - Champs analys√©s: ${stats.totalFields}`);
    console.log(`   - Types convertis: ${stats.convertedTypes}`);
    console.log(`   - Tailles optimis√©es: ${stats.optimizedSizes}`);
    console.log(`   - √ânum√©rations d√©tect√©es: ${stats.enumsDetected}`);
    console.log(`   - Probl√®mes identifi√©s: ${stats.issuesFound}`);
    
    return {
      schema: auditedSchema,
      issues,
      enums,
      typeConversionMap,
      statistics: stats
    };
  }

  /**
   * D√©tecte si un champ devrait √™tre un bool√©en (TINYINT(1))
   */
  private detectBoolean(column: ColumnInfo, tableName: string, columnName: string): boolean {
    // TINYINT(1) est souvent utilis√© pour les bool√©ens
    if (column.originalType?.match(/TINYINT\s*\(\s*1\s*\)/i) ||
        (column.type === 'TINYINT' && column.length === 1)) {
      
      // V√©rifier le nom du champ (is_*, has_*, can_*, etc.)
      if (columnName.startsWith('is_') || 
          columnName.startsWith('has_') || 
          columnName.startsWith('can_') ||
          columnName.startsWith('should_') ||
          columnName.startsWith('allow_') ||
          columnName === 'active' ||
          columnName === 'enabled' ||
          columnName === 'visible' ||
          columnName === 'deleted' ||
          columnName === 'archived' ||
          columnName === 'published' ||
          columnName === 'locked' ||
          columnName === 'required') {
        
        column.suggestedPostgresType = 'BOOLEAN';
        column.suggestedPrismaType = 'Boolean';
        return true;
      }
    }
    return false;
  }

  /**
   * Convertit le type d'une colonne MySQL en types PostgreSQL et Prisma
   */
  private convertColumnType(
    column: ColumnInfo, 
    tableName: string, 
    columnName: string,
    typeConversionMap: Record<string, TypeConversionRule[]>
  ): void {
    // Extraire le type de base (sans longueur/pr√©cision)
    const baseType = this.extractBaseType(column.originalType || column.type);
    
    // Normaliser le type pour la correspondance
    const normalizedType = baseType.toUpperCase();
    
    if (this.typeMappingRules[normalizedType]) {
      const mapping = this.typeMappingRules[normalizedType];
      let postgresType = mapping.postgresType;
      const prismaType = mapping.prismaType;
      
      // Ajouter la longueur/pr√©cision si n√©cessaire
      if (mapping.needsLength && column.length) {
        postgresType = `${postgresType}(${column.length})`;
      } else if (mapping.needsPrecision && column.precision) {
        if (column.scale !== undefined) {
          postgresType = `${postgresType}(${column.precision},${column.scale})`;
        } else {
          postgresType = `${postgresType}(${column.precision})`;
        }
      }
      
      // Appliquer la conversion
      column.suggestedPostgresType = postgresType;
      column.suggestedPrismaType = prismaType;
      
      // Ajouter √† la carte de conversion
      this.addToConversionMap(
        typeConversionMap, 
        normalizedType, 
        postgresType, 
        prismaType, 
        tableName, 
        columnName
      );
    } else {
      // Type non reconnu, utiliser TEXT/String par d√©faut
      column.suggestedPostgresType = 'TEXT';
      column.suggestedPrismaType = 'String';
      
      // Ajouter un probl√®me pour les types non reconnus
      this.addToConversionMap(
        typeConversionMap, 
        normalizedType, 
        'TEXT', 
        'String', 
        tableName, 
        columnName,
        'Type MySQL non reconnu, conversion g√©n√©rique appliqu√©e'
      );
    }
  }

  /**
   * Ajoute une r√®gle de conversion √† la carte de conversion
   */
  private addToConversionMap(
    map: Record<string, TypeConversionRule[]>,
    mysqlType: string,
    postgresType: string,
    prismaType: string,
    tableName: string,
    columnName: string,
    reason: string = 'Conversion standard'
  ): void {
    if (!map[mysqlType]) {
      map[mysqlType] = [];
    }
    
    // V√©rifier si cette r√®gle existe d√©j√†
    let rule = map[mysqlType].find(r => 
      r.postgresType === postgresType && 
      r.prismaType === prismaType
    );
    
    if (!rule) {
      rule = {
        mysqlType,
        postgresType,
        prismaType,
        examples: [],
        reason
      };
      map[mysqlType].push(rule);
    }
    
    // Ajouter cet exemple
    rule.examples.push({
      table: tableName,
      column: columnName
    });
  }

  /**
   * Extrait le type de base d'une cha√Æne de type MySQL
   */
  private extractBaseType(type: string): string {
    // Extraire le type de base sans la longueur/pr√©cision
    const match = type.match(/^([A-Za-z]+)/);
    return match ? match[1] : type;
  }

  /**
   * V√©rifie si un champ devrait avoir sa taille ajust√©e
   */
  private shouldAdjustSize(column: ColumnInfo): boolean {
    // V√©rifier si c'est un type VARCHAR ou CHAR avec une longueur
    if ((column.type === 'VARCHAR' || column.type === 'CHAR') && column.length) {
      // Ne pas ajuster les cl√©s primaires ou uniques pour s√©curit√©
      if (column.isPrimary || column.isUnique) {
        return false;
      }
      return true;
    }
    return false;
  }

  /**
   * D√©termine la taille optimale pour un champ bas√© sur son nom
   */
  private determineOptimalSize(columnName: string, column: ColumnInfo): number | null {
    // V√©rifier les r√®gles pr√©d√©finies
    for (const [pattern, size] of Object.entries(this.suggestedFieldSizes)) {
      if (columnName.includes(pattern) || columnName === pattern) {
        return size;
      }
    }
    
    // Si c'est un VARCHAR(255) et non une cl√©, sugg√©rer 100 par d√©faut
    if (column.type === 'VARCHAR' && column.length === 255 && !column.isPrimary && !column.isUnique) {
      return 100;
    }
    
    return null;
  }

  /**
   * D√©tecte si une colonne pourrait √™tre une √©num√©ration
   */
  private detectEnum(
    column: ColumnInfo, 
    tableName: string, 
    columnName: string
  ): { name: string; values: string[] } | null {
    // Si c'est d√©j√† un ENUM MySQL, extraire directement les valeurs
    if (column.type === 'ENUM' || column.originalType?.toUpperCase().startsWith('ENUM')) {
      const match = (column.originalType || '').match(/ENUM\s*\(\s*(.+?)\s*\)/i);
      if (match && match[1]) {
        return {
          name: columnName,
          values: match[1].split(',').map(value => 
            value.trim().replace(/^['"]|['"]$/g, '')
          )
        };
      }
    }
    
    // Si ce n'est pas un type cha√Æne, ignorer
    if (!['VARCHAR', 'CHAR', 'TEXT', 'TINYTEXT'].includes(column.type.toUpperCase())) {
      return null;
    }
    
    // V√©rifier le nom pour des patterns connus d'√©num√©ration
    for (const [patternName, regex] of Object.entries(this.enumPatterns)) {
      if (columnName.includes(patternName) || 
          columnName === patternName ||
          columnName.endsWith(`_${patternName}`) || 
          columnName.startsWith(`${patternName}_`)) {
        
        // S'il y a des valeurs d'√©chantillon, tester contre le pattern
        if (column.enumValues && column.enumValues.length > 0) {
          if (column.enumValues.length <= 15 && 
              column.enumValues.every(val => typeof val === 'string' && val.length < 30)) {
            return {
              name: columnName,
              values: column.enumValues
            };
          }
        }
        
        // Pour les types nomm√©s "status", "type", etc. sans donn√©es, cr√©er un enum par d√©faut
        if (columnName === 'status') {
          return {
            name: 'Status',
            values: ['ACTIVE', 'INACTIVE', 'PENDING', 'ARCHIVED']
          };
        } else if (columnName === 'type' || columnName.endsWith('_type')) {
          return {
            name: this.toPascalCase(columnName),
            values: ['STANDARD', 'PREMIUM', 'BASIC']
          };
        }
      }
    }
    
    // V√©rifier le commentaire pour des indices d'√©num√©ration
    if (column.comment) {
      const comment = column.comment.toLowerCase();
      if (comment.includes('enum') || 
          comment.includes('valeurs possibles') || 
          comment.includes('possible values') ||
          comment.includes('valeurs autoris√©es') ||
          comment.includes('allowed values') ||
          comment.includes('type:')) {
        
        // Tenter d'extraire les valeurs du commentaire
        const valuesMatch = comment.match(/(?:valeurs|values|options)[\s:]+([^\.]+)/i);
        if (valuesMatch && valuesMatch[1]) {
          const values = valuesMatch[1]
            .split(/[,;|]/)
            .map(v => v.trim())
            .filter(v => v.length > 0);
          
          if (values.length >= 2 && values.length <= 15) {
            return {
              name: columnName,
              values: values.map(v => v.toUpperCase())
            };
          }
        }
        
        // Sugg√©rer une √©num√©ration m√™me sans valeurs extraites
        return {
          name: columnName,
          values: [`${columnName.toUpperCase()}_1`, `${columnName.toUpperCase()}_2`, `${columnName.toUpperCase()}_3`]
        };
      }
    }
    
    return null;
  }

  /**
   * D√©tecte d'autres probl√®mes de typage potentiels
   */
  private detectTypingIssues(
    column: ColumnInfo, 
    tableName: string, 
    columnName: string, 
    issues: TypeIssue[]
  ): void {
    const originalType = column.originalType || column.type;
    
    // D√©tecter TEXT pour des champs courts
    if (['TEXT', 'MEDIUMTEXT', 'LONGTEXT'].includes(column.type.toUpperCase())) {
      if (columnName.includes('name') ||
          columnName.includes('title') ||
          columnName.includes('code') ||
          columnName.includes('short') ||
          columnName.includes('summary')) {
        
        issues.push({
          tableName,
          columnName,
          originalType,
          suggestedType: 'VARCHAR(200)',
          severity: 'low',
          reason: 'Type TEXT utilis√© pour un champ probablement court',
          recommendation: 'Utiliser VARCHAR avec une limite appropri√©e (100-200 caract√®res)'
        });
      }
    }
    
    // D√©tecter VARCHAR tr√®s long qui devrait √™tre TEXT
    if (column.type.toUpperCase() === 'VARCHAR' && column.length && column.length > 1000) {
      issues.push({
        tableName,
        columnName,
        originalType,
        suggestedType: 'TEXT',
        severity: 'low',
        reason: `VARCHAR(${column.length}) tr√®s large`,
        recommendation: 'Utiliser TEXT pour de longs contenus'
      });
    }
    
    // D√©tecter INT pour stocker des dates (erreur commune)
    if (['INT', 'INTEGER', 'BIGINT'].includes(column.type.toUpperCase())) {
      if (columnName.includes('date') ||
          columnName.includes('time') ||
          columnName === 'created_at' ||
          columnName === 'updated_at' ||
          columnName === 'deleted_at') {
        
        issues.push({
          tableName,
          columnName,
          originalType,
          suggestedType: 'TIMESTAMP',
          severity: 'medium',
          reason: 'Entier utilis√© pour stocker une date/heure',
          recommendation: 'Utiliser TIMESTAMP ou DATETIME'
        });
        
        // Corriger le type sugg√©r√©
        column.suggestedPostgresType = 'TIMESTAMP';
        column.suggestedPrismaType = 'DateTime';
      }
    }
    
    // D√©tecter DECIMAL sans pr√©cision pour des montants
    if (column.type.toUpperCase() === 'DECIMAL' && (!column.precision || column.precision < 8)) {
      if (columnName.includes('price') ||
          columnName.includes('amount') ||
          columnName.includes('cost') ||
          columnName.includes('total') ||
          columnName.includes('fee') ||
          columnName.includes('tax')) {
        
        issues.push({
          tableName,
          columnName,
          originalType,
          suggestedType: 'DECIMAL(10,2)',
          severity: 'medium',
          reason: 'Pr√©cision insuffisante pour un montant mon√©taire',
          recommendation: 'Utiliser DECIMAL(10,2) pour les montants mon√©taires'
        });
        
        // Corriger le type sugg√©r√©
        column.suggestedPostgresType = 'DECIMAL(10,2)';
        column.precision = 10;
        column.scale = 2;
      }
    }
  }

  /**
   * Convertit un texte en format PascalCase
   */
  private toPascalCase(str: string): string {
    return str
      .split(/[-_\s]/)
      .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
      .join('');
  }

  /**
   * Convertit un texte en format camelCase
   */
  private toCamelCase(str: string): string {
    const pascalCase = this.toPascalCase(str);
    return pascalCase.charAt(0).toLowerCase() + pascalCase.slice(1);
  }
}

/**
 * G√©n√®re un sch√©ma Prisma contenant uniquement les √©num√©rations
 */
function generatePrismaEnums(enums: Record<string, EnumDefinition>): string {
  let prismaSchema = `// Prisma Enums - G√©n√©r√©s automatiquement
// Date: ${new Date().toISOString().split('T')[0]}
// Source: Type Audit Agent

`;

  // Trier les enums par nom
  const sortedEnums = Object.values(enums).sort((a, b) => a.name.localeCompare(b.name));
  
  for (const enumDef of sortedEnums) {
    prismaSchema += `enum ${enumDef.name} {\n`;
    
    // Trier les valeurs pour une meilleure lisibilit√©
    const sortedValues = [...enumDef.values].sort();
    
    for (const value of sortedValues) {
      prismaSchema += `  ${value}\n`;
    }
    
    prismaSchema += `}\n\n`;
  }
  
  return prismaSchema;
}

/**
 * G√©n√®re le rapport sur les probl√®mes de typage
 */
function generateTypingIssuesReport(issues: TypeIssue[]): string {
  let markdown = `# Rapport d'audit des types SQL

*G√©n√©r√© le ${new Date().toISOString().split('T')[0]}*

Ce rapport identifie les probl√®mes potentiels de typage dans le sch√©ma MySQL et propose des optimisations pour la migration vers PostgreSQL et Prisma.

## R√©sum√© des probl√®mes

Total des probl√®mes d√©tect√©s: **${issues.length}**

| S√©v√©rit√© | Nombre |
|----------|--------|
| üî¥ Haute | ${issues.filter(i => i.severity === 'high').length} |
| üü† Moyenne | ${issues.filter(i => i.severity === 'medium').length} |
| üü° Basse | ${issues.filter(i => i.severity === 'low').length} |

## Probl√®mes par table

`;

  // Regrouper les probl√®mes par table
  const issuesByTable = issues.reduce((acc, issue) => {
    if (!acc[issue.tableName]) {
      acc[issue.tableName] = [];
    }
    acc[issue.tableName].push(issue);
    return acc;
  }, {} as Record<string, TypeIssue[]>);
  
  // G√©n√©rer le rapport pour chaque table
  for (const [tableName, tableIssues] of Object.entries(issuesByTable)) {
    markdown += `### Table: \`${tableName}\`\n\n`;
    markdown += `| Colonne | Type original | Type sugg√©r√© | Raison | Recommandation |\n`;
    markdown += `|---------|--------------|-------------|--------|----------------|\n`;
    
    for (const issue of tableIssues) {
      const severityIcon = issue.severity === 'high' ? 'üî¥' : issue.severity === 'medium' ? 'üü†' : 'üü°';
      markdown += `| ${issue.columnName} | \`${issue.originalType}\` | \`${issue.suggestedType}\` | ${severityIcon} ${issue.reason} | ${issue.recommendation} |\n`;
    }
    
    markdown += `\n`;
  }
  
  // Ajouter section sur les conversions de types les plus fr√©quentes
  markdown += `## Conversions de types les plus courantes\n\n`;
  
  // Regrouper par type de conversion
  const byConversion = issues.reduce((acc, issue) => {
    const key = `${issue.originalType} ‚Üí ${issue.suggestedType}`;
    if (!acc[key]) {
      acc[key] = [];
    }
    acc[key].push(issue);
    return acc;
  }, {} as Record<string, TypeIssue[]>);
  
  markdown += `| Type MySQL | Type PostgreSQL | Type Prisma | Instances | Raison |\n`;
  markdown += `|------------|----------------|-------------|-----------|--------|\n`;
  
  Object.entries(byConversion)
    .sort((a, b) => b[1].length - a[1].length)
    .forEach(([conversion, convIssues]) => {
      const [mysqlType, postgresType] = conversion.split(' ‚Üí ');
      let prismaType = 'String'; // Type par d√©faut
      
      // Trouver le type Prisma √† partir du premier probl√®me
      if (convIssues[0].suggestedType.includes('Enum')) {
        prismaType = 'Enum';
      } else if (convIssues[0].suggestedType === 'BOOLEAN') {
        prismaType = 'Boolean';
      } else if (convIssues[0].suggestedType === 'TIMESTAMP') {
        prismaType = 'DateTime';
      } else if (convIssues[0].suggestedType.startsWith('DECIMAL')) {
        prismaType = 'Decimal';
      } else if (convIssues[0].suggestedType === 'TEXT') {
        prismaType = 'String';
      } else if (convIssues[0].suggestedType.startsWith('VARCHAR')) {
        prismaType = 'String';
      }
      
      const reason = convIssues[0].reason;
      
      markdown += `| ${mysqlType} | ${postgresType} | ${prismaType} | ${convIssues.length} | ${reason} |\n`;
    });
  
  markdown += `\n`;
  
  // Ajouter section des recommandations g√©n√©rales
  markdown += `## Recommandations g√©n√©rales\n\n`;
  
  // Regrouper les recommandations
  const recommendations = issues.reduce((acc, issue) => {
    if (!acc[issue.recommendation]) {
      acc[issue.recommendation] = 0;
    }
    acc[issue.recommendation]++;
    return acc;
  }, {} as Record<string, number>);
  
  // Trier par fr√©quence
  Object.entries(recommendations)
    .sort((a, b) => b[1] - a[1])
    .forEach(([recommendation, count]) => {
      markdown += `- ${recommendation} (${count} occurrences)\n`;
    });
  
  return markdown;
}

/**
 * Sauvegarde un objet JSON dans un fichier
 */
function saveToJson(filePath: string, data: any): void {
  fs.writeFileSync(filePath, JSON.stringify(data, null, 2), 'utf8');
}

/**
 * Sauvegarde du texte Markdown dans un fichier
 */
function saveToMarkdown(filePath: string, markdown: string): void {
  fs.writeFileSync(filePath, markdown, 'utf8');
}

/**
 * Fonction principale
 */
async function main() {
  try {
    // V√©rifier que le fichier existe
    if (!fs.existsSync(schemaPath)) {
      console.error(`‚ùå Le fichier ${schemaPath} n'existe pas`);
      process.exit(1);
    }
    
    // Pr√©parer le dossier de sortie
    const outputDir = path.resolve(options.outputDir);
    if (!fs.existsSync(outputDir)) {
      fs.mkdirSync(outputDir, { recursive: true });
    }
    
    console.log(`üöÄ Agent 2 - Audit des types SQL d√©marr√©...`);
    console.log(`üìÇ Fichier sch√©ma: ${schemaPath}`);
    console.log(`üìÅ Dossier de sortie: ${outputDir}`);
    
    // Cr√©er et ex√©cuter l'auditeur de types
    const typeAuditor = new TypeAuditor();
    const result = await typeAuditor.auditTypes(schemaPath, {
      deepAnalysis: options.deepAnalysis,
      adjustSizes: options.adjustSizes || true,
      detectEnums: options.detectEnums || true
    });
    
    // G√©n√©rer et sauvegarder les r√©sultats
    console.log('üìù G√©n√©ration des fichiers de r√©sultats...');
    
    // 1. Sauvegarder la carte de conversion des types
    const typeConversionMapPath = path.join(outputDir, 'type_conversion_map.json');
    saveToJson(typeConversionMapPath, result.typeConversionMap);
    console.log(`‚úÖ ${typeConversionMapPath} g√©n√©r√©`);
    
    // 2. Sauvegarder le rapport des probl√®mes de typage
    const fieldTypingIssuesPath = path.join(outputDir, 'field_typing_issues.md');
    const typingIssuesReport = generateTypingIssuesReport(result.issues);
    saveToMarkdown(fieldTypingIssuesPath, typingIssuesReport);
    console.log(`‚úÖ ${fieldTypingIssuesPath} g√©n√©r√©`);
    
    // 3. Sauvegarder les √©num√©rations Prisma
    const prismaEnumsPath = path.join(outputDir, 'prisma_enum.suggestion.prisma');
    const prismaEnums = generatePrismaEnums(result.enums);
    fs.writeFileSync(prismaEnumsPath, prismaEnums, 'utf8');
    console.log(`‚úÖ ${prismaEnumsPath} g√©n√©r√©`);
    
    // 4. Sauvegarder le sch√©ma avec les types convertis
    const convertedSchemaPath = path.join(outputDir, 'mysql_schema_converted.json');
    saveToJson(convertedSchemaPath, result.schema);
    console.log(`‚úÖ ${convertedSchemaPath} g√©n√©r√©`);
    
    console.log('üéâ Agent 2 - Audit des types SQL termin√© avec succ√®s!');
  } catch (error) {
    console.error(`‚ùå Erreur: ${error instanceof Error ? error.message : String(error)}`);
    if (error instanceof Error && error.stack) {
      console.error(error.stack);
    }
    process.exit(1);
  }
}

// Ex√©cuter la fonction principale
main();





























import { BaseAgent } from '@workspaces/cahier-des-charge/src/core/interfaces/base-agent';
import { BusinessAgent } from '@workspaces/cahier-des-charge/src/core/interfaces/business';


























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































