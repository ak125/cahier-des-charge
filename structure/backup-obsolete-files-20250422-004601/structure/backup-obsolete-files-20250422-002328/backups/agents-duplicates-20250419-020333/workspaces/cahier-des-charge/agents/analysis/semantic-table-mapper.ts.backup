// Agent de Cartographie S√©mantique des Tables SQL
// Cet agent analyse et classifie les tables d'une base de donn√©es selon leur r√¥le fonctionnel

import * as fs from 'fs';
import * as path from 'path';
import { BaseAgent, BusinessAgent } from '../core/interfaces/base-agent';


import { AnalyzerAgent } from '@workspaces/cahier-des-charge/src/core/interfaces/business';
interface SemanticTableDefinition {
  name: string;
  category: string;
  role: string;
  confidence: number;
  relations: string[];
  isJunction: boolean;
  isTechnical: boolean;
  isOrphan: boolean;
  tags: string[];
  metadata: {
    columnCount: number;
    hasPrimaryKey: boolean;
    hasTimestamps: boolean;
    suggestedName?: string;
    contextScore: number;
    relatedDomains: string[];
  };
}

interface SemanticMapResult {
  entityGroups: {
    [key: string]: string[];
  };
  junctionTables: string[];
  technicalTables: {
    [key: string]: string[];
  };
  orphanTables: string[];
  tablesByDomain: {
    [key: string]: string[];
  };
  entityRelationships: {
    [key: string]: string[];
  };
  metadata: {
    mappedTables: number;
    unmappedTables: number;
    analysisCoverage: number;
    identifiedRelationships: number;
    timestamp: string;
  };
  tableDefinitions: {
    [key: string]: SemanticTableDefinition;
  };
}

export class SemanticMapper implements BaseAgent, BusinessAgent , AnalyzerAgent{
  private schemaData: any;
  private config: any;
  private configPath: string;
  private outputPath: string;

  constructor(schemaFilePath: string, configPath: string, outputPath: string) {
    try {
      this.schemaData = JSON.parse(fs.readFileSync(schemaFilePath, 'utf8'));
    } catch (error) {
      console.error(`Erreur lors de la lecture du sch√©ma: ${error}`);
      throw new Error('Impossible de lire le sch√©ma JSON');
    }

    this.configPath = configPath;
    this.outputPath = outputPath;
    this.loadConfig();
  }

  private loadConfig() {
    try {
      const configData = JSON.parse(fs.readFileSync(this.configPath, 'utf8'));
      this.config = configData.agents.semanticMapper;
    } catch (error) {
      console.error(`Erreur lors de la lecture de la configuration: ${error}`);
      throw new Error('Configuration introuvable ou invalide');
    }
  }

  public async analyze(): Promise<SemanticMapResult> {
    console.log('‚è≥ D√©marrage de l\'analyse s√©mantique des tables...');
    
    const tableNames = this.extractTableNames();
    console.log(`üìä ${tableNames.length} tables trouv√©es pour l'analyse`);

    // Initialiser le r√©sultat
    const result: SemanticMapResult = {
      entityGroups: {},
      junctionTables: [],
      technicalTables: {},
      orphanTables: [],
      tablesByDomain: {},
      entityRelationships: {},
      metadata: {
        mappedTables: 0,
        unmappedTables: 0,
        analysisCoverage: 0,
        identifiedRelationships: 0,
        timestamp: new Date().toISOString(),
      },
      tableDefinitions: {}
    };

    // Initialiser les groupes d'entit√©s bas√©s sur la configuration
    this.config.entityPatterns.forEach((pattern: any) => {
      result.entityGroups[pattern.category] = [];
    });

    // Initialiser les groupes de tables techniques
    const technicalCategories = Array.from(
      new Set(
        this.config.technicalTablePatterns.map((pattern: any) => pattern.category)
      )
    );
    technicalCategories.forEach((category) => {
      result.technicalTables[category] = [];
    });

    // Classifier chaque table
    for (const tableName of tableNames) {
      if (this.config.skipTables.includes(tableName)) {
        console.log(`‚è≠Ô∏è Table ignor√©e: ${tableName}`);
        continue;
      }

      const tableDefinition = this.analyzeTable(tableName);
      result.tableDefinitions[tableName] = tableDefinition;

      // Ajouter √† la cat√©gorie appropri√©e
      if (tableDefinition.isJunction) {
        result.junctionTables.push(tableName);
      } else if (tableDefinition.isTechnical) {
        result.technicalTables[tableDefinition.category].push(tableName);
      } else if (tableDefinition.isOrphan) {
        result.orphanTables.push(tableName);
      } else if (tableDefinition.category) {
        if (!result.entityGroups[tableDefinition.category]) {
          result.entityGroups[tableDefinition.category] = [];
        }
        result.entityGroups[tableDefinition.category].push(tableName);
      }

      // Domaines associ√©s
      tableDefinition.metadata.relatedDomains.forEach(domain => {
        if (!result.tablesByDomain[domain]) {
          result.tablesByDomain[domain] = [];
        }
        result.tablesByDomain[domain].push(tableName);
      });

      // Relations
      if (tableDefinition.relations.length > 0) {
        result.entityRelationships[tableName] = tableDefinition.relations;
        result.metadata.identifiedRelationships += tableDefinition.relations.length;
      }
    }

    // Calculer les m√©tadonn√©es globales
    result.metadata.mappedTables = Object.keys(result.tableDefinitions).length;
    result.metadata.unmappedTables = tableNames.length - result.metadata.mappedTables;
    result.metadata.analysisCoverage = tableNames.length > 0 
      ? result.metadata.mappedTables / tableNames.length 
      : 0;

    console.log('‚úÖ Analyse s√©mantique des tables termin√©e');
    return result;
  }

  private extractTableNames(): string[] {
    if (!this.schemaData.tables) {
      return [];
    }
    return Object.keys(this.schemaData.tables);
  }

  private analyzeTable(tableName: string): SemanticTableDefinition {
    console.log(`üîç Analyse de la table: ${tableName}`);
    
    const table = this.schemaData.tables[tableName];
    const columns = table.columns || {};
    const columnNames = Object.keys(columns);

    // Initialiser la d√©finition de table
    const tableDefinition: SemanticTableDefinition = {
      name: tableName,
      category: '',
      role: '',
      confidence: 0,
      relations: [],
      isJunction: false,
      isTechnical: false,
      isOrphan: false,
      tags: [],
      metadata: {
        columnCount: columnNames.length,
        hasPrimaryKey: this.hasPrimaryKey(table),
        hasTimestamps: this.hasTimestampColumns(columnNames),
        contextScore: 0,
        relatedDomains: []
      }
    };

    // V√©rifier si c'est une table de jonction
    this.checkJunctionTable(tableName, tableDefinition);

    // V√©rifier si c'est une table technique
    if (!tableDefinition.isJunction) {
      this.checkTechnicalTable(tableName, tableDefinition);
    }

    // V√©rifier si c'est une table orpheline
    if (!tableDefinition.isJunction && !tableDefinition.isTechnical) {
      this.checkOrphanTable(tableName, tableDefinition);
    }

    // Identifier la cat√©gorie d'entit√©
    if (!tableDefinition.isJunction && !tableDefinition.isTechnical && !tableDefinition.isOrphan) {
      this.identifyEntityCategory(tableName, tableDefinition);
    }

    // Analyser le contexte des colonnes
    this.analyzeColumnContext(columnNames, tableDefinition);

    // Identifier les relations avec d'autres tables
    this.identifyRelations(tableName, columnNames, tableDefinition);

    // G√©n√©rer des tags descriptifs
    this.generateTags(tableDefinition, columnNames);

    return tableDefinition;
  }

  private hasPrimaryKey(table: any): boolean {
    // V√©rifier s'il existe une cl√© primaire dans la table
    if (table.primaryKey && table.primaryKey.columns && table.primaryKey.columns.length > 0) {
      return true;
    }
    
    // V√©rifier si une colonne est marqu√©e comme √©tant une cl√© primaire
    const columns = table.columns || {};
    for (const columnName in columns) {
      if (columns[columnName].isPrimaryKey) {
        return true;
      }
    }
    
    return false;
  }

  private hasTimestampColumns(columnNames: string[]): boolean {
    const timestampColumns = ['created_at', 'updated_at', 'deleted_at', 'timestamp', 'date_creation', 'date_modification'];
    return columnNames.some(column => timestampColumns.includes(column.toLowerCase()));
  }

  private checkJunctionTable(tableName: string, tableDefinition: SemanticTableDefinition): void {
    // Caract√©ristiques d'une table de jonction
    // 1. Nom contenant des indicateurs comme "_has_", "_to_", "link", "rel", "map"
    // 2. Nombre limit√© de colonnes (g√©n√©ralement 2-4)
    // 3. Colonnes principalement des cl√©s √©trang√®res

    const junctionPatterns = this.config.junctionTablePatterns || [];
    const columnNames = Object.keys(this.schemaData.tables[tableName].columns || {});
    const hasForeignKeys = this.countForeignKeyColumns(tableName) >= 2;
    const hasLimitedColumns = columnNames.length <= 5;    
    // V√©rification du nom de la table
    const nameMatchesPattern = junctionPatterns.some((pattern: string) => 
      new RegExp(pattern, 'i').test(tableName)
    );
    
    // V√©rifier si le nom contient "_has_", "_to_" ou autres indicateurs communs
    const nameIndicatesJunction = /(_has_|_to_|_link|_rel|_map)/.test(tableName);
    
    // Une table est consid√©r√©e comme table de jonction si elle a des cl√©s √©trang√®res et
    // soit son nom correspond √† un motif de jonction, soit elle a un nombre limit√© de colonnes
    const isJunction = hasForeignKeys && (nameMatchesPattern || nameIndicatesJunction || hasLimitedColumns);
    
    // Calculer le niveau de confiance
    let confidence = 0;
    if (hasForeignKeys) confidence += 0.3;
    if (nameMatchesPattern) confidence += 0.3;
    if (nameIndicatesJunction) confidence += 0.2;
    if (hasLimitedColumns) confidence += 0.2;
    
    // Mettre √† jour la d√©finition de la table
    tableDefinition.isJunction = isJunction;
    if (isJunction) {
      tableDefinition.category = 'JUNCTION';
      tableDefinition.role = 'Relation N-N';
      tableDefinition.confidence = Math.min(confidence, 1);
    }
  }

  private countForeignKeyColumns(tableName: string): number {
    const table = this.schemaData.tables[tableName];
    const columns = table.columns || {};
    let fkCount = 0;
    
    for (const columnName in columns) {
      const column = columns[columnName];
      if (column.isForeignKey || columnName.endsWith('_id') || columnName.endsWith('_fk')) {
        fkCount++;
      }
    }
    
    return fkCount;
  }

  private checkTechnicalTable(tableName: string, tableDefinition: SemanticTableDefinition): void {
    const technicalPatterns = this.config.technicalTablePatterns || [];
    
    for (const pattern of technicalPatterns) {
      if (new RegExp(pattern.pattern, 'i').test(tableName)) {
        tableDefinition.isTechnical = true;
        tableDefinition.category = pattern.category || 'technical';
        tableDefinition.role = pattern.role || 'Support technique';
        tableDefinition.confidence = 0.85;
        tableDefinition.tags.push('technique');
        tableDefinition.tags.push(pattern.category.toLowerCase());
        break;
      }
    }
    
    // V√©rification suppl√©mentaire pour les tables techniques courantes
    const commonTechnicalPatterns = [
      /^log_/, /^audit_/, /^temp_/, /^bak_/, /^backup_/,
      /^cache/, /^config/, /^setting/, /^param/,
      /^migration/, /^version/, /^sync_/
    ];
    
    if (!tableDefinition.isTechnical) {
      for (const pattern of commonTechnicalPatterns) {
        if (pattern.test(tableName)) {
          tableDefinition.isTechnical = true;
          tableDefinition.category = 'system';
          tableDefinition.role = 'Support syst√®me';
          tableDefinition.confidence = 0.75;
          tableDefinition.tags.push('technique');
          tableDefinition.tags.push('syst√®me');
          break;
        }
      }
    }
  }

  private checkOrphanTable(tableName: string, tableDefinition: SemanticTableDefinition): void {
    // Une table orpheline n'a pas ou peu de relations avec d'autres tables
    const foreignKeyCount = this.countForeignKeyColumns(tableName);
    const isReferencedByOthers = this.isTableReferencedByOthers(tableName);
    
    // Si la table n'a pas de cl√©s √©trang√®res et n'est pas r√©f√©renc√©e par d'autres tables
    if (foreignKeyCount === 0 && !isReferencedByOthers) {
      tableDefinition.isOrphan = true;
      tableDefinition.category = 'orphan';
      tableDefinition.role = 'Table isol√©e';
      tableDefinition.confidence = 0.7;
      tableDefinition.tags.push('orpheline');
    }
  }

  private isTableReferencedByOthers(tableName: string): boolean {
    // Parcourir toutes les tables pour v√©rifier si elles r√©f√©rencent cette table
    for (const otherTableName in this.schemaData.tables) {
      if (otherTableName === tableName) continue;
      
      const foreignKeys = this.schemaData.tables[otherTableName].foreignKeys || [];
      
      for (const fk of foreignKeys) {
        if (fk.referencedTable === tableName) {
          return true;
        }
      }
    }
    
    return false;
  }

  private identifyEntityCategory(tableName: string, tableDefinition: SemanticTableDefinition): void {
    const entityPatterns = this.config.entityPatterns || [];
    let highestConfidence = 0;
    
    for (const pattern of entityPatterns) {
      const regex = new RegExp(pattern.pattern, 'i');
      if (regex.test(tableName)) {
        // Si la confiance est plus √©lev√©e, mettre √† jour la cat√©gorie
        if (pattern.confidence > highestConfidence) {
          tableDefinition.category = pattern.category;
          tableDefinition.role = pattern.role;
          tableDefinition.confidence = pattern.confidence;
          highestConfidence = pattern.confidence;
        }
      }
    }
    
    // Si aucune cat√©gorie n'est identifi√©e, essayer de d√©duire √† partir du nom
    if (!tableDefinition.category) {
      // Tables au singulier sont souvent des entit√©s principales
      if (!/s$/.test(tableName)) {
        tableDefinition.category = 'core';
        tableDefinition.role = 'Entit√© principale';
        tableDefinition.confidence = 0.6;
      } else {
        tableDefinition.category = 'collection';
        tableDefinition.role = 'Collection d\'entit√©s';
        tableDefinition.confidence = 0.5;
      }
    }
    
    // Ajouter la cat√©gorie comme tag
    if (tableDefinition.category && !tableDefinition.tags.includes(tableDefinition.category)) {
      tableDefinition.tags.push(tableDefinition.category.toLowerCase());
    }
  }

  private analyzeColumnContext(columnNames: string[], tableDefinition: SemanticTableDefinition): void {
    const domainKeywords = this.config.domainKeywords || {};
    const columnContextScore: {[domain: string]: number} = {};
    
    // Parcourir chaque colonne et v√©rifier les mots-cl√©s de domaine
    for (const column of columnNames) {
      for (const domain in domainKeywords) {
        const keywords = domainKeywords[domain];
        for (const keyword of keywords) {
          if (column.toLowerCase().includes(keyword.toLowerCase())) {
            if (!columnContextScore[domain]) {
              columnContextScore[domain] = 0;
            }
            columnContextScore[domain] += 1;
          }
        }
      }
    }
    
    // D√©terminer les domaines li√©s
    const relatedDomains: string[] = [];
    let totalScore = 0;
    
    for (const domain in columnContextScore) {
      totalScore += columnContextScore[domain];
      if (columnContextScore[domain] >= 2) {
        relatedDomains.push(domain);
      }
    }
    
    tableDefinition.metadata.contextScore = totalScore;
    tableDefinition.metadata.relatedDomains = relatedDomains;
    
    // Sugg√©rer un meilleur nom si applicable
    if (relatedDomains.length > 0 && tableDefinition.confidence < 0.7) {
      const mainDomain = relatedDomains[0];
      tableDefinition.metadata.suggestedName = `${mainDomain}_${tableDefinition.name}`;
    }
  }

  private identifyRelations(tableName: string, columnNames: string[], tableDefinition: SemanticTableDefinition): void {
    const relations: string[] = [];
    
    // Analyser les cl√©s √©trang√®res explicites
    const table = this.schemaData.tables[tableName];
    const foreignKeys = table.foreignKeys || [];
    
    for (const fk of foreignKeys) {
      if (fk.referencedTable) {
        relations.push(fk.referencedTable);
      }
    }
    
    // D√©duire les relations √† partir des noms de colonnes (convention _id)
    for (const column of columnNames) {
      if (column.endsWith('_id') && !column.startsWith('id_') && column !== 'id') {
        const possibleTableName = column.replace('_id', '');
        // V√©rifier si cette table existe
        if (this.schemaData.tables[possibleTableName]) {
          if (!relations.includes(possibleTableName)) {
            relations.push(possibleTableName);
          }
        }
        // Pour les cas de pluriel
        const singularTableName = possibleTableName.endsWith('s') 
          ? possibleTableName.slice(0, -1) 
          : possibleTableName;
        if (singularTableName !== possibleTableName && this.schemaData.tables[singularTableName]) {
          if (!relations.includes(singularTableName)) {
            relations.push(singularTableName);
          }
        }
      }
    }
    
    tableDefinition.relations = relations;
  }

  private generateTags(tableDefinition: SemanticTableDefinition, columnNames: string[]): void {
    // G√©n√©rer des tags en fonction des propri√©t√©s identifi√©es
    
    // Tag pour la taille de la table
    if (columnNames.length > 15) {
      tableDefinition.tags.push('grande-table');
    } else if (columnNames.length < 5) {
      tableDefinition.tags.push('petite-table');
    }
    
    // Tag pour les horodatages
    if (tableDefinition.metadata.hasTimestamps) {
      tableDefinition.tags.push('horodat√©e');
    }
    
    // Tag pour les relations
    if (tableDefinition.relations.length > 3) {
      tableDefinition.tags.push('tr√®s-connect√©e');
    } else if (tableDefinition.relations.length > 0) {
      tableDefinition.tags.push('connect√©e');
    }
    
    // Tag pour la cl√© primaire
    if (tableDefinition.metadata.hasPrimaryKey) {
      tableDefinition.tags.push('identifi√©e');
    } else {
      tableDefinition.tags.push('sans-identifiant');
    }
    
    // Tags bas√©s sur le r√¥le fonctionnel
    if (tableDefinition.isJunction) {
      tableDefinition.tags.push('relation-n-n');
    }
    
    // Tags bas√©s sur les domaines associ√©s
    tableDefinition.metadata.relatedDomains.forEach(domain => {
      tableDefinition.tags.push(`domaine-${domain.toLowerCase()}`);
    });
    
    // Tags bas√©s sur le contenu des colonnes
    const booleanColumns = columnNames.filter(col => 
      col.startsWith('is_') || col.startsWith('has_') || 
      col.startsWith('est_') || col.startsWith('a_')
    );
    
    if (booleanColumns.length > 2) {
      tableDefinition.tags.push('√©tats-multiples');
    }
    
    // D√©tecter les tables de configuration
    const configColumns = columnNames.filter(col => 
      col.includes('config') || col.includes('setting') || 
      col.includes('param') || col.includes('option')
    );
    
    if (configColumns.length > 1) {
      tableDefinition.tags.push('configuration');
    }
    
    // D√©tecter les tables d'historique
    const historyColumns = columnNames.filter(col => 
      col.includes('history') || col.includes('log') || 
      col.includes('historique') || col.includes('archive') ||
      col.includes('version') || col.includes('revision')
    );
    
    if (historyColumns.length > 0) {
      tableDefinition.tags.push('historique');
    }
    
    // D√©tecter les tables avec donn√©es g√©ographiques
    const geoColumns = columnNames.filter(col => 
      col.includes('lat') || col.includes('lon') || 
      col.includes('coord') || col.includes('geo') ||
      col.includes('pays') || col.includes('region') ||
      col.includes('ville') || col.includes('adresse')
    );
    
    if (geoColumns.length > 0) {
      tableDefinition.tags.push('g√©ographique');
    }
    
    // D√©tecter les tables avec donn√©es temporelles
    const temporalColumns = columnNames.filter(col => 
      col.includes('date') || col.includes('time') || 
      col.includes('duration') || col.includes('p√©riode') ||
      col.includes('ann√©e') || col.includes('mois') ||
      col.includes('jour') || col.includes('heure')
    );
    
    if (temporalColumns.length > 0) {
      tableDefinition.tags.push('temporelle');
    }
    
    // D√©tecter les tables avec donn√©es financi√®res
    const financialColumns = columnNames.filter(col => 
      col.includes('prix') || col.includes('montant') || 
      col.includes('co√ªt') || col.includes('tarif') ||
      col.includes('budget') || col.includes('finance') ||
      col.includes('payment') || col.includes('transaction')
    );
    
    if (financialColumns.length > 0) {
      tableDefinition.tags.push('financi√®re');
    }
    
    // √âliminer les doublons de tags
    tableDefinition.tags = [...new Set(tableDefinition.tags)];
  }

  public saveResults(results: SemanticMapResult): void {
    console.log('üíæ Enregistrement des r√©sultats de l\'analyse s√©mantique...');

    try {
      // Cr√©er le dossier de sortie s'il n'existe pas
      const outputDir = path.dirname(this.outputPath);
      if (!fs.existsSync(outputDir)) {
        fs.mkdirSync(outputDir, { recursive: true });
      }

      // Ajouter un timestamp au nom du fichier
      const timestamp = new Date().toISOString().replace(/:/g, '-').replace(/\./g, '-');
      const outputFile = this.outputPath.replace('.json', `-${timestamp}.json`);

      // √âcrire les r√©sultats au format JSON
      fs.writeFileSync(
        outputFile,
        JSON.stringify(results, null, 2),
        'utf8'
      );

      console.log(`‚úÖ R√©sultats enregistr√©s dans ${outputFile}`);

      // G√©n√©rer un rapport de synth√®se
      this.generateSummaryReport(results, outputDir, timestamp);
    } catch (error) {
      console.error(`‚ùå Erreur lors de l'enregistrement des r√©sultats: ${error}`);
      throw new Error('Impossible d\'enregistrer les r√©sultats');
    }
  }

  private generateSummaryReport(results: SemanticMapResult, outputDir: string, timestamp: string): void {
    const reportPath = path.join(outputDir, `rapport-tables-${timestamp}.md`);
    let reportContent = `# Rapport d'Analyse S√©mantique des Tables\n\n`;
    reportContent += `Date d'analyse: ${new Date().toLocaleDateString('fr-FR')}\n\n`;
    
    // Statistiques g√©n√©rales
    reportContent += `## Statistiques G√©n√©rales\n\n`;
    reportContent += `- Tables analys√©es: ${results.metadata.mappedTables}\n`;
    reportContent += `- Tables non cartographi√©es: ${results.metadata.unmappedTables}\n`;
    reportContent += `- Couverture de l'analyse: ${(results.metadata.analysisCoverage * 100).toFixed(2)}%\n`;
    reportContent += `- Relations identifi√©es: ${results.metadata.identifiedRelationships}\n\n`;
    
    // Groupes d'entit√©s
    reportContent += `## Groupes d'Entit√©s\n\n`;
    for (const category in results.entityGroups) {
      const tables = results.entityGroups[category];
      if (tables.length > 0) {
        reportContent += `### ${category} (${tables.length} tables)\n\n`;
        tables.forEach(table => {
          const tableDef = results.tableDefinitions[table];
          reportContent += `- ${table}: ${tableDef.role} (confiance: ${(tableDef.confidence * 100).toFixed(0)}%)\n`;
        });
        reportContent += `\n`;
      }
    }
    
    // Tables de jonction
    if (results.junctionTables.length > 0) {
      reportContent += `## Tables de Jonction (${results.junctionTables.length})\n\n`;
      results.junctionTables.forEach(table => {
        const tableDef = results.tableDefinitions[table];
        reportContent += `- ${table}: Relie ${tableDef.relations.join(' et ')}\n`;
      });
      reportContent += `\n`;
    }
    
    // Tables techniques
    reportContent += `## Tables Techniques\n\n`;
    for (const category in results.technicalTables) {
      const tables = results.technicalTables[category];
      if (tables.length > 0) {
        reportContent += `### ${category} (${tables.length} tables)\n\n`;
        tables.forEach(table => {
          reportContent += `- ${table}\n`;
        });
        reportContent += `\n`;
      }
    }
    
    // Tables orphelines
    if (results.orphanTables.length > 0) {
      reportContent += `## Tables Orphelines (${results.orphanTables.length})\n\n`;
      results.orphanTables.forEach(table => {
        reportContent += `- ${table}\n`;
      });
      reportContent += `\n`;
    }
    
    // √âcrire le rapport
    fs.writeFileSync(reportPath, reportContent, 'utf8');
    console.log(`üìã Rapport de synth√®se g√©n√©r√©: ${reportPath}`);
  }

  public async generateVisualization(results: SemanticMapResult): Promise<void> {
    console.log('üîç G√©n√©ration de visualisations des relations entre tables...');
    
    try {
      const outputDir = path.dirname(this.outputPath);
      const dotFilePath = path.join(outputDir, 'semantic-map.dot');
      
      // G√©n√©rer un fichier DOT pour Graphviz
      let dotContent = 'digraph SemanticMap {\n';
      dotContent += '  rankdir=LR;\n';
      dotContent += '  node [shape=box, style=filled, fontname="Arial"];\n';
      dotContent += '  edge [fontname="Arial", fontsize=10];\n\n';
      
      // D√©finir les n≈ìuds avec des couleurs par cat√©gorie
      for (const tableName in results.tableDefinitions) {
        const tableDef = results.tableDefinitions[tableName];
        let color = 'white';
        
        if (tableDef.isJunction) {
          color = 'gold';
        } else if (tableDef.isTechnical) {
          color = 'lightgrey';
        } else if (tableDef.isOrphan) {
          color = 'lightcoral';
        } else {
          // Couleurs par cat√©gorie d'entit√©
          switch (tableDef.category) {
            case 'core': color = 'lightblue'; break;
            case 'user': color = 'lightgreen'; break;
            case 'business': color = 'lightsalmon'; break;
            case 'content': color = 'plum'; break;
            case 'settings': color = 'lightcyan'; break;
            default: color = 'white';
          }
        }
        
        dotContent += `  "${tableName}" [label="${tableName}\\n(${tableDef.role})", fillcolor="${color}"];\n`;
      }
      
      dotContent += '\n';
      
      // D√©finir les ar√™tes pour repr√©senter les relations
      for (const tableName in results.entityRelationships) {
        const relations = results.entityRelationships[tableName];
        
        for (const relatedTable of relations) {
          dotContent += `  "${tableName}" -> "${relatedTable}";\n`;
        }
      }
      
      dotContent += '}\n';
      
      // √âcrire le fichier DOT
      fs.writeFileSync(dotFilePath, dotContent, 'utf8');
      console.log(`üìä Fichier de visualisation g√©n√©r√©: ${dotFilePath}`);
      
    } catch (error) {
      console.error(`‚ùå Erreur lors de la g√©n√©ration de visualisations: ${error}`);
    }
  }

  // G√©n√©ration du rapport Markdown
  public generateMarkdownReport(result: SemanticMapResult): string {
    let markdown = `# Rapport de Cartographie S√©mantique des Tables SQL\n\n`;
    markdown += `*Date de g√©n√©ration: ${new Date().toLocaleDateString()}*\n\n`;

    // R√©sum√© des cat√©gories
    markdown += `## üìä R√©sum√© des cat√©gories\n\n`;
    markdown += `| Cat√©gorie | Nombre de tables |\n`;
    markdown += `|-----------|------------------|\n`;
    
    let entityCount = 0;
    for (const category in result.entityGroups) {
      const count = result.entityGroups[category].length;
      entityCount += count;
      markdown += `| ${category} | ${count} |\n`;
    }
    
    let technicalCount = 0;
    for (const category in result.technicalTables) {
      const count = result.technicalTables[category].length;
      technicalCount += count;
    }
    
    markdown += `| JONCTION | ${result.junctionTables.length} |\n`;
    markdown += `| TECHNIQUE | ${technicalCount} |\n`;
    markdown += `| ORPHELINE | ${result.orphanTables.length} |\n`;
    markdown += `| **TOTAL** | **${result.metadata.mappedTables}** |\n\n`;

    // Graphique descriptif (ASCII)
    markdown += `## üìà Distribution des tables\n\n`;
    markdown += `\`\`\`\n`;
    markdown += `Entit√©s m√©tier  [${this.generateBarChart(entityCount, result.metadata.mappedTables)}] ${entityCount}\n`;
    markdown += `Tables jonction [${this.generateBarChart(result.junctionTables.length, result.metadata.mappedTables)}] ${result.junctionTables.length}\n`;
    markdown += `Tables tech.    [${this.generateBarChart(technicalCount, result.metadata.mappedTables)}] ${technicalCount}\n`;
    markdown += `Tables orphel.  [${this.generateBarChart(result.orphanTables.length, result.metadata.mappedTables)}] ${result.orphanTables.length}\n`;
    markdown += `\`\`\`\n\n`;

    // Tables par cat√©gorie
    markdown += `## üóÇÔ∏è Tables par cat√©gorie\n\n`;
    
    for (const category in result.entityGroups) {
      if (result.entityGroups[category].length > 0) {
        markdown += `### ${category} (${result.entityGroups[category].length})\n\n`;
        for (const tableName of result.entityGroups[category]) {
          const table = result.tableDefinitions[tableName];
          markdown += `- **${tableName}** `;
          if (table.tags.length > 0) {
            markdown += `[${table.tags.join(', ')}] `;
          }
          if (table.relations.length > 0) {
            markdown += `‚Üí Reli√© √†: ${table.relations.join(', ')}`;
          }
          markdown += `\n`;
        }
        markdown += `\n`;
      }
    }

    // Tables de jonction
    if (result.junctionTables.length > 0) {
      markdown += `### ‚ö° Tables de jonction (${result.junctionTables.length})\n\n`;
      for (const tableName of result.junctionTables) {
        const table = result.tableDefinitions[tableName];
        markdown += `- **${tableName}** ‚Üí Relie: ${table.relations.join(' et ')}\n`;
      }
      markdown += `\n`;
    }

    // Tables techniques
    let totalTechTables = 0;
    for (const category in result.technicalTables) {
      totalTechTables += result.technicalTables[category].length;
    }
    
    if (totalTechTables > 0) {
      markdown += `### üîß Tables techniques (${totalTechTables})\n\n`;
      for (const category in result.technicalTables) {
        if (result.technicalTables[category].length > 0) {
          markdown += `#### ${category} (${result.technicalTables[category].length})\n\n`;
          for (const tableName of result.technicalTables[category]) {
            markdown += `- **${tableName}**\n`;
          }
          markdown += `\n`;
        }
      }
    }

    // Tables orphelines
    if (result.orphanTables.length > 0) {
      markdown += `### ‚ö†Ô∏è Tables orphelines (${result.orphanTables.length})\n\n`;
      for (const tableName of result.orphanTables) {
        const table = result.tableDefinitions[tableName];
        markdown += `- **${tableName}**`;
        if (table.metadata.suggestedName) {
          markdown += ` ‚Üí Nom sugg√©r√©: \`${table.metadata.suggestedName}\``;
        }
        markdown += `\n`;
      }
      markdown += `\n`;
    }

    // Tables par domaine contextuel
    markdown += `## üåê Tables par domaine contextuel\n\n`;
    for (const domain in result.tablesByDomain) {
      markdown += `### ${domain} (${result.tablesByDomain[domain].length})\n\n`;
      for (const tableName of result.tablesByDomain[domain]) {
        markdown += `- **${tableName}**\n`;
      }
      markdown += `\n`;
    }

    // M√©tadonn√©es
    markdown += `## üìù M√©tadonn√©es d'analyse\n\n`;
    markdown += `- Tables analys√©es: ${result.metadata.mappedTables}\n`;
    markdown += `- Couverture: ${(result.metadata.analysisCoverage * 100).toFixed(1)}%\n`;
    markdown += `- Relations identifi√©es: ${result.metadata.identifiedRelationships}\n`;
    markdown += `- Date d'analyse: ${result.metadata.timestamp}\n`;

    return markdown;
  }

  private generateBarChart(value: number, total: number, width: number = 20): string {
    if (total === 0) return '';
    
    const filledChars = Math.round((value / total) * width);
    return '#'.repeat(filledChars) + ' '.repeat(Math.max(0, width - filledChars));
  }

  // Sauvegarde des r√©sultats
  public saveResults(result: SemanticMapResult): void {
    // Sauvegarder le fichier JSON
    const jsonOutputPath = path.join(this.outputPath, 'table_classification.json');
    fs.writeFileSync(jsonOutputPath, JSON.stringify(result, null, 2));
    console.log(`‚úÖ R√©sultats JSON sauvegard√©s dans: ${jsonOutputPath}`);

    // Sauvegarder le rapport Markdown
    const markdownReport = this.generateMarkdownReport(result);
    const mdOutputPath = path.join(this.outputPath, 'entity_graph.md');
    fs.writeFileSync(mdOutputPath, markdownReport);
    console.log(`‚úÖ Rapport Markdown sauvegard√© dans: ${mdOutputPath}`);
  }

  id: string = '';
  type: string = '';
  version: string = '1.0.0';

  /**
   * Initialise l'agent avec des options sp√©cifiques
   */
  async initialize(options?: Record<string, any>): Promise<void> {
    // √Ä impl√©menter selon les besoins sp√©cifiques de l'agent
    console.log(`[${this.name}] Initialisation...`);
  }

  /**
   * Indique si l'agent est pr√™t √† √™tre utilis√©
   */
  isReady(): boolean {
    return true;
  }

  /**
   * Arr√™te et nettoie l'agent
   */
  async shutdown(): Promise<void> {
    console.log(`[${this.name}] Arr√™t...`);
  }

  /**
   * R√©cup√®re les m√©tadonn√©es de l'agent
   */
  getMetadata(): Record<string, any> {
    return {
      id: this.id,
      name: this.name,
      type: this.type,
      version: this.version
    };
  }

  /**
   * R√©cup√®re l'√©tat actuel de l'agent business
   */
  async getState(): Promise<Record<string, any>> {
    return {
      status: 'active',
      timestamp: new Date().toISOString()
    };
  }
}

// Point d'entr√©e du script si ex√©cut√© directement
if (require.main === module) {
  if (process.argv.length < 5) {
    console.error('Usage: ts-node semantic-table-mapper.ts <schema-json-path> <config-path> <output-path>');
    process.exit(1);
  }
  
  const schemaFilePath = process.argv[2];
  const configPath = process.argv[3];
  const outputPath = process.argv[4];
  
  const mapper = new SemanticMapper(schemaFilePath, configPath, outputPath);
  
  mapper.analyze()
    .then(result => {
      mapper.saveResults(result);
      console.log('‚úÖ Analyse et g√©n√©ration des rapports termin√©es avec succ√®s');
    })
    .catch(error => {
      console.error(`‚ùå Erreur: ${error}`);
      process.exit(1);
    });
}