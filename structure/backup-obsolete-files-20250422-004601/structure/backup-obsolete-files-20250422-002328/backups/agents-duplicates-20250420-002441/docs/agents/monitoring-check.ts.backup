/**
 * monitoring-check.ts
 * Agent de surveillance post-migration
 * 
 * Cet agent v√©rifie la stabilit√© fonctionnelle, la performance et la coh√©rence visuelle
 * des routes migr√©es, apr√®s d√©ploiement (en preview ou en production).
 */

import * as fs from 'fs-extra';
import * as path from 'path';
import axios from 'axios';
import { execSync } from 'child_process';
import * as chalk from 'chalk';
import * as dotenv from 'dotenv';
import { program } from 'commander';

// Chargement des variables d'environnement
dotenv.config();

// Types
interface MonitoringConfig {
  baseUrl: string;
  routes: string[];
  oldRoutes?: { [key: string]: string };
  timeoutMs: number;
  expectedStatuses: { [key: string]: number };
  performanceThreshold: number;
  domElementsToCheck: string[];
  screenshotComparison: boolean;
  outputDir: string;
  slackWebhook?: string;
  n8nWebhook?: string;
}

interface RouteStatus {
  url: string;
  status: number;
  location?: string;
  valid: boolean;
  responseTime: number;
  error?: string;
}

interface PerformanceComparison {
  route: string;
  oldTime?: number;
  newTime: number;
  difference?: number;
  percentChange?: number;
  improvement: boolean;
}

interface DomIssue {
  route: string;
  issues: string[];
  severity: 'critical' | 'warning' | 'info';
}

interface MonitoringResult {
  timestamp: string;
  environment: string;
  baseUrl: string;
  summary: {
    totalRoutes: number;
    validStatusCodes: number;
    invalidStatusCodes: number;
    performanceImprovements: number;
    performanceRegressions: number;
    criticalDomIssues: number;
    warnings: number;
  };
  statusResults: RouteStatus[];
  performanceResults: PerformanceComparison[];
  domIssues: DomIssue[];
}

class MonitoringAgent implements BaseAgent, BusinessAgent {
  private config: MonitoringConfig;
  private results: MonitoringResult;
  private environment: string;
  private migrationData: any;

  constructor(environment: string, targetRoutes?: string[]) {
    this.environment = environment;

    // Configuration par d√©faut
    this.config = {
      baseUrl: '',
      routes: [],
      timeoutMs: 10000,
      expectedStatuses: {},
      performanceThreshold: 20, // pourcentage de diff√©rence tol√©r√©
      domElementsToCheck: ['title', 'meta[name="description"]', 'main', 'header', 'footer'],
      screenshotComparison: true,
      outputDir: path.join(process.cwd(), 'reports', 'monitoring')
    };

    // Initialisation des r√©sultats
    this.results = {
      timestamp: new Date().toISOString(),
      environment,
      baseUrl: '',
      summary: {
        totalRoutes: 0,
        validStatusCodes: 0,
        invalidStatusCodes: 0,
        performanceImprovements: 0,
        performanceRegressions: 0,
        criticalDomIssues: 0,
        warnings: 0
      },
      statusResults: [],
      performanceResults: [],
      domIssues: []
    };

    // Charger les donn√©es de migration
    this.loadMigrationData();

    // Configurer l'agent selon l'environnement
    this.configureForEnvironment(environment, targetRoutes);
  }

  /**
   * Charge les donn√©es de migration depuis les fichiers de r√©sultats
   */
  private loadMigrationData(): void {
    try {
      // Trouver le fichier de r√©sultats de migration le plus r√©cent
      const migrationResults = path.join(process.cwd(), 'migration-results-*.json');
      const latestMigrationFile = execSync(`ls -t ${migrationResults} | head -1`).toString().trim();

      if (fs.existsSync(latestMigrationFile)) {
        this.migrationData = fs.readJsonSync(latestMigrationFile);
        console.log(chalk.blue(`‚úì Donn√©es de migration charg√©es depuis: ${latestMigrationFile}`));
      } else {
        console.log(chalk.yellow('‚ö†Ô∏è Aucun fichier de r√©sultats de migration trouv√©'));
        this.migrationData = { routes: [], redirections: {} };
      }
    } catch (error) {
      console.error(chalk.red(`‚ùå Erreur lors du chargement des donn√©es de migration: ${error}`));
      this.migrationData = { routes: [], redirections: {} };
    }
  }

  /**
   * Configure l'agent selon l'environnement cible (preview ou production)
   */
  private configureForEnvironment(environment: string, targetRoutes?: string[]): void {
    // D√©terminer l'URL de base selon l'environnement
    if (environment === 'preview') {
      // Chercher l'URL de pr√©visualisation la plus r√©cente
      try {
        const previewDirs = fs.readdirSync(path.join(process.cwd(), '.preview'))
          .filter(dir => dir.startsWith('fiche-'))
          .sort()
          .reverse();
        
        if (previewDirs.length > 0) {
          const previewUrlPath = path.join(process.cwd(), '.preview', previewDirs[0], 'preview_url.txt');
          if (fs.existsSync(previewUrlPath)) {
            this.config.baseUrl = fs.readFileSync(previewUrlPath, 'utf8').trim();
          }
        }
        
        if (!this.config.baseUrl) {
          this.config.baseUrl = process.env.PREVIEW_URL || 'http://localhost:3000';
        }
      } catch (error) {
        console.error(chalk.red(`‚ùå Erreur lors de la recherche de l'URL de pr√©visualisation: ${error}`));
        this.config.baseUrl = process.env.PREVIEW_URL || 'http://localhost:3000';
      }
    } else if (environment === 'production') {
      this.config.baseUrl = process.env.PROD_URL || 'https://www.mysite.io';
    } else {
      this.config.baseUrl = environment; // Utiliser directement l'environnement comme URL
    }

    // Assigner l'URL de base aux r√©sultats
    this.results.baseUrl = this.config.baseUrl;
    console.log(chalk.blue(`üåê URL de base: ${this.config.baseUrl}`));

    // Routes √† surveiller
    if (targetRoutes && targetRoutes.length > 0) {
      this.config.routes = targetRoutes;
    } else if (this.migrationData && this.migrationData.routes) {
      // Utiliser les routes trouv√©es dans les donn√©es de migration
      this.config.routes = this.migrationData.routes.map((r: any) => r.newPath || r.path);
    } else {
      // Routes par d√©faut
      this.config.routes = ['/'];
    }

    // Mapper les anciennes routes vers les nouvelles (pour les redirections)
    this.config.oldRoutes = {};
    if (this.migrationData && this.migrationData.redirections) {
      this.config.oldRoutes = this.migrationData.redirections;
    }

    // Statuts HTTP attendus
    this.config.expectedStatuses = {};
    this.config.routes.forEach(route => {
      this.config.expectedStatuses[route] = 200; // Par d√©faut, on attend un 200 OK
    });
    
    // Pour les anciennes routes, on attend une redirection 301
    if (this.config.oldRoutes) {
      Object.keys(this.config.oldRoutes).forEach(oldRoute => {
        this.config.expectedStatuses[oldRoute] = 301;
      });
    }

    // Cr√©er le dossier de sortie si n√©cessaire
    fs.ensureDirSync(this.config.outputDir);
    console.log(chalk.blue(`‚úì Dossier de sortie cr√©√©: ${this.config.outputDir}`));
  }

  /**
   * V√©rifie les statuts HTTP pour toutes les routes
   */
  async checkHttpStatuses(): Promise<RouteStatus[]> {
    console.log(chalk.blue('üîç V√©rification des statuts HTTP...'));

    const allRoutes = [
      ...this.config.routes, 
      ...(this.config.oldRoutes ? Object.keys(this.config.oldRoutes) : [])
    ];

    const results: RouteStatus[] = [];

    for (const route of allRoutes) {
      try {
        const url = new URL(route, this.config.baseUrl).toString();
        const startTime = Date.now();
        
        console.log(chalk.blue(`  V√©rification de: ${url}`));
        
        const response = await axios.get(url, {
          maxRedirects: 0,
          validateStatus: () => true,
          timeout: this.config.timeoutMs
        });
        
        const endTime = Date.now();
        const responseTime = endTime - startTime;
        
        const expectedStatus = this.config.expectedStatuses[route] || 200;
        const valid = this.validateStatus(route, response.status, response.headers.location);
        
        const result: RouteStatus = {
          url: route,
          status: response.status,
          responseTime,
          valid
        };
        
        // Ajouter l'URL de redirection si c'est une redirection
        if (response.status >= 300 && response.status < 400 && response.headers.location) {
          result.location = response.headers.location;
        }
        
        if (!valid) {
          result.error = `Statut attendu: ${expectedStatus}, re√ßu: ${response.status}`;
        }
        
        results.push(result);
        
        if (valid) {
          console.log(chalk.green(`  ‚úì ${route} - ${response.status} (${responseTime}ms)`));
        } else {
          console.log(chalk.red(`  ‚ùå ${route} - ${response.status} (${responseTime}ms) - Attendu: ${expectedStatus}`));
        }
      } catch (error: any) {
        console.error(chalk.red(`  ‚ùå Erreur pour ${route}: ${error.message}`));
        
        results.push({
          url: route,
          status: 0,
          responseTime: 0,
          valid: false,
          error: `Erreur de connexion: ${error.message}`
        });
      }
    }

    // Mise √† jour des statistiques du r√©sum√©
    this.results.summary.totalRoutes = results.length;
    this.results.summary.validStatusCodes = results.filter(r => r.valid).length;
    this.results.summary.invalidStatusCodes = results.filter(r => !r.valid).length;
    this.results.statusResults = results;

    return results;
  }

  /**
   * Valide si le statut re√ßu correspond au statut attendu
   */
  private validateStatus(route: string, status: number, location?: string): boolean {
    const expectedStatus = this.config.expectedStatuses[route] || 200;
    
    // Cas d'une redirection 301
    if (expectedStatus === 301) {
      if (status !== 301) return false;
      
      // V√©rifier aussi que la redirection pointe vers la bonne URL
      if (this.config.oldRoutes && this.config.oldRoutes[route]) {
        const expectedLocation = this.config.oldRoutes[route];
        // V√©rification simplifi√©e: la redirection doit se terminer par le chemin attendu
        return location ? location.endsWith(expectedLocation) : false;
      }
      
      return true;
    }
    
    // Cas standard: le statut doit correspondre exactement
    return status === expectedStatus;
  }

  /**
   * Analyse les temps de r√©ponse et les compare avec les donn√©es historiques
   */
  async analyzeResponseTimes(): Promise<PerformanceComparison[]> {
    console.log(chalk.blue('‚è±Ô∏è Analyse des temps de r√©ponse...'));

    const results: PerformanceComparison[] = [];
    const historicalData = this.loadHistoricalPerformanceData();

    // Analyse uniquement pour les nouvelles routes (pas les redirections)
    for (const routeStatus of this.results.statusResults.filter(r => this.config.routes.includes(r.url))) {
      const route = routeStatus.url;
      const newTime = routeStatus.responseTime;
      
      const comparison: PerformanceComparison = {
        route,
        newTime,
        improvement: false
      };
      
      // Chercher les donn√©es historiques pour cette route
      const historicalEntry = historicalData[route];
      if (historicalEntry) {
        comparison.oldTime = historicalEntry.responseTime;
        comparison.difference = newTime - comparison.oldTime;
        comparison.percentChange = comparison.oldTime ? Math.round((comparison.difference / comparison.oldTime) * 100) : 0;
        comparison.improvement = comparison.difference < 0;
        
        const changeText = comparison.improvement 
          ? chalk.green(`${Math.abs(comparison.percentChange || 0)}% plus rapide`) 
          : chalk.yellow(`${comparison.percentChange || 0}% plus lent`);
        
        console.log(chalk.blue(`  ${route}: ${newTime}ms vs ${comparison.oldTime}ms (${changeText})`));
      } else {
        console.log(chalk.blue(`  ${route}: ${newTime}ms (pas de donn√©es historiques)`));
      }
      
      results.push(comparison);
    }

    // Mise √† jour des statistiques du r√©sum√©
    this.results.performanceResults = results;
    this.results.summary.performanceImprovements = results.filter(r => r.improvement).length;
    this.results.summary.performanceRegressions = results.filter(r => !r.improvement && r.percentChange !== undefined).length;

    // Enregistrer les nouvelles donn√©es de performance
    this.savePerformanceData();

    return results;
  }

  /**
   * Charge les donn√©es historiques de performance
   */
  private loadHistoricalPerformanceData(): { [route: string]: { responseTime: number, timestamp: string } } {
    const historyFile = path.join(this.config.outputDir, 'performance_history.json');
    
    if (fs.existsSync(historyFile)) {
      try {
        return fs.readJsonSync(historyFile);
      } catch (error) {
        console.error(chalk.red(`‚ùå Erreur lors du chargement des donn√©es historiques: ${error}`));
      }
    }
    
    return {};
  }

  /**
   * Enregistre les nouvelles donn√©es de performance
   */
  private savePerformanceData(): void {
    const historyFile = path.join(this.config.outputDir, 'performance_history.json');
    let history = this.loadHistoricalPerformanceData();
    
    // Ajouter les nouvelles donn√©es
    this.results.statusResults.forEach(status => {
      history[status.url] = {
        responseTime: status.responseTime,
        timestamp: this.results.timestamp
      };
    });
    
    // Sauvegarder
    fs.writeJsonSync(historyFile, history, { spaces: 2 });
  }

  /**
   * V√©rifie la structure DOM des pages
   */
  async inspectDomStructure(): Promise<DomIssue[]> {
    console.log(chalk.blue('üß¨ Inspection de la structure DOM...'));

    // V√©rifier si Playwright est install√©
    try {
      execSync('npx playwright --version', { stdio: 'ignore' });
    } catch (e) {
      console.log(chalk.yellow('‚ö†Ô∏è Playwright non install√©. Installation en cours...'));
      execSync('npx playwright install --with-deps chromium');
    }

    const issues: DomIssue[] = [];
    const snapshotsDir = path.join(this.config.outputDir, 'dom_snapshots');
    fs.ensureDirSync(snapshotsDir);

    // Cr√©er un script temporaire pour Playwright
    const playwrightScript = `
      const { chromium } = require('playwright');
      const fs = require('fs');
      const path = require('path');

      (async () => {
        const browser = await chromium.launch();
        const context = await browser.newContext();
        const baseUrl = process.argv[2];
        const routes = ${JSON.stringify(this.config.routes)};
        const elementsToCheck = ${JSON.stringify(this.config.domElementsToCheck)};
        const outputDir = process.argv[3];
        
        for (const route of routes) {
          try {
            const page = await context.newPage();
            const url = new URL(route, baseUrl).toString();
            
            console.log('Analyzing DOM:', url);
            await page.goto(url, { waitUntil: 'networkidle', timeout: 30000 });
            
            // Capturer une snapshot du DOM
            const domSnapshot = await page.evaluate(() => {
              // Fonction pour nettoyer le DOM (retirer les scripts, etc.)
              function cleanDom(node) {
                const clone = node.cloneNode(true);
                const scripts = clone.querySelectorAll('script, noscript, style');
                scripts.forEach(s => s.remove());
                return clone.outerHTML;
              }
              
              return cleanDom(document.documentElement);
            });
            
            // Sauvegarder la snapshot
            const safeRoute = route.replace(/\\//g, '_').replace(/^_/, '') || 'home';
            fs.writeFileSync(
              path.join(outputDir, \`dom_\${safeRoute}.html\`),
              domSnapshot
            );
            
            // V√©rifier les √©l√©ments critiques
            const missingElements = [];
            for (const selector of elementsToCheck) {
              const element = await page.$(selector);
              if (!element) {
                missingElements.push(selector);
              }
            }
            
            // V√©rifier les attributs ALT des images
            const imagesWithoutAlt = await page.$$eval('img:not([alt]), img[alt=""]', (imgs) => imgs.length);
            
            // V√©rifier les liens sans texte ou titre
            const emptyLinks = await page.$$eval('a:not(:has(*)):empty, a:not([title]):not(:has(*)):empty', (links) => links.length);
            
            // Sauvegarder les probl√®mes
            const issues = {
              route,
              missingElements,
              imagesWithoutAlt,
              emptyLinks,
              otherIssues: []
            };
            
            // V√©rifier la pr√©sence de H1
            const h1Count = await page.$$eval('h1', (h1s) => h1s.length);
            if (h1Count === 0) {
              issues.otherIssues.push('missing-h1');
            } else if (h1Count > 1) {
              issues.otherIssues.push('multiple-h1');
            }
            
            fs.writeFileSync(
              path.join(outputDir, \`issues_\${safeRoute}.json\`),
              JSON.stringify(issues, null, 2)
            );
            
            await page.close();
          } catch (error) {
            console.error(\`Error analyzing \${route}: \${error.message}\`);
            fs.writeFileSync(
              path.join(outputDir, \`error_\${route.replace(/\\//g, '_')}.txt\`),
              error.message
            );
          }
        }
        
        await browser.close();
      })();
    `;

    const scriptPath = path.join(this.config.outputDir, 'dom-inspect.js');
    fs.writeFileSync(scriptPath, playwrightScript);

    try {
      // Ex√©cuter Playwright
      execSync(`node ${scriptPath} ${this.config.baseUrl} ${snapshotsDir}`, { stdio: 'inherit' });
      
      // Analyser les r√©sultats
      const issueFiles = fs.readdirSync(snapshotsDir).filter(file => file.startsWith('issues_'));
      
      for (const file of issueFiles) {
        const filePath = path.join(snapshotsDir, file);
        const fileData = fs.readJsonSync(filePath);
        
        const routeIssues: string[] = [];
        let severity: 'critical' | 'warning' | 'info' = 'info';
        
        // Analyser les √©l√©ments manquants
        if (fileData.missingElements && fileData.missingElements.length > 0) {
          fileData.missingElements.forEach((element: string) => {
            routeIssues.push(`missing-element: ${element}`);
            if (element === 'title' || element === 'meta[name="description"]' || element === 'main') {
              severity = 'critical';
            } else {
              severity = 'warning';
            }
          });
        }
        
        // Ajouter les autres probl√®mes
        if (fileData.imagesWithoutAlt > 0) {
          routeIssues.push(`${fileData.imagesWithoutAlt} images sans attribut alt`);
          severity = severity === 'info' ? 'warning' : severity;
        }
        
        if (fileData.emptyLinks > 0) {
          routeIssues.push(`${fileData.emptyLinks} liens vides ou sans texte`);
          severity = severity === 'info' ? 'warning' : severity;
        }
        
        if (fileData.otherIssues && fileData.otherIssues.length > 0) {
          fileData.otherIssues.forEach((issue: string) => {
            routeIssues.push(issue);
            if (issue === 'missing-h1') {
              severity = 'warning';
            }
          });
        }
        
        if (routeIssues.length > 0) {
          issues.push({
            route: fileData.route,
            issues: routeIssues,
            severity
          });
          
          if (severity === 'critical') {
            console.log(chalk.red(`  ‚ùå ${fileData.route}: ${routeIssues.join(', ')}`));
          } else if (severity === 'warning') {
            console.log(chalk.yellow(`  ‚ö†Ô∏è ${fileData.route}: ${routeIssues.join(', ')}`));
          } else {
            console.log(chalk.blue(`  ‚ÑπÔ∏è ${fileData.route}: ${routeIssues.join(', ')}`));
          }
        } else {
          console.log(chalk.green(`  ‚úì ${fileData.route}: Aucun probl√®me DOM d√©tect√©`));
        }
      }
    } catch (error) {
      console.error(chalk.red(`‚ùå Erreur lors de l'analyse DOM: ${error}`));
    }

    // Mise √† jour des statistiques du r√©sum√©
    this.results.domIssues = issues;
    this.results.summary.criticalDomIssues = issues.filter(issue => issue.severity === 'critical').length;
    this.results.summary.warnings = issues.filter(issue => issue.severity === 'warning').length;

    return issues;
  }

  /**
   * Compare visuellement les pages avant/apr√®s migration (si des captures sont disponibles)
   */
  async compareScreenshots(): Promise<void> {
    // Impl√©mentation future pour la comparaison de captures d'√©cran
    // N√©cessiterait des captures d'√©cran "avant migration" pour comparaison
    console.log(chalk.blue('üñºÔ∏è La comparaison visuelle automatique n\'est pas impl√©ment√©e dans cette version'));
  }

  /**
   * G√©n√®re les rapports de sortie
   */
  async generateReports(): Promise<void> {
    console.log(chalk.blue('üìä G√©n√©ration des rapports...'));

    // Rapport JSON principal
    const monitorReportPath = path.join(this.config.outputDir, 'post_migration_monitor.json');
    fs.writeJsonSync(monitorReportPath, this.results, { spaces: 2 });
    console.log(chalk.green(`  ‚úì Rapport principal g√©n√©r√©: ${monitorReportPath}`));

    // Rapport d√©taill√© des statuts HTTP
    const statusReportPath = path.join(this.config.outputDir, 'route_statuses.json');
    fs.writeJsonSync(statusReportPath, this.results.statusResults, { spaces: 2 });
    console.log(chalk.green(`  ‚úì Rapport des statuts g√©n√©r√©: ${statusReportPath}`));

    // Rapport de comparaison des temps de r√©ponse
    const timingReportPath = path.join(this.config.outputDir, 'timing_comparison.md');
    let timingReport = `# Rapport de Performance - ${this.environment}\n\n`;
    timingReport += `Date: ${new Date().toLocaleString('fr-FR')}\n\n`;
    timingReport += `## Comparaison des temps de r√©ponse\n\n`;
    timingReport += `| Route | Temps actuel | Temps pr√©c√©dent | Diff√©rence | % Change |\n`;
    timingReport += `| --- | ---: | ---: | ---: | ---: |\n`;

    this.results.performanceResults.forEach(result => {
      const diff = result.difference !== undefined ? `${result.difference > 0 ? '+' : ''}${result.difference}ms` : '-';
      const percent = result.percentChange !== undefined ? `${result.percentChange > 0 ? '+' : ''}${result.percentChange}%` : '-';
      const oldTime = result.oldTime !== undefined ? `${result.oldTime}ms` : '-';
      
      timingReport += `| ${result.route} | ${result.newTime}ms | ${oldTime} | ${diff} | ${percent} |\n`;
    });

    fs.writeFileSync(timingReportPath, timingReport);
    console.log(chalk.green(`  ‚úì Rapport de performance g√©n√©r√©: ${timingReportPath}`));

    // Rapport des probl√®mes DOM
    const domReportPath = path.join(this.config.outputDir, 'dom_issues_report.md');
    let domReport = `# Rapport d'Analyse DOM - ${this.environment}\n\n`;
    domReport += `Date: ${new Date().toLocaleString('fr-FR')}\n\n`;
    domReport += `## Probl√®mes d√©tect√©s\n\n`;

    if (this.results.domIssues.length === 0) {
      domReport += `‚úÖ Aucun probl√®me DOM d√©tect√©.\n\n`;
    } else {
      this.results.domIssues.forEach(issue => {
        const severityIcon = issue.severity === 'critical' ? 'üî¥' : issue.severity === 'warning' ? 'üü†' : 'üîµ';
        domReport += `### ${severityIcon} ${issue.route}\n\n`;
        issue.issues.forEach(problem => {
          domReport += `- ${problem}\n`;
        });
        domReport += `\n`;
      });
    }

    fs.writeFileSync(domReportPath, domReport);
    console.log(chalk.green(`  ‚úì Rapport d'analyse DOM g√©n√©r√©: ${domReportPath}`));

    // Rapport de r√©sum√©
    const summaryReportPath = path.join(this.config.outputDir, 'monitoring_summary.md');
    let summaryReport = `# R√©sum√© de la Surveillance Post-Migration - ${this.environment}\n\n`;
    summaryReport += `Date: ${new Date().toLocaleString('fr-FR')}\n\n`;
    summaryReport += `Base URL: ${this.config.baseUrl}\n\n`;
    
    const statuses = this.results.summary;
    const totalIssues = statuses.invalidStatusCodes + statuses.performanceRegressions + statuses.criticalDomIssues;
    const statusIcon = totalIssues === 0 ? '‚úÖ' : totalIssues > 3 ? '‚ùå' : '‚ö†Ô∏è';
    
    summaryReport += `## Statut global: ${statusIcon}\n\n`;
    summaryReport += `- Routes test√©es: ${statuses.totalRoutes}\n`;
    summaryReport += `- Codes HTTP valides: ${statuses.validStatusCodes}/${statuses.totalRoutes}\n`;
    summaryReport += `- Am√©liorations de performance: ${statuses.performanceImprovements}\n`;
    summaryReport += `- R√©gressions de performance: ${statuses.performanceRegressions}\n`;
    summaryReport += `- Probl√®mes DOM critiques: ${statuses.criticalDomIssues}\n`;
    summaryReport += `- Avertissements: ${statuses.warnings}\n\n`;
    
    summaryReport += `## Liens vers les rapports d√©taill√©s\n\n`;
    summaryReport += `- [Statuts HTTP](./route_statuses.json)\n`;
    summaryReport += `- [Performances](./timing_comparison.md)\n`;
    summaryReport += `- [Analyse DOM](./dom_issues_report.md)\n`;

    fs.writeFileSync(summaryReportPath, summaryReport);
    console.log(chalk.green(`  ‚úì Rapport de r√©sum√© g√©n√©r√©: ${summaryReportPath}`));
  }

  /**
   * Envoie une notification si des probl√®mes sont d√©tect√©s
   */
  async sendNotifications(): Promise<void> {
    console.log(chalk.blue('üì£ Envoi des notifications...'));

    const statuses = this.results.summary;
    const totalIssues = statuses.invalidStatusCodes + statuses.performanceRegressions + statuses.criticalDomIssues;
    
    if (totalIssues === 0) {
      console.log(chalk.green('  ‚úì Aucun probl√®me d√©tect√©, pas de notification n√©cessaire'));
      return;
    }

    // Pr√©parer le message
    const message = {
      text: `üö® Surveillance post-migration: probl√®mes d√©tect√©s sur ${this.environment}`,
      blocks: [
        {
          type: "header",
          text: {
            type: "plain_text",
            text: `üö® Probl√®mes post-migration d√©tect√©s (${this.environment})`,
            emoji: true
          }
        },
        {
          type: "section",
          text: {
            type: "mrkdwn",
            text: `*Base URL:* ${this.config.baseUrl}\n*Date:* ${new Date().toLocaleString('fr-FR')}`
          }
        },
        {
          type: "section",
          fields: [
            {
              type: "mrkdwn",
              text: `*Routes test√©es:*\n${statuses.totalRoutes}`
            },
            {
              type: "mrkdwn",
              text: `*HTTP invalides:*\n${statuses.invalidStatusCodes}`
            },
            {
              type: "mrkdwn",
              text: `*R√©gressions perf:*\n${statuses.performanceRegressions}`
            },
            {
              type: "mrkdwn",
              text: `*Probl√®mes DOM:*\n${statuses.criticalDomIssues}`
            }
          ]
        }
      ]
    };

    // Envoyer √† Slack si configur√©
    if (this.config.slackWebhook) {
      try {
        await axios.post(this.config.slackWebhook, message);
        console.log(chalk.green('  ‚úì Notification Slack envoy√©e'));
      } catch (error) {
        console.error(chalk.red(`  ‚ùå Erreur lors de l'envoi de la notification Slack: ${error}`));
      }
    }

    // Envoyer √† n8n si configur√©
    if (this.config.n8nWebhook) {
      try {
        await axios.post(this.config.n8nWebhook, {
          monitoring: this.results,
          environment: this.environment,
          timestamp: new Date().toISOString()
        });
        console.log(chalk.green('  ‚úì Notification n8n envoy√©e'));
      } catch (error) {
        console.error(chalk.red(`  ‚ùå Erreur lors de l'envoi de la notification n8n: ${error}`));
      }
    }
  }

  /**
   * Ex√©cute toutes les √©tapes de surveillance
   */
  async run(): Promise<MonitoringResult> {
    console.log(chalk.blue(`üöÄ D√©marrage de la surveillance post-migration pour ${this.environment}`));

    try {
      // 1. V√©rifier les statuts HTTP
      await this.checkHttpStatuses();

      // 2. Analyser les temps de r√©ponse
      await this.analyzeResponseTimes();

      // 3. Inspecter la structure DOM
      await this.inspectDomStructure();

      // 4. Comparer visuellement (si activ√©)
      if (this.config.screenshotComparison) {
        await this.compareScreenshots();
      }

      // 5. G√©n√©rer les rapports
      await this.generateReports();

      // 6. Envoyer des notifications si des probl√®mes sont d√©tect√©s
      await this.sendNotifications();

      console.log(chalk.green(`‚úÖ Surveillance post-migration termin√©e`));
      return this.results;
    } catch (error) {
      console.error(chalk.red(`‚ùå Erreur lors de l'ex√©cution de la surveillance: ${error}`));
      throw error;
    }
  }
}

// Point d'entr√©e du script en ligne de commande
if (require.main === module) {
  program
    .name('monitoring-check')
    .description('Agent de surveillance post-migration')
    .option('-e, --env <environment>', 'Environnement cible (preview, production, ou URL personnalis√©e)', 'preview')
    .option('-t, --target <routes>', 'Routes sp√©cifiques √† surveiller (s√©par√©es par des virgules)')
    .option('-o, --output <dir>', 'Dossier de sortie des rapports')
    .parse(process.argv);

  const options = program.opts();
  const targetRoutes = options.target ? options.target.split(',').map((r: string) => r.trim()) : undefined;
  
  const agent = new MonitoringAgent(options.env, targetRoutes);
  
  if (options.output) {
    agent.config.outputDir = options.output;
  }
  
  agent.run()
    .then(() => {
      console.log(chalk.green('‚úÖ Monitoring termin√© avec succ√®s'));
      process.exit(0);
    })
    .catch(error => {
      console.error(chalk.red(`‚ùå Erreur: ${error.message}`));
      process.exit(1);
    });
}

// Export pour utilisation dans d'autres modules
export { MonitoringAgent, MonitoringResult };














import { BaseAgent } from '@workspaces/cahier-des-charge/src/core/interfaces/base-agent';
import { BusinessAgent } from '@workspaces/cahier-des-charge/src/core/interfaces/business';
























































































































































































































































































































































































































































































































































































































































































































































































































































