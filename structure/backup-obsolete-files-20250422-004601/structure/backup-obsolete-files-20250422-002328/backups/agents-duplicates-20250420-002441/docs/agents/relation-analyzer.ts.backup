/**
 * relation-analyzer.ts
 * Agent 3 ‚Äì Analyse Relationnelle & Coh√©rence R√©f√©rentielle
 * 
 * Assure l'int√©grit√© relationnelle de la future base PostgreSQL et identifie 
 * les relations manquantes, floues, cascades dangereuses, et traduit les 
 * polymorphismes SQL en mod√®les Prisma typ√©s.
 */

import * as fs from 'fs';
import * as path from 'path';
import { promisify } from 'util';

const readFile = promisify(fs.readFile);
const writeFile = promisify(fs.writeFile);
const mkdir = promisify(fs.mkdir);

// Types pour les structures de donn√©es
interface Table {
  name: string;
  columns: Column[];
  foreignKeys?: ForeignKey[];
  comment?: string;
  engine?: string;
}

interface Column {
  name: string;
  type: string;
  nullable: boolean;
  isPrimary?: boolean;
  default?: string | null;
  comment?: string;
}

interface ForeignKey {
  column: string;
  references: {
    table: string;
    column: string;
  };
  onDelete?: string;
  onUpdate?: string;
}

interface Relation {
  from_table: string;
  from_column: string;
  to_table: string;
  to_column: string;
  on_delete?: string;
  on_update?: string;
  confidence: number;
  is_polymorphic?: boolean;
  polymorphic_type_column?: string;
  warning?: string;
  prisma_relation: PrismaRelation;
}

interface PrismaRelation {
  relation_name: string;
  onDelete?: string;
  relation_type?: "one-to-one" | "one-to-many" | "many-to-one" | "many-to-many";
  optional?: boolean;
}

interface PolymorphicCandidate {
  table: string;
  id_column: string;
  type_column: string;
  references: string[];
  warning: string;
  suggestion: string;
}

interface NodeInGraph {
  id: string;
  label: string;
  type: "entity" | "junction" | "technical" | "polymorphic";
  relations_in: number;
  relations_out: number;
  centrality: number;
}

interface EdgeInGraph {
  source: string;
  target: string;
  label?: string;
  type: "direct" | "polymorphic" | "implicit";
  warning?: boolean;
}

interface RelationalGraph {
  nodes: NodeInGraph[];
  edges: EdgeInGraph[];
}

interface AnalysisConfig {
  baseOutputPath: string;
  agents: {
    analyseRelationnelle: {
      enabled: boolean;
      inputFiles: string[];
      outputFiles: string[];
      options: {
        detectImplicitJoins: boolean;
        detectPolymorphism: boolean;
        checkCascadeRisks: boolean;
        generateVisualization: boolean;
      };
    };
  };
}

class RelationAnalyzer implements BaseAgent, BusinessAgent, AnalyzerAgent {
  private config: AnalysisConfig;
  private tables: Table[] = [];
  private relations: Relation[] = [];
  private polymorphicCandidates: PolymorphicCandidate[] = [];
  private graph: RelationalGraph = { nodes: [], edges: [] };
  private logger: Console;

  constructor(configPath: string, private schemaPath: string, logger = console) {
    this.config = JSON.parse(fs.readFileSync(configPath, 'utf8'));
    this.logger = logger;
  }

  /**
   * Charge les donn√©es du sch√©ma
   */
  async loadSchema(): Promise<void> {
    try {
      const schemaContent = await readFile(this.schemaPath, 'utf8');
      const schema = JSON.parse(schemaContent);
      
      // Adaptez cette partie selon la structure r√©elle de votre schema_raw.json
      if (Array.isArray(schema.tables)) {
        this.tables = schema.tables;
      } else if (schema.tables) {
        // Si c'est un objet avec des noms de table comme cl√©s
        this.tables = Object.keys(schema.tables).map(tableName => {
          return {
            name: tableName,
            ...schema.tables[tableName]
          };
        });
      } else {
        throw new Error('Format du schema_raw.json non reconnu');
      }
      
      this.logger.info(`Charg√© ${this.tables.length} tables depuis le sch√©ma`);
    } catch (error) {
      this.logger.error(`Erreur lors du chargement du sch√©ma: ${error}`);
      throw error;
    }
  }

  /**
   * Ex√©cute l'analyse compl√®te
   */
  async analyze(): Promise<void> {
    await this.loadSchema();
    
    // √âtape 1: Extraire toutes les relations explicites (cl√©s √©trang√®res)
    this.extractExplicitRelations();
    
    // √âtape 2: D√©tecter les relations implicites
    if (this.config.agents.analyseRelationnelle.options.detectImplicitJoins) {
      this.detectImplicitRelations();
    }
    
    // √âtape 3: D√©tecter les polymorphismes
    if (this.config.agents.analyseRelationnelle.options.detectPolymorphism) {
      this.detectPolymorphism();
    }
    
    // √âtape 4: V√©rifier les risques de cascade
    if (this.config.agents.analyseRelationnelle.options.checkCascadeRisks) {
      this.checkCascadeRisks();
    }
    
    // √âtape 5: Construire le graphe relationnel
    this.buildRelationalGraph();
    
    // √âtape 6: Calculer les m√©triques de centralit√©
    this.calculateCentrality();
    
    // √âtape 7: G√©n√©rer les suggestions Prisma
    this.generatePrismaRecommendations();
    
    // √âtape 8: G√©n√©rer les fichiers de sortie
    await this.generateOutputFiles();
  }

  /**
   * Extrait les relations explicites √† partir des cl√©s √©trang√®res
   */
  private extractExplicitRelations(): void {
    for (const table of this.tables) {
      if (!table.foreignKeys || table.foreignKeys.length === 0) continue;
      
      for (const fk of table.foreignKeys) {
        // Trouver la table cible pour obtenir plus d'informations
        const targetTable = this.tables.find(t => t.name === fk.references.table);
        if (!targetTable) {
          this.logger.warn(`Table r√©f√©renc√©e ${fk.references.table} introuvable pour FK ${table.name}.${fk.column}`);
          continue;
        }
        
        // Cr√©er une relation
        const relation: Relation = {
          from_table: table.name,
          from_column: fk.column,
          to_table: fk.references.table,
          to_column: fk.references.column,
          on_delete: fk.onDelete || 'NO ACTION',
          on_update: fk.onUpdate || 'NO ACTION',
          confidence: 1.0, // Confiance maximale pour les relations explicites
          prisma_relation: {
            relation_name: this.suggestRelationName(table.name, fk.column),
            onDelete: this.mapOnDeleteToPrisma(fk.onDelete)
          }
        };
        
        this.relations.push(relation);
      }
    }
    
    this.logger.info(`Identifi√© ${this.relations.length} relations explicites`);
  }

  /**
   * D√©tecte les relations implicites bas√©es sur les conventions de nommage
   */
  private detectImplicitRelations(): void {
    const initialRelationCount = this.relations.length;
    
    // Rechercher des colonnes qui ressemblent √† des cl√©s √©trang√®res
    for (const table of this.tables) {
      for (const column of table.columns) {
        // Ignorer les colonnes d√©j√† impliqu√©es dans des FK explicites
        const isAlreadyFK = table.foreignKeys?.some(fk => fk.column === column.name);
        if (isAlreadyFK) continue;
        
        // V√©rifier si le nom de la colonne suit une convention _id ou se termine par Id
        if (column.name.endsWith('_id') || 
            column.name.endsWith('Id') || 
            column.name === 'parent_id' || 
            column.name === 'parentId') {
          
          // D√©duire le nom de la table potentiellement r√©f√©renc√©e
          let refTableName: string | null = null;
          
          if (column.name.endsWith('_id')) {
            refTableName = column.name.replace(/_id$/, '').toUpperCase();
          } else if (column.name.endsWith('Id')) {
            refTableName = column.name.replace(/Id$/, '').toUpperCase();
          } else if (column.name === 'parent_id' || column.name === 'parentId') {
            refTableName = table.name; // Potentiellement auto-r√©f√©rence
          }
          
          if (refTableName) {
            // Rechercher la table correspondante
            const targetTable = this.tables.find(t => 
              t.name.toUpperCase() === refTableName || 
              t.name.toUpperCase() === refTableName + 'S'
            );
            
            if (targetTable) {
              // Trouver la colonne id dans la table cible
              const targetIdColumn = targetTable.columns.find(c => 
                c.isPrimary || c.name === 'id' || c.name === 'ID'
              );
              
              if (targetIdColumn) {
                const relation: Relation = {
                  from_table: table.name,
                  from_column: column.name,
                  to_table: targetTable.name,
                  to_column: targetIdColumn.name,
                  confidence: 0.7, // Confiance r√©duite car implicite
                  warning: 'Relation implicite d√©tect√©e, non d√©fini√© comme FK dans le sch√©ma',
                  prisma_relation: {
                    relation_name: this.suggestRelationName(table.name, column.name),
                    onDelete: 'SetNull'
                  }
                };
                
                this.relations.push(relation);
              }
            }
          }
        }
      }
    }
    
    this.logger.info(`Identifi√© ${this.relations.length - initialRelationCount} relations implicites additionnelles`);
  }

  /**
   * D√©tecte les polymorphismes dans le sch√©ma
   */
  private detectPolymorphism(): void {
    // Chercher les paires de colonnes {entity_id, entity_type} typiques du polymorphisme
    for (const table of this.tables) {
      // Chercher des colonnes comme entity_id, parent_id, ref_id
      const idColumns = table.columns.filter(col => 
        col.name.endsWith('_id') && 
        !table.foreignKeys?.some(fk => fk.column === col.name)
      );
      
      for (const idColumn of idColumns) {
        // Chercher le type correspondant (entity_type, parent_type, etc.)
        const baseColumnName = idColumn.name.replace(/_id$/, '');
        const typeColumn = table.columns.find(col => 
          col.name === `${baseColumnName}_type` || 
          col.name === `${baseColumnName}Type`
        );
        
        if (typeColumn) {
          // Nous avons probablement trouv√© un polymorphisme!
          const polymorphicCandidate: PolymorphicCandidate = {
            table: table.name,
            id_column: idColumn.name,
            type_column: typeColumn.name,
            references: [], // Sera rempli plus tard si possible
            warning: 'Polymorphisme SQL d√©tect√© - difficile √† mod√©liser en Prisma',
            suggestion: 'Consid√©rer une restructuration en relations explicites par type'
          };
          
          // Ajouter aux candidats polymorphiques
          this.polymorphicCandidates.push(polymorphicCandidate);
          
          // Cr√©er des relations polymorphiques estim√©es
          // Nous faisons des suppositions bas√©es sur les conventions
          const possibleReferences = this.getPossiblePolymorphicReferences(baseColumnName);
          
          if (possibleReferences.length > 0) {
            polymorphicCandidate.references = possibleReferences.map(ref => ref.name);
            
            for (const refTable of possibleReferences) {
              // Trouver la colonne id dans la table de r√©f√©rence
              const refIdColumn = refTable.columns.find(c => c.isPrimary || c.name === 'id');
              
              if (refIdColumn) {
                const relation: Relation = {
                  from_table: table.name,
                  from_column: idColumn.name,
                  to_table: refTable.name,
                  to_column: refIdColumn.name,
                  confidence: 0.5, // Confiance basse pour le polymorphisme
                  is_polymorphic: true,
                  polymorphic_type_column: typeColumn.name,
                  warning: 'Relation polymorphique (via type_column) - limit√©e en Prisma',
                  prisma_relation: {
                    relation_name: `${this.suggestRelationName(table.name, idColumn.name)}On${refTable.name}`,
                    onDelete: 'SetNull',
                    optional: true
                  }
                };
                
                this.relations.push(relation);
              }
            }
          }
        }
      }
    }
    
    this.logger.info(`D√©tect√© ${this.polymorphicCandidates.length} candidats polymorphiques`);
  }

  /**
   * Trouve des tables qui pourraient √™tre r√©f√©renc√©es par un polymorphisme
   */
  private getPossiblePolymorphicReferences(baseColumnName: string): Table[] {
    // Si baseColumnName = "parent", chercher des tables qui pourraient √™tre "parentes"
    // Si baseColumnName est trop g√©n√©rique (entity, item), chercher toutes les tables principales
    
    if (baseColumnName === 'entity' || baseColumnName === 'item' || baseColumnName === 'ref') {
      // Retourner toutes les tables qui ont une structure d'entit√© m√©tier
      return this.tables.filter(table => {
        const hasIdColumn = table.columns.some(c => c.isPrimary || c.name === 'id');
        const hasForeignKeys = this.relations.some(r => r.to_table === table.name);
        
        return hasIdColumn && hasForeignKeys;
      });
    } else {
      // Chercher des tables sp√©cifiques qui correspondent au nom de base
      const singularName = baseColumnName.endsWith('s') 
        ? baseColumnName.substring(0, baseColumnName.length - 1) 
        : baseColumnName;
      
      return this.tables.filter(table => {
        const tableName = table.name.toLowerCase();
        const singularBaseName = singularName.toLowerCase();
        
        return tableName === singularBaseName || 
               tableName === singularBaseName + 's' ||
               tableName.includes(singularBaseName);
      });
    }
  }

  /**
   * V√©rifie les risques li√©s aux cascades de suppression
   */
  private checkCascadeRisks(): void {
    for (const relation of this.relations) {
      // V√©rifier les cascades √† risque
      if (relation.on_delete === 'CASCADE') {
        // Calculer le nombre de tables d√©pendantes
        const dependentTableCount = this.relations.filter(r => 
          r.to_table === relation.to_table
        ).length;
        
        // V√©rifier si cette table est centrale (beaucoup de d√©pendances)
        if (dependentTableCount > 3) {
          relation.warning = `‚ö†Ô∏è Cascade DELETE risqu√©e: ${relation.to_table} a ${dependentTableCount} tables d√©pendantes`;
        }
      }
      
      // V√©rifier les relations sans gestion explicite de suppression
      if (!relation.on_delete || relation.on_delete === 'NO ACTION' || relation.on_delete === 'RESTRICT') {
        // V√©rifier si la colonne source est NOT NULL
        const sourceTable = this.tables.find(t => t.name === relation.from_table);
        const sourceColumn = sourceTable?.columns.find(c => c.name === relation.from_column);
        
        if (sourceColumn && !sourceColumn.nullable) {
          relation.warning = `‚ö†Ô∏è FK ${relation.from_column} NOT NULL sans ON DELETE SET NULL/CASCADE`;
        }
      }
    }
  }

  /**
   * Construit le graphe relationnel
   */
  private buildRelationalGraph(): void {
    // Cr√©er les noeuds (tables)
    for (const table of this.tables) {
      // D√©terminer le type de la table
      let nodeType: NodeInGraph['type'] = 'entity';
      
      // V√©rifier si c'est une table de jonction (table de liaison)
      const isJunction = this.isJunctionTable(table);
      if (isJunction) {
        nodeType = 'junction';
      }
      
      // V√©rifier si c'est une table avec polymorphisme
      const isPolymorphic = this.polymorphicCandidates.some(pc => pc.table === table.name);
      if (isPolymorphic) {
        nodeType = 'polymorphic';
      }
      
      // Ajouter le noeud
      this.graph.nodes.push({
        id: table.name,
        label: table.name,
        type: nodeType,
        relations_in: 0,  // Sera calcul√© plus tard
        relations_out: 0, // Sera calcul√© plus tard
        centrality: 0     // Sera calcul√© plus tard
      });
    }
    
    // Cr√©er les ar√™tes (relations)
    for (const relation of this.relations) {
      const edgeType = relation.is_polymorphic 
        ? 'polymorphic' 
        : (relation.confidence < 0.8 ? 'implicit' : 'direct');
      
      const edge: EdgeInGraph = {
        source: relation.from_table,
        target: relation.to_table,
        label: `${relation.from_column} ‚Üí ${relation.to_column}`,
        type: edgeType,
        warning: !!relation.warning
      };
      
      this.graph.edges.push(edge);
      
      // Incr√©menter les compteurs de relations entrantes/sortantes
      const sourceNode = this.graph.nodes.find(n => n.id === relation.from_table);
      const targetNode = this.graph.nodes.find(n => n.id === relation.to_table);
      
      if (sourceNode) sourceNode.relations_out++;
      if (targetNode) targetNode.relations_in++;
    }
  }

  /**
   * V√©rifie si une table est une table de jonction
   */
  private isJunctionTable(table: Table): boolean {
    // Une table de jonction a typiquement 2+ FK et peu d'autres colonnes
    const fkCount = table.foreignKeys?.length || 0;
    if (fkCount < 2) return false;
    
    // Calculer le pourcentage de colonnes qui sont des FK
    const totalColumns = table.columns.length;
    const fkPercentage = fkCount / totalColumns;
    
    return fkPercentage > 0.5;
  }

  /**
   * Calcule la centralit√© des tables dans le graphe
   */
  private calculateCentrality(): void {
    // Calculer une forme simple de centralit√© bas√©e sur le nombre de d√©pendances
    for (const node of this.graph.nodes) {
      // Centralit√© = (relations entrantes + relations sortantes) / total des relations
      const totalRelations = this.graph.edges.length || 1; // √âviter division par z√©ro
      node.centrality = (node.relations_in + node.relations_out) / totalRelations;
    }
    
    // Trier les noeuds par centralit√© pour faciliter l'identification des tables centrales
    this.graph.nodes.sort((a, b) => b.centrality - a.centrality);
  }

  /**
   * G√©n√®re des recommandations Prisma pour chaque relation
   */
  private generatePrismaRecommendations(): void {
    for (const relation of this.relations) {
      // D√©terminer le type de relation
      const relationType = this.determinePrismaRelationType(relation);
      relation.prisma_relation.relation_type = relationType;
      
      // D√©terminer si la relation est optionnelle
      const fromTable = this.tables.find(t => t.name === relation.from_table);
      const fromColumn = fromTable?.columns.find(c => c.name === relation.from_column);
      relation.prisma_relation.optional = fromColumn?.nullable ?? true;
      
      // Mappages sp√©cifiques √† Prisma pour les contraintes d'int√©grit√©
      if (!relation.prisma_relation.onDelete) {
        relation.prisma_relation.onDelete = relation.prisma_relation.optional 
          ? 'SetNull' 
          : 'Cascade';
      }
    }
  }

  /**
   * D√©termine le type de relation Prisma
   */
  private determinePrismaRelationType(relation: Relation): PrismaRelation['relation_type'] {
    // V√©rifier si la table source pourrait √™tre une table de jonction
    const sourceTable = this.tables.find(t => t.name === relation.from_table);
    const isSourceJunction = sourceTable && this.isJunctionTable(sourceTable);
    
    // V√©rifier si la colonne cible est une cl√© primaire
    const targetTable = this.tables.find(t => t.name === relation.to_table);
    const targetColumn = targetTable?.columns.find(c => c.name === relation.to_column);
    const isTargetPrimaryKey = targetColumn?.isPrimary || targetColumn?.name === 'id';
    
    // V√©rifier si d'autres tables pointent vers la m√™me table cible
    const hasMultipleReferencesToTarget = this.relations.filter(r => 
      r.to_table === relation.to_table && 
      r.from_table !== relation.from_table
    ).length > 0;
    
    // R√®gles de d√©duction du type de relation
    if (isSourceJunction) {
      return 'many-to-many';
    } else if (isTargetPrimaryKey && hasMultipleReferencesToTarget) {
      return 'many-to-one';
    } else if (isTargetPrimaryKey) {
      // V√©rifier si la cl√© √©trang√®re est unique dans la table source
      const isSourceColumnUnique = sourceTable?.columns.find(c => 
        c.name === relation.from_column
      )?.isPrimary;
      
      return isSourceColumnUnique ? 'one-to-one' : 'many-to-one';
    } else {
      return 'one-to-many';
    }
  }

  /**
   * Sugg√®re un nom pour une relation Prisma
   */
  private suggestRelationName(tableName: string, columnName: string): string {
    // Enlever les suffixes communs
    let relationName = columnName
      .replace(/_id$/, '')
      .replace(/Id$/, '')
      .replace(/ID$/, '');
    
    // Si le nom est vide, utiliser le nom de la table cible
    if (!relationName) {
      const targetTableName = tableName.toLowerCase();
      relationName = targetTableName.endsWith('s') 
        ? targetTableName.substring(0, targetTableName.length - 1) 
        : targetTableName;
    }
    
    // Convertir en camelCase si n√©cessaire
    if (relationName.includes('_')) {
      relationName = relationName.split('_')
        .map((word, index) => 
          index === 0 
            ? word.toLowerCase() 
            : word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()
        )
        .join('');
    }
    
    return relationName;
  }

  /**
   * Mappe les valeurs MySQL ON DELETE vers la syntaxe Prisma
   */
  private mapOnDeleteToPrisma(onDelete?: string): string {
    if (!onDelete) return 'SetNull';
    
    switch (onDelete.toUpperCase()) {
      case 'CASCADE': return 'Cascade';
      case 'SET NULL': return 'SetNull';
      case 'RESTRICT': return 'Restrict';
      case 'NO ACTION': return 'NoAction';
      default: return 'SetNull';
    }
  }

  /**
   * G√©n√®re les fichiers de sortie
   */
  async generateOutputFiles(): Promise<void> {
    const { baseOutputPath } = this.config;
    const outputDir = baseOutputPath || './reports';
    
    // S'assurer que le r√©pertoire de sortie existe
    try {
      await mkdir(outputDir, { recursive: true });
    } catch (error) {
      // Ignorer l'erreur si le r√©pertoire existe d√©j√†
    }
    
    // G√©n√©rer relation_graph.json
    const relationGraphPath = path.join(outputDir, 'relation_graph.json');
    await writeFile(relationGraphPath, JSON.stringify(
      {
        relations: this.relations,
        graph: this.graph
      }, 
      null, 
      2
    ), 'utf8');
    this.logger.info(`Graphe relationnel √©crit dans ${relationGraphPath}`);
    
    // G√©n√©rer relation_audit.md
    const auditPath = path.join(outputDir, 'relation_audit.md');
    const auditContent = this.generateRelationAuditMarkdown();
    await writeFile(auditPath, auditContent, 'utf8');
    this.logger.info(`Audit relationnel √©crit dans ${auditPath}`);
    
    // G√©n√©rer optionnellement polymorphic_candidates.json
    if (this.polymorphicCandidates.length > 0) {
      const polymorphicPath = path.join(outputDir, 'polymorphic_candidates.json');
      await writeFile(polymorphicPath, JSON.stringify(this.polymorphicCandidates, null, 2), 'utf8');
      this.logger.info(`Candidats polymorphiques √©crits dans ${polymorphicPath}`);
    }
  }

  /**
   * G√©n√®re le rapport d'audit au format Markdown
   */
  private generateRelationAuditMarkdown(): string {
    let markdown = `# üîó Analyse Relationnelle & Coh√©rence R√©f√©rentielle\n\n`;
    
    // Statistiques g√©n√©rales
    markdown += `## üìä Statistiques\n\n`;
    markdown += `- Tables analys√©es: **${this.tables.length}**\n`;
    markdown += `- Relations d√©tect√©es: **${this.relations.length}**\n`;
    markdown += `- Relations explicites: **${this.relations.filter(r => r.confidence === 1.0).length}**\n`;
    markdown += `- Relations implicites: **${this.relations.filter(r => r.confidence < 1.0 && !r.is_polymorphic).length}**\n`;
    markdown += `- Relations polymorphiques: **${this.relations.filter(r => r.is_polymorphic).length}**\n`;
    markdown += `- Tables avec risques de cascade: **${this.relations.filter(r => r.warning && r.warning.includes('Cascade')).length}**\n\n`;
    
    // Tables centrales
    const centralTables = this.graph.nodes
      .filter(n => n.centrality > 0.1)
      .sort((a, b) => b.centrality - a.centrality)
      .slice(0, 5);
    
    if (centralTables.length > 0) {
      markdown += `## üåü Tables centrales\n\n`;
      for (const table of centralTables) {
        markdown += `- **${table.label}** - Score de centralit√©: ${table.centrality.toFixed(2)} (${table.relations_in} entrantes, ${table.relations_out} sortantes)\n`;
      }
      markdown += `\n`;
    }
    
    // Relations explicites
    markdown += `## üîê Relations explicites\n\n`;
    const explicitRelations = this.relations.filter(r => r.confidence === 1.0);
    
    for (const relation of explicitRelations) {
      markdown += `### ${relation.from_table} ‚Üí ${relation.to_table}\n\n`;
      markdown += `- Colonne: \`${relation.from_column}\` r√©f√©rence \`${relation.to_table}.${relation.to_column}\`\n`;
      
      if (relation.on_delete) {
        markdown += `- ON DELETE: \`${relation.on_delete}\`\n`;
      }
      
      if (relation.on_update) {
        markdown += `- ON UPDATE: \`${relation.on_update}\`\n`;
      }
      
      if (relation.warning) {
        markdown += `- ‚ö†Ô∏è **Avertissement**: ${relation.warning}\n`;
      }
      
      // Suggestion Prisma
      markdown += `- **Suggestion Prisma**:\n`;
      markdown += `  \`\`\`prisma\n`;
      markdown += `  ${relation.prisma_relation.relation_name}: ${relation.to_table} @relation(fields: [${relation.from_column}], references: [${relation.to_column}]`;
      
      if (relation.prisma_relation.onDelete) {
        markdown += `, onDelete: ${relation.prisma_relation.onDelete}`;
      }
      
      markdown += `)\n`;
      markdown += `  \`\`\`\n\n`;
    }
    
    // Relations implicites
    const implicitRelations = this.relations.filter(r => r.confidence < 1.0 && !r.is_polymorphic);
    if (implicitRelations.length > 0) {
      markdown += `## üîé Relations implicites d√©tect√©es\n\n`;
      markdown += `Ces relations ne sont pas d√©clar√©es explicitement comme cl√©s √©trang√®res mais semblent √™tre des relations bas√©es sur les conventions de nommage ou la structure.\n\n`;
      
      for (const relation of implicitRelations) {
        markdown += `### ${relation.from_table} ‚Üí ${relation.to_table} (confiance: ${relation.confidence.toFixed(2)})\n\n`;
        markdown += `- Colonne: \`${relation.from_column}\` semble r√©f√©rencer \`${relation.to_table}.${relation.to_column}\`\n`;
        
        if (relation.warning) {
          markdown += `- ‚ö†Ô∏è **Avertissement**: ${relation.warning}\n`;
        }
        
        // Suggestion d'am√©lioration
        markdown += `- **Suggestion**: Ajouter une contrainte de cl√© √©trang√®re pour renforcer l'int√©grit√© relationnelle\n`;
        markdown += `  \`\`\`sql\n`;
        markdown += `  ALTER TABLE ${relation.from_table} ADD CONSTRAINT fk_${relation.from_table.toLowerCase()}_${relation.from_column}\n`;
        markdown += `  FOREIGN KEY (${relation.from_column}) REFERENCES ${relation.to_table}(${relation.to_column});\n`;
        markdown += `  \`\`\`\n\n`;
        
        // Suggestion Prisma
        markdown += `- **Suggestion Prisma**:\n`;
        markdown += `  \`\`\`prisma\n`;
        markdown += `  ${relation.prisma_relation.relation_name}: ${relation.to_table} @relation(fields: [${relation.from_column}], references: [${relation.to_column}]`;
        
        if (relation.prisma_relation.onDelete) {
          markdown += `, onDelete: ${relation.prisma_relation.onDelete}`;
        }
        
        markdown += `)\n`;
        markdown += `  \`\`\`\n\n`;
      }
    }
    
    // Relations polymorphiques
    if (this.polymorphicCandidates.length > 0) {
      markdown += `## ‚ö†Ô∏è Relations polymorphiques\n\n`;
      markdown += `Les relations polymorphiques sont difficiles √† mod√©liser en Prisma. Voici les candidats d√©tect√©s et les suggestions de restructuration:\n\n`;
      
      for (const candidate of this.polymorphicCandidates) {
        markdown += `### Table ${candidate.table} - Polymorphisme via ${candidate.type_column}\n\n`;
        markdown += `- ID Column: \`${candidate.id_column}\`\n`;
        markdown += `- Type Column: \`${candidate.type_column}\`\n`;
        
        if (candidate.references.length > 0) {
          markdown += `- R√©f√©rences probables: ${candidate.references.join(', ')}\n`;
        }
        
        markdown += `- **Probl√®me**: ${candidate.warning}\n`;
        markdown += `- **Suggestion**: ${candidate.suggestion}\n\n`;
        
        // Exemple de restructuration
        markdown += `#### Option 1: Relations explicites s√©par√©es\n\n`;
        markdown += `\`\`\`prisma\n`;
        for (const refTable of candidate.references) {
          const camelCaseRefTable = refTable.charAt(0).toLowerCase() + refTable.slice(1);
          markdown += `${camelCaseRefTable}: ${refTable}? @relation(fields: [${camelCaseRefTable}Id], references: [id])\n`;
          markdown += `${camelCaseRefTable}Id: Int?\n`;
        }
        markdown += `\`\`\`\n\n`;
        
        markdown += `#### Option 2: Tables de relation s√©par√©es\n\n`;
        markdown += `Cr√©er des tables de jonction s√©par√©es pour chaque type de relation.\n\n`;
      }
    }
    
    // Risques de cascade
    const cascadeRisks = this.relations.filter(r => r.warning && r.warning.includes('Cascade'));
    if (cascadeRisks.length > 0) {
      markdown += `## üî• Risques de cascade\n\n`;
      
      for (const risk of cascadeRisks) {
        markdown += `### ${risk.from_table} ‚Üí ${risk.to_table}\n\n`;
        markdown += `- **Avertissement**: ${risk.warning}\n`;
        markdown += `- **Impact**: Supprimer des donn√©es de \`${risk.to_table}\` pourrait entra√Æner la suppression en cascade de donn√©es dans plusieurs tables d√©pendantes\n`;
        markdown += `- **Suggestion**: Consid√©rer SET NULL au lieu de CASCADE, ou mettre en place des sauvegardes avant suppression\n\n`;
      }
    }
    
    return markdown;
  }
}

/**
 * Point d'entr√©e pour l'ex√©cution √† partir de la ligne de commande
 */
async function main() {
  try {
    const args = process.argv.slice(2);
    const configPath = args.find(arg => arg.startsWith('--config='))?.split('=')[1] || './config/sql_analyzer.config.json';
    const schemaPath = args.find(arg => arg.startsWith('--schema='))?.split('=')[1] || './reports/schema_raw.json';
    
    console.log(`üîó D√©marrage de l'Analyse Relationnelle...`);
    console.log(`üìÅ Configuration: ${configPath}`);
    console.log(`üìÅ Sch√©ma: ${schemaPath}`);
    
    const analyzer = new RelationAnalyzer(configPath, schemaPath);
    await analyzer.analyze();
    
    console.log(`‚úÖ Analyse relationnelle termin√©e avec succ√®s`);
  } catch (error) {
    console.error(`‚ùå Erreur lors de l'analyse: ${error}`);
    process.exit(1);
  }
}

// Si ex√©cut√© directement (pas import√©)
if (require.main === module) {
  main();
}

export { RelationAnalyzer };











import { BaseAgent } from '@workspaces/cahier-des-charge/src/core/interfaces/base-agent';
import { BusinessAgent, AnalyzerAgent } from '@workspaces/cahier-des-charge/src/core/interfaces/business';
































































































































































































































































































































































































































































































































































































































































































































































































































































