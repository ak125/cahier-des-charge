#!/usr/bin/env node
/**
 * prisma-smart-generator.ts
 * 
 * Agent 6 - G√©n√©rateur Prisma Intelligent
 * 
 * G√©n√®re automatiquement un schema.prisma propre, lisible, modulaire, et compatible PostgreSQL
 * √† partir des sorties des agents pr√©c√©dents, tout en anticipant les erreurs classiques de migration depuis MySQL.
 * 
 * Usage: ts-node prisma-smart-generator.ts [options]
 * 
 * Options:
 *   --input-schema=<path>     Chemin vers le fichier de sch√©ma JSON analys√© (default: ./reports/schema_analysis.json)
 *   --type-mapping=<path>     Chemin vers le fichier de mapping des types MySQL -> PostgreSQL (default: ./config/type_mapping.json)
 *   --table-classification=<path> Chemin vers le fichier de classification des tables (default: ./config/table_classification.json)
 *   --output-dir=<path>       R√©pertoire de sortie (default: ./reports/latest)
 *   --multi-file              G√©n√®re des fichiers Prisma s√©par√©s par domaine fonctionnel
 *   --keep-snake-case         Conserve le snake_case pour les noms de champs (pas de conversion en camelCase)
 */

import * as fs from 'fs';
import * as path from 'path';
import { program } from 'commander';
import * as chalk from 'chalk';

// Types
interface MySQLSchema {
  tables: Record<string, TableInfo>;
  views: Record<string, ViewInfo>;
  procedures: Record<string, any>;
  functions: Record<string, any>;
  triggers: Record<string, any>;
  databaseInfo: any;
}

interface TableInfo {
  name: string;
  comment?: string;
  columns: Record<string, ColumnInfo>;
  primaryKey?: string[];
  indexes: IndexInfo[];
  foreignKeys: ForeignKeyInfo[];
  relations?: RelationInfo[];
  tableType?: 'TABLE' | 'VIEW' | 'JUNCTION' | 'TEMP';
}

interface ViewInfo {
  name: string;
  comment?: string;
  columns: Record<string, ColumnInfo>;
  definition: string;
}

interface ColumnInfo {
  name: string;
  position: number;
  type: string;
  originalType: string;
  suggestedPrismaType?: string;
  nullable: boolean;
  defaultValue?: any;
  comment?: string;
  primaryKey: boolean;
  unique: boolean;
  autoIncrement: boolean;
  isImplicitForeignKey?: boolean;
}

interface IndexInfo {
  name: string;
  columns: string[];
  unique: boolean;
}

interface ForeignKeyInfo {
  name: string;
  columns: string[];
  referencedTable: string;
  referencedColumns: string[];
  onUpdate: string;
  onDelete: string;
}

interface RelationInfo {
  type: RelationType;
  sourceTable: string;
  sourceColumn: string;
  targetTable: string;
  targetColumn: string;
}

enum RelationType {
  ONE_TO_ONE = 'ONE_TO_ONE',
  ONE_TO_MANY = 'ONE_TO_MANY',
  MANY_TO_ONE = 'MANY_TO_ONE',
  MANY_TO_MANY = 'MANY_TO_MANY'
}

interface TypeMapping {
  mysql: {
    [key: string]: {
      postgresql: string;
      prisma: string;
      jsType: string;
    }
  }
}

interface TableClassification {
  domains: {
    [key: string]: {
      description: string;
      tables: string[];
    }
  }
}

// Configuration de la ligne de commande
program
  .version('1.0.0')
  .description('G√©n√©rateur Prisma Intelligent')
  .option('--input-schema <path>', 'Chemin vers le fichier de sch√©ma JSON analys√©', './reports/schema_analysis.json')
  .option('--type-mapping <path>', 'Chemin vers le fichier de mapping des types MySQL -> PostgreSQL', './config/type_mapping.json')
  .option('--table-classification <path>', 'Chemin vers le fichier de classification des tables', './config/table_classification.json')
  .option('--output-dir <path>', 'R√©pertoire de sortie', './reports/latest')
  .option('--multi-file', 'G√©n√®re des fichiers Prisma s√©par√©s par domaine fonctionnel', false)
  .option('--keep-snake-case', 'Conserve le snake_case pour les noms de champs', false)
  .parse(process.argv);

const options = program.opts();

/**
 * Classe principale du g√©n√©rateur Prisma intelligent
 */
class PrismaSmartGenerator {
  private schema: MySQLSchema;
  private typeMapping: TypeMapping;
  private tableClassification: TableClassification;
  private warnings: string[] = [];
  private modelMappings: Record<string, { 
    mysqlTable: string, 
    prismaModel: string, 
    postgresTable: string 
  }> = {};
  private domainModels: Record<string, string[]> = {};

  constructor(
    schemaPath: string,
    typeMappingPath: string,
    tableClassificationPath: string,
    private keepSnakeCase: boolean
  ) {
    try {
      this.schema = JSON.parse(fs.readFileSync(schemaPath, 'utf8'));
      this.typeMapping = JSON.parse(fs.readFileSync(typeMappingPath, 'utf8'));
      this.tableClassification = JSON.parse(fs.readFileSync(tableClassificationPath, 'utf8'));
    } catch (error: any) {
      console.error(chalk.red(`Erreur lors du chargement des fichiers: ${error.message}`));
      if (error.code === 'ENOENT') {
        const missingFile = error.path;
        console.error(chalk.yellow(`Fichier non trouv√©: ${missingFile}`));
        
        if (missingFile.includes('type_mapping.json')) {
          this.typeMapping = this.createDefaultTypeMapping();
          console.log(chalk.yellow('Utilisation d\'un mapping de types par d√©faut'));
        } else if (missingFile.includes('table_classification.json')) {
          this.tableClassification = this.createDefaultTableClassification();
          console.log(chalk.yellow('Utilisation d\'une classification de tables par d√©faut'));
        } else {
          throw error;
        }
      } else {
        throw error;
      }
    }
  }

  /**
   * Cr√©e un mapping de types par d√©faut si le fichier n'existe pas
   */
  private createDefaultTypeMapping(): TypeMapping {
    return {
      mysql: {
        "INT": {
          postgresql: "INTEGER",
          prisma: "Int",
          jsType: "number"
        },
        "BIGINT": {
          postgresql: "BIGINT",
          prisma: "BigInt",
          jsType: "bigint"
        },
        "TINYINT(1)": {
          postgresql: "BOOLEAN",
          prisma: "Boolean",
          jsType: "boolean"
        },
        "VARCHAR": {
          postgresql: "VARCHAR",
          prisma: "String",
          jsType: "string"
        },
        "TEXT": {
          postgresql: "TEXT",
          prisma: "String",
          jsType: "string"
        },
        "TIMESTAMP": {
          postgresql: "TIMESTAMP",
          prisma: "DateTime",
          jsType: "Date"
        },
        "DATE": {
          postgresql: "DATE",
          prisma: "DateTime",
          jsType: "Date"
        },
        "DECIMAL": {
          postgresql: "DECIMAL",
          prisma: "Decimal",
          jsType: "Decimal"
        },
        "ENUM": {
          postgresql: "TEXT",
          prisma: "String",
          jsType: "string"
        },
        "JSON": {
          postgresql: "JSONB",
          prisma: "Json",
          jsType: "object"
        }
      }
    };
  }

  /**
   * Cr√©e une classification de tables par d√©faut si le fichier n'existe pas
   */
  private createDefaultTableClassification(): TableClassification {
    return {
      domains: {
        "user": {
          description: "Mod√®les li√©s aux utilisateurs et authentification",
          tables: []
        },
        "product": {
          description: "Mod√®les li√©s aux produits",
          tables: []
        },
        "order": {
          description: "Mod√®les li√©s aux commandes",
          tables: []
        },
        "content": {
          description: "Mod√®les li√©s au contenu",
          tables: []
        },
        "system": {
          description: "Mod√®les li√©s au syst√®me",
          tables: []
        }
      }
    };
  }

  /**
   * G√©n√®re tous les fichiers de sortie
   */
  async generate(outputDir: string, multiFile: boolean): Promise<void> {
    console.log(chalk.blue('üß¨ G√©n√©ration du sch√©ma Prisma...'));

    // Cr√©er le r√©pertoire de sortie s'il n'existe pas
    if (!fs.existsSync(outputDir)) {
      fs.mkdirSync(outputDir, { recursive: true });
    }

    // G√©n√©rer le sch√©ma Prisma
    const prismaSchema = this.generatePrismaSchema();

    // √âcrire le sch√©ma principal
    fs.writeFileSync(path.join(outputDir, 'suggested_schema.prisma'), prismaSchema);
    console.log(chalk.green('‚úÖ Sch√©ma Prisma g√©n√©r√©: suggested_schema.prisma'));

    // G√©n√©rer et √©crire les mod√®les par domaine si demand√©
    if (multiFile) {
      this.generateDomainSplitFiles(outputDir);
    }

    // G√©n√©rer et √©crire les fichiers additionnels
    this.generateMappingFile(outputDir);
    this.generateWarningsFile(outputDir);
    this.generateModuleSplitsFile(outputDir);

    console.log(chalk.green('‚úÖ G√©n√©ration termin√©e avec succ√®s!'));
  }

  /**
   * G√©n√®re le sch√©ma Prisma complet
   */
  private generatePrismaSchema(): string {
    // G√©n√©rer l'en-t√™te
    let prismaSchema = this.generateHeader();

    // Collecter tous les enums
    const enums = this.collectEnums();
    
    // G√©n√©rer les d√©finitions d'enum
    Object.entries(enums).forEach(([enumName, values]) => {
      prismaSchema += this.generateEnum(enumName, values);
    });

    // Classer les tables par domaine
    this.classifyTables();

    // G√©n√©rer les mod√®les pour chaque table
    Object.entries(this.schema.tables).forEach(([tableName, table]) => {
      const modelDefinition = this.generateModel(tableName, table);
      prismaSchema += modelDefinition;
    });

    // G√©n√©rer les mod√®les pour les vues (comment√©s)
    Object.entries(this.schema.views || {}).forEach(([viewName, view]) => {
      const viewModelDefinition = this.generateViewModel(viewName, view);
      prismaSchema += viewModelDefinition;
    });

    return prismaSchema;
  }

  /**
   * G√©n√®re l'en-t√™te du sch√©ma Prisma
   */
  private generateHeader(): string {
    return `// Sch√©ma Prisma g√©n√©r√© automatiquement par l'Agent 6 - G√©n√©rateur Prisma Intelligent
// Date de g√©n√©ration: ${new Date().toISOString()}
// Pour plus d'informations: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
  // Activer la pr√©visualisation des fonctionnalit√©s PostgreSQL avanc√©es
  previewFeatures = ["postgresqlExtensions", "relationJoins"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
  // Extensions PostgreSQL recommand√©es
  extensions = [citext, pg_trgm]
}

`;
  }

  /**
   * Collecte tous les enums √† d√©finir dans le sch√©ma Prisma
   */
  private collectEnums(): Record<string, string[]> {
    const enums: Record<string, string[]> = {};
    
    // Parcourir toutes les colonnes de type ENUM
    Object.entries(this.schema.tables).forEach(([tableName, table]) => {
      Object.entries(table.columns).forEach(([columnName, column]) => {
        if (column.type.toUpperCase() === 'ENUM') {
          // Extraire les valeurs d'enum
          const match = column.originalType.match(/ENUM\s*\(\s*(.+?)\s*\)/i);
          if (match) {
            const enumValues = match[1]
              .split(',')
              .map(value => value.trim().replace(/^['"]|['"]$/g, ''));
            
            // Cr√©er un nom d'enum bas√© sur la table et la colonne
            const enumName = `${this.toPascalCase(tableName)}${this.toPascalCase(columnName)}`;
            enums[enumName] = enumValues;
            
            // Mettre √† jour le type Prisma sugg√©r√© pour cette colonne
            if (this.schema.tables[tableName]?.columns[columnName]) {
              this.schema.tables[tableName].columns[columnName].suggestedPrismaType = enumName;
            }
          }
        }
      });
    });
    
    return enums;
  }

  /**
   * G√©n√®re une d√©finition d'enum Prisma
   */
  private generateEnum(enumName: string, values: string[]): string {
    let enumDefinition = `enum ${enumName} {\n`;
    
    values.forEach(value => {
      // Convertir la valeur en constante valide pour Prisma
      const safeValue = this.toSafeEnumValue(value);
      enumDefinition += `  ${safeValue}\n`;
    });
    
    enumDefinition += '}\n\n';
    return enumDefinition;
  }

  /**
   * Convertit une valeur d'enum en valeur s√©curis√©e pour Prisma
   */
  private toSafeEnumValue(value: string): string {
    // Remplacer les caract√®res non autoris√©s par des underscores
    let safeValue = value.replace(/[^a-zA-Z0-9_]/g, '_');
    
    // S'assurer que la valeur commence par une lettre
    if (!/^[a-zA-Z]/.test(safeValue)) {
      safeValue = 'E_' + safeValue;
    }
    
    // Si la valeur est vide apr√®s nettoyage, utiliser une valeur par d√©faut
    if (!safeValue) {
      safeValue = 'EMPTY';
    }
    
    return safeValue;
  }

  /**
   * Classe les tables par domaine fonctionnel
   */
  private classifyTables(): void {
    // Initialiser les domaines
    Object.keys(this.tableClassification.domains).forEach(domain => {
      this.domainModels[domain] = [];
    });

    // Classer les tables explicitement d√©finies
    Object.entries(this.tableClassification.domains).forEach(([domain, domainInfo]) => {
      domainInfo.tables.forEach(tableName => {
        if (this.schema.tables[tableName]) {
          this.domainModels[domain].push(this.toPascalCase(tableName));
        }
      });
    });

    // Tenter de classer automatiquement les tables non class√©es
    Object.keys(this.schema.tables).forEach(tableName => {
      const modelName = this.toPascalCase(tableName);
      
      // V√©rifier si cette table est d√©j√† class√©e
      const isClassified = Object.values(this.domainModels).some(models => 
        models.includes(modelName)
      );

      if (!isClassified) {
        // Essayer de deviner le domaine par le nom
        let assigned = false;
        
        // R√®gles de classification automatique
        if (tableName.match(/user|auth|permission|role|account|profile/i)) {
          this.domainModels['user'].push(modelName);
          assigned = true;
        } else if (tableName.match(/product|item|catalog|category|tag/i)) {
          this.domainModels['product'].push(modelName);
          assigned = true;
        } else if (tableName.match(/order|cart|checkout|payment|transaction|invoice/i)) {
          this.domainModels['order'].push(modelName);
          assigned = true;
        } else if (tableName.match(/post|article|comment|content|page|blog|media/i)) {
          this.domainModels['content'].push(modelName);
          assigned = true;
        } else if (tableName.match(/setting|config|log|stat|history|audit|system|temp|migration/i)) {
          this.domainModels['system'].push(modelName);
          assigned = true;
        }

        // Si non class√©, mettre dans "system" par d√©faut
        if (!assigned) {
          this.domainModels['system'].push(modelName);
        }
      }
    });
  }

  /**
   * G√©n√®re un mod√®le Prisma pour une table
   */
  private generateModel(tableName: string, table: TableInfo): string {
    // Convertir le nom de la table en PascalCase pour le mod√®le Prisma
    const modelName = this.toPascalCase(tableName);
    
    // Stocker le mapping pour r√©f√©rence future
    this.modelMappings[modelName] = {
      mysqlTable: tableName,
      prismaModel: modelName,
      postgresTable: tableName
    };
    
    // D√©terminer le domaine pour les commentaires
    const domain = this.findDomainForModel(modelName);
    
    let modelDefinition = `// Domaine: ${domain}\n`;
    
    // Ajouter un commentaire si disponible
    if (table.comment) {
      modelDefinition += `/// ${table.comment}\n`;
    }
    
    modelDefinition += `model ${modelName} {\n`;
    
    // G√©n√©rer les champs du mod√®le
    Object.entries(table.columns).forEach(([columnName, column]) => {
      const field = this.generateField(columnName, column, table);
      modelDefinition += `  ${field}\n`;
    });
    
    // Ajouter les relations invers√©es manquantes
    const inverseRelations = this.generateInverseRelations(tableName, table);
    if (inverseRelations.length > 0) {
      modelDefinition += '\n  // Relations invers√©es\n';
      inverseRelations.forEach(relation => {
        modelDefinition += `  ${relation}\n`;
      });
    }
    
    // Ajouter les index
    const indexes = this.generateIndexes(table);
    if (indexes.length > 0) {
      modelDefinition += '\n  // Index et contraintes\n';
      indexes.forEach(index => {
        modelDefinition += `  ${index}\n`;
      });
    }
    
    // Ajouter la directive de mapping pour la table
    modelDefinition += `\n  @@map("${tableName}")\n`;
    
    modelDefinition += '}\n\n';
    return modelDefinition;
  }

  /**
   * G√©n√®re un mod√®le Prisma pour une vue (comment√©)
   */
  private generateViewModel(viewName: string, view: ViewInfo): string {
    // Convertir le nom de la vue en PascalCase
    const modelName = this.toPascalCase(viewName);
    
    let modelDefinition = `// Mod√®le de Vue (d√©sactiv√© par d√©faut)
// Pour activer, retirez les commentaires et utilisez l'option "relationMode = 'prisma'" dans le bloc generator
// model ${modelName} {\n`;
    
    // G√©n√©rer les champs de la vue
    Object.entries(view.columns).forEach(([columnName, column]) => {
      // Pour les vues, tous les champs sont en lecture seule
      const fieldType = column.suggestedPrismaType || this.getPrismaType(column);
      const fieldName = this.keepSnakeCase ? columnName : this.toCamelCase(columnName);
      const nullable = column.nullable ? '?' : '';
      
      modelDefinition += `//   ${fieldName} ${fieldType}${nullable}\n`;
    });
    
    modelDefinition += `//   @@map("${viewName}")\n`;
    modelDefinition += `//   @@schema("public") // Ajustez si la vue est dans un sch√©ma sp√©cifique\n`;
    modelDefinition += `// }\n\n`;
    
    return modelDefinition;
  }

  /**
   * G√©n√®re un champ Prisma pour une colonne
   */
  private generateField(columnName: string, column: ColumnInfo, table: TableInfo): string {
    // Convertir le nom de la colonne en camelCase pour Prisma (ou conserver snake_case si demand√©)
    const fieldName = this.keepSnakeCase ? columnName : this.toCamelCase(columnName);
    
    // D√©terminer le type Prisma √† utiliser
    let fieldType = column.suggestedPrismaType || this.getPrismaType(column);
    
    // D√©terminer si c'est une cl√© √©trang√®re et g√©rer la relation
    const { isForeignKey, relationInfo } = this.detectForeignKey(columnName, table);
    
    // Si c'est une cl√© √©trang√®re, ajuster le type et pr√©parer la relation
    let relation = '';
    if (isForeignKey && relationInfo) {
      const targetModelName = this.toPascalCase(relationInfo.targetTable);
      
      fieldType = targetModelName;
      relation = `@relation(fields: [${fieldName}Id], references: [id])`;
      
      // Ajouter le champ de l'ID de la cl√© √©trang√®re
      const foreignKeyField = `${fieldName}Id ${this.getForeignKeyType(relationInfo.targetTable, relationInfo.targetColumn)}`;
      const foreignKeyMap = fieldName !== columnName ? ` @map("${columnName}")` : '';
      
      return `${fieldName} ${fieldType}${column.nullable ? '?' : ''} ${relation}\n  ${foreignKeyField}${foreignKeyMap}`;
    }
    
    // Si c'est une cl√© primaire, ajouter @id
    let attributes = '';
    if (column.primaryKey) {
      attributes += ' @id';
      
      // Si c'est auto-increment, ajouter @default(autoincrement())
      if (column.autoIncrement) {
        attributes += ' @default(autoincrement())';
      }
    }
    
    // Si c'est unique, ajouter @unique
    if (column.unique && !column.primaryKey) {
      attributes += ' @unique';
    }
    
    // Si c'est nullable, ajouter un point d'interrogation au type
    const nullable = column.nullable ? '?' : '';
    
    // Si une valeur par d√©faut est sp√©cifi√©e
    if (column.defaultValue !== undefined && column.defaultValue !== null && !column.autoIncrement) {
      attributes += this.generateDefaultValue(column);
    }
    
    // Ajouter le type PostgreSQL appropri√© avec @db
    const dbType = this.getPostgreSQLType(column);
    if (dbType) {
      attributes += ` @db.${dbType}`;
    }
    
    // Ajouter la directive de mapping pour la colonne si le nom est diff√©rent
    if (fieldName !== columnName && !isForeignKey) {
      attributes += ` @map("${columnName}")`;
    }
    
    // Ajouter un commentaire si pr√©sent
    let comment = '';
    if (column.comment) {
      comment = ` /// ${column.comment}`;
    }
    
    return `${fieldName} ${fieldType}${nullable}${attributes}${comment}`;
  }

  /**
   * D√©tecte si une colonne est une cl√© √©trang√®re (explicite ou implicite)
   */
  private detectForeignKey(columnName: string, table: TableInfo): { 
    isForeignKey: boolean; 
    relationInfo?: { 
      type: RelationType; 
      targetTable: string; 
      targetColumn: string; 
    } 
  } {
    // V√©rifier les cl√©s √©trang√®res explicites
    const explicitFK = table.foreignKeys?.find(fk => 
      fk.columns.includes(columnName)
    );
    
    if (explicitFK) {
      return {
        isForeignKey: true,
        relationInfo: {
          type: RelationType.MANY_TO_ONE,
          targetTable: explicitFK.referencedTable,
          targetColumn: explicitFK.referencedColumns[explicitFK.columns.indexOf(columnName)]
        }
      };
    }
    
    // V√©rifier les cl√©s √©trang√®res implicites (nom se terminant par _id)
    if (columnName.endsWith('_id')) {
      const possibleTargetTable = columnName.slice(0, -3); // Supprimer le suffixe "_id"
      
      // V√©rifier si une table avec ce nom existe
      if (this.schema.tables[possibleTargetTable]) {
        // V√©rifier si la table cible a une colonne "id"
        const targetTable = this.schema.tables[possibleTargetTable];
        const idColumn = Object.entries(targetTable.columns).find(([_, col]) => col.primaryKey);
        
        if (idColumn) {
          return {
            isForeignKey: true,
            relationInfo: {
              type: RelationType.MANY_TO_ONE,
              targetTable: possibleTargetTable,
              targetColumn: idColumn[0]
            }
          };
        }
      }
    }
    
    return { isForeignKey: false };
  }

  /**
   * G√©n√®re les relations invers√©es manquantes
   */
  private generateInverseRelations(tableName: string, table: TableInfo): string[] {
    const inverseRelations: string[] = [];
    
    // Pour chaque cl√© √©trang√®re qui r√©f√©rence cette table
    Object.entries(this.schema.tables).forEach(([sourceTableName, sourceTable]) => {
      if (sourceTableName === tableName) return; // Ignorer la m√™me table
      
      // V√©rifier les cl√©s √©trang√®res explicites
      sourceTable.foreignKeys?.forEach(fk => {
        if (fk.referencedTable === tableName) {
          // C'est une relation inverse - cette table est r√©f√©renc√©e par une autre
          const sourceModelName = this.toPascalCase(sourceTableName);
          const relationFieldName = this.pluralize(this.keepSnakeCase ? sourceTableName : this.toCamelCase(sourceTableName));
          
          // √âviter les doublons de noms de champs
          if (Object.keys(table.columns).some(col => 
            (this.keepSnakeCase ? col : this.toCamelCase(col)) === relationFieldName
          )) {
            this.warnings.push(`Conflit de nom pour la relation inverse ${tableName} -> ${sourceTableName}: ${relationFieldName} existe d√©j√† comme champ`);
            return;
          }
          
          inverseRelations.push(`${relationFieldName} ${sourceModelName}[] @relation("${sourceTableName}_${fk.name}")`);
        }
      });
      
      // V√©rifier les cl√©s √©trang√®res implicites
      Object.entries(sourceTable.columns).forEach(([columnName, column]) => {
        if (columnName.endsWith('_id') && columnName.slice(0, -3) === tableName) {
          // C'est une relation inverse implicite
          const sourceModelName = this.toPascalCase(sourceTableName);
          const relationFieldName = this.pluralize(this.keepSnakeCase ? sourceTableName : this.toCamelCase(sourceTableName));
          
          // √âviter les doublons
          if (Object.keys(table.columns).some(col => 
            (this.keepSnakeCase ? col : this.toCamelCase(col)) === relationFieldName
          )) {
            return;
          }
          
          // √âviter les doublons avec les relations explicites
          if (inverseRelations.some(r => r.startsWith(relationFieldName))) {
            return;
          }
          
          inverseRelations.push(`${relationFieldName} ${sourceModelName}[] @relation("${sourceTableName}_${columnName}")`);
        }
      });
    });
    
    return inverseRelations;
  }

  /**
   * G√©n√®re les directives d'index pour une table
   */
  private generateIndexes(table: TableInfo): string[] {
    const indexes: string[] = [];
    
    table.indexes?.forEach(index => {
      // Ignorer l'index de cl√© primaire (d√©j√† g√©r√© via @id)
      if (index.name === 'PRIMARY' || index.columns.every(col => {
        const column = table.columns[col];
        return column && column.primaryKey;
      })) {
        return;
      }
      
      // Transformer les noms de colonnes en camelCase si n√©cessaire
      const columnNames = index.columns.map(col => 
        this.keepSnakeCase ? col : this.toCamelCase(col)
      );
      
      const indexFields = columnNames.map(col => col).join(', ');
      
      if (index.unique) {
        if (columnNames.length === 1) {
          // D√©j√† g√©r√© dans generateField avec @unique
          return;
        }
        indexes.push(`@@unique([${indexFields}], name: "${index.name}")`);
      } else {
        indexes.push(`@@index([${indexFields}], name: "${index.name}")`);
      }
    });
    
    return indexes;
  }

  /**
   * G√©n√®re une directive @default pour une colonne
   */
  private generateDefaultValue(column: ColumnInfo): string {
    const defaultValue = column.defaultValue;
    
    if (defaultValue === null || defaultValue === undefined) {
      return '';
    }
    
    // Pour les timestamps automatiques
    if (defaultValue === 'CURRENT_TIMESTAMP' || defaultValue === 'NOW()') {
      return ' @default(now())';
    }
    
    // Pour les UUIDs
    if (defaultValue === 'UUID()' || defaultValue === 'uuid_generate_v4()') {
      return ' @default(uuid())';
    }
    
    // Pour les types num√©riques
    if (['Int', 'Float', 'Decimal', 'BigInt'].includes(column.suggestedPrismaType || '')) {
      // Valeurs sp√©ciales
      if (defaultValue === '0' || defaultValue === 0) {
        return ' @default(0)';
      }
      return ` @default(${defaultValue})`;
    }
    
    // Pour les types bool√©ens
    if (column.suggestedPrismaType === 'Boolean') {
      const boolValue = defaultValue === '1' || defaultValue.toLowerCase() === 'true';
      return ` @default(${boolValue})`;
    }
    
    // Pour les strings
    if (column.suggestedPrismaType === 'String') {
      return ` @default("${defaultValue.replace(/"/g, '\\"')}")`;
    }
    
    // Pour les autres types, entourer de guillemets
    return ` @default("${defaultValue}")`;
  }

  /**
   * Obtient le type Prisma pour une colonne
   */
  private getPrismaType(column: ColumnInfo): string {
    // Rechercher dans le mapping des types
    const baseType = column.type.toUpperCase().replace(/\(.+\)/, '').trim();
    
    // Cas sp√©cial pour TINYINT(1) qui est g√©n√©ralement un bool√©en
    if (column.originalType.toUpperCase() === 'TINYINT(1)') {
      return 'Boolean';
    }
    
    const mappedType = Object.entries(this.typeMapping.mysql).find(([mysqlType, _]) => {
      return mysqlType === baseType || baseType.startsWith(mysqlType);
    });
    
    if (mappedType) {
      return mappedType[1].prisma;
    }
    
    // Type par d√©faut si non trouv√©
    this.warnings.push(`Type non mapp√©: ${column.originalType} -> utilisation de String par d√©faut`);
    return 'String';
  }

  /**
   * Obtient le type PostgreSQL pour une colonne
   */
  private getPostgreSQLType(column: ColumnInfo): string {
    const baseType = column.type.toUpperCase().replace(/\(.+\)/, '').trim();
    
    // Extraire les param√®tres (taille, pr√©cision, etc.)
    const match = column.originalType.match(/\((.+?)\)/);
    const params = match ? match[1] : '';
    
    switch (baseType) {
      case 'VARCHAR':
      case 'CHAR':
        return `VarChar(${params || '255'})`;
      case 'TEXT':
        return 'Text';
      case 'INT':
      case 'INTEGER':
        return 'Integer';
      case 'BIGINT':
        return 'BigInt';
      case 'DECIMAL':
      case 'NUMERIC':
        return `Decimal(${params || '10,2'})`;
      case 'FLOAT':
      case 'DOUBLE':
        return 'DoublePrecision';
      case 'BOOLEAN':
      case 'TINYINT': // TINYINT(1) en MySQL est souvent utilis√© comme bool√©en
        if (column.originalType.toUpperCase() === 'TINYINT(1)') {
          return 'Boolean';
        }
        return 'SmallInt';
      case 'DATE':
        return 'Date';
      case 'TIMESTAMP':
      case 'DATETIME':
        return 'Timestamp(6)';
      case 'JSON':
      case 'JSONB':
        return 'JsonB';
      case 'ENUM':
        // Les ENUM MySQL sont g√©n√©ralement convertis en type TEXT dans PostgreSQL
        return 'Text';
      default:
        return '';
    }
  }

  /**
   * Obtient le type pour une cl√© √©trang√®re
   */
  private getForeignKeyType(targetTable: string, targetColumn: string): string {
    if (!this.schema.tables[targetTable] || !this.schema.tables[targetTable].columns[targetColumn]) {
      return 'Int';
    }
    
    const column = this.schema.tables[targetTable].columns[targetColumn];
    return column.suggestedPrismaType || this.getPrismaType(column);
  }

  /**
   * Trouve le domaine fonctionnel d'un mod√®le
   */
  private findDomainForModel(modelName: string): string {
    for (const [domain, models] of Object.entries(this.domainModels)) {
      if (models.includes(modelName)) {
        return domain;
      }
    }
    return 'non-class√©';
  }

  /**
   * G√©n√®re des fichiers Prisma s√©par√©s par domaine fonctionnel
   */
  private generateDomainSplitFiles(outputDir: string): void {
    console.log(chalk.blue('üì¶ G√©n√©ration des fichiers par domaine...'));

    // Cr√©er un fichier d'index qui importe tous les mod√®les
    let indexContent = `// Fichier d'index Prisma - importe tous les mod√®les par domaine
// G√©n√©r√© automatiquement par l'Agent 6 - G√©n√©rateur Prisma Intelligent

generator client {
  provider = "prisma-client-js"
  previewFeatures = ["postgresqlExtensions", "relationJoins", "multiSchema"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
  extensions = [citext, pg_trgm]
}

`;

    // G√©n√©rer un fichier par domaine
    Object.entries(this.domainModels).forEach(([domain, models]) => {
      if (models.length === 0) return; // Ignorer les domaines vides
      
      // Cr√©er le contenu du fichier de domaine
      let domainContent = `// Mod√®les Prisma du domaine: ${domain}
// G√©n√©r√© automatiquement par l'Agent 6 - G√©n√©rateur Prisma Intelligent

`;

      // Ajouter les mod√®les √† ce domaine
      models.forEach(modelName => {
        // Retrouver le nom de la table originale
        const tableName = Object.entries(this.modelMappings)
          .find(([prismaModel, _]) => prismaModel === modelName)?.[1].mysqlTable;
        
        if (tableName && this.schema.tables[tableName]) {
          domainContent += this.generateModel(tableName, this.schema.tables[tableName]);
        }
      });

      // √âcrire le fichier de domaine
      const domainFileName = `${domain.toLowerCase()}.prisma`;
      fs.writeFileSync(path.join(outputDir, domainFileName), domainContent);
      console.log(chalk.green(`‚úÖ Fichier de domaine g√©n√©r√©: ${domainFileName}`));
      
      // Ajouter l'import au fichier d'index
      indexContent += `// Importer le domaine ${domain}\n`;
      indexContent += `import "${domainFileName}"\n\n`;
    });

    // √âcrire le fichier d'index
    fs.writeFileSync(path.join(outputDir, 'index.prisma'), indexContent);
    console.log(chalk.green('‚úÖ Fichier d\'index g√©n√©r√©: index.prisma'));
  }

  /**
   * G√©n√®re le fichier de mapping
   */
  private generateMappingFile(outputDir: string): void {
    fs.writeFileSync(
      path.join(outputDir, 'prisma_model_map.json'),
      JSON.stringify(this.modelMappings, null, 2)
    );
    console.log(chalk.green('‚úÖ Fichier de mapping g√©n√©r√©: prisma_model_map.json'));
  }

  /**
   * G√©n√®re le fichier d'avertissements
   */
  private generateWarningsFile(outputDir: string): void {
    let content = `# Avertissements et Probl√®mes Potentiels

Ce fichier contient les avertissements et probl√®mes d√©tect√©s lors de la g√©n√©ration du sch√©ma Prisma.

## Points d'attention

${this.warnings.length > 0 
  ? this.warnings.map(w => `- ‚ö†Ô∏è ${w}`).join('\n') 
  : '- ‚úÖ Aucun avertissement d√©tect√©'}

## Suggestions d'optimisation

- V√©rifiez que les relations ont √©t√© correctement d√©tect√©es et √©tablies
- Assurez-vous que les types de donn√©es sont adapt√©s √† vos besoins
- Examinez les valeurs par d√©faut pour confirmer qu'elles sont correctement transpos√©es
- Validez les index et contraintes pour optimiser les performances

## Vues et Tables Temporaires

Les vues sont comment√©es dans le sch√©ma. Pour les activer, retirez les commentaires et utilisez l'option appropri√©e.

`;

    fs.writeFileSync(path.join(outputDir, 'prisma_warnings.md'), content);
    console.log(chalk.green('‚úÖ Fichier d\'avertissements g√©n√©r√©: prisma_warnings.md'));
  }

  /**
   * G√©n√®re le fichier de suggestions de d√©coupage en modules
   */
  private generateModuleSplitsFile(outputDir: string): void {
    let content = `# Suggestions de D√©coupage en Modules

Ce fichier propose une organisation modulaire du sch√©ma Prisma pour une meilleure maintenabilit√©.

## Modules Fonctionnels

`;

    Object.entries(this.domainModels).forEach(([domain, models]) => {
      if (models.length === 0) return;
      
      content += `### Module ${domain.toUpperCase()}\n\n`;
      content += `Responsabilit√©: ${this.tableClassification.domains[domain]?.description || 'Non sp√©cifi√©e'}\n\n`;
      content += `Mod√®les inclus:\n`;
      models.forEach(model => {
        content += `- ${model}\n`;
      });
      content += '\n';
    });

    content += `## Comment Utiliser le Multi-Fichiers

Pour utiliser Prisma avec plusieurs fichiers:

1. Activez la fonctionnalit√© multiSchema dans le g√©n√©rateur:
   \`\`\`prisma
   generator client {
     provider = "prisma-client-js"
     previewFeatures = ["multiSchema"]
   }
   \`\`\`

2. Importez les fichiers dans votre index.prisma:
   \`\`\`prisma
   import "./user.prisma"
   import "./product.prisma"
   // etc.
   \`\`\`

3. Ex√©cutez la g√©n√©ration comme d'habitude:
   \`\`\`
   npx prisma generate
   \`\`\`
`;

    fs.writeFileSync(path.join(outputDir, 'module_splits.md'), content);
    console.log(chalk.green('‚úÖ Fichier de d√©coupage en modules g√©n√©r√©: module_splits.md'));
  }

  /**
   * Convertit une cha√Æne en PascalCase
   */
  private toPascalCase(str: string): string {
    return str
      .split(/[_\s]/)
      .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
      .join('');
  }

  /**
   * Convertit une cha√Æne en camelCase
   */
  private toCamelCase(str: string): string {
    const pascalCase = this.toPascalCase(str);
    return pascalCase.charAt(0).toLowerCase() + pascalCase.slice(1);
  }

  /**
   * Met au pluriel une cha√Æne
   */
  private pluralize(str: string): string {
    // R√®gles de pluralisation simplifi√©es
    if (str.endsWith('s') || str.endsWith('x') || str.endsWith('z') || 
        str.endsWith('ch') || str.endsWith('sh')) {
      return str + 'es';
    } else if (str.endsWith('y') && !['a', 'e', 'i', 'o', 'u'].includes(str.charAt(str.length - 2).toLowerCase())) {
      return str.slice(0, -1) + 'ies';
    } else {
      return str + 's';
    }
  }
}

/**
 * Fonction principale
 */
async function main() {
  try {
    console.log(chalk.blue('üöÄ D√©marrage du G√©n√©rateur Prisma Intelligent'));

    // V√©rifier que les fichiers d'entr√©e existent
    if (!fs.existsSync(options.inputSchema)) {
      console.error(chalk.red(`‚ùå Erreur: Le fichier de sch√©ma ${options.inputSchema} n'existe pas.`));
      console.log(chalk.yellow('üí° Utilisez l\'agent MySQL Analyzer pour g√©n√©rer ce fichier d\'abord.'));
      process.exit(1);
    }

    // Cr√©er le g√©n√©rateur
    const generator = new PrismaSmartGenerator(
      options.inputSchema,
      options.typeMapping,
      options.tableClassification,
      options.keepSnakeCase
    );

    // G√©n√©rer le sch√©ma
    await generator.generate(options.outputDir, options.multiFile);

  } catch (error: any) {
    console.error(chalk.red(`‚ùå Erreur: ${error.message}`));
    console.error(error);
    process.exit(1);
  }
}

// Ex√©cuter la fonction principale
main().catch(error => {
  console.error(chalk.red(`‚ùå Erreur non g√©r√©e: ${error.message}`));
  console.error(error);
  process.exit(1);
});























import { BaseAgent } from '@workspaces/cahier-des-charge/src/core/interfaces/base-agent';
import { BusinessAgent, GeneratorAgent } from '@workspaces/cahier-des-charge/src/core/interfaces/business';








































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































