#!/usr/bin/env node
// Fichier adapt√© pour la nouvelle architecture √† trois couches
import { AbstractAnalyzerAgent, AnalyzerConfig } from '../../core/abstract-analyzer-agent';
import { AgentContext } from '../../core/mcp-agent';

/**
 * php-analyzer.ts
 * 
 * Agent d'analyse PHP qui examine les fichiers PHP, g√©n√®re un rapport d'analyse
 * et enregistre les r√©sultats dans Supabase pour le protocole MCP.
 * 
 * Usage: ts-node php-analyzer.ts [options]
 * 
 * Options:
 *   --file=<path>        Chemin vers le fichier PHP √† analyser
 *   --dir=<path>         R√©pertoire contenant les fichiers PHP √† analyser
 *   --output=<path>      R√©pertoire de sortie pour les rapports
 *   --recursive          Analyse r√©cursivement les sous-r√©pertoires
 *   --verbose            Affiche des informations d√©taill√©es pendant l'analyse
 */

import * as fs from 'fs';
import * as path from 'path';
import { program } from 'commander';
import * as glob from 'glob';
import chalk from 'chalk';
import { Engine, Parser } from 'php-parser';  // Correction: importer Parser au lieu de parse
import { supabase, SupabaseHelper, AuditLog, FileMapping } from '../../mcp-core/supabaseClient';

// Imports suppl√©mentaires si n√©cessaires
import { BaseAgent } from '../../core/interfaces/base-agent';
import { BusinessAgent } from '../../core/interfaces/business';

// Configuration de la ligne de commande
program
  .version('1.0.0')
  .description('Analyse les fichiers PHP et enregistre les r√©sultats dans Supabase')
  .option('--file <path>', 'Chemin vers le fichier PHP √† analyser')
  .option('--dir <path>', 'R√©pertoire contenant les fichiers PHP √† analyser')
  .option('--output <path>', 'R√©pertoire de sortie pour les rapports', './reports/php-analysis')
  .option('--recursive', 'Analyse r√©cursivement les sous-r√©pertoires', false)
  .option('--verbose', 'Affiche des informations d√©taill√©es pendant l\'analyse', false)
  .parse(process.argv);

const options = program.opts();

// Interfaces pour les r√©sultats d'analyse
interface PHPAnalysisResult {
  filePath: string;
  className?: string;
  methods: MethodInfo[];
  properties: PropertyInfo[];
  dependencies: string[];
  databaseQueries: DatabaseQueryInfo[];
  complexity: ComplexityMetrics;
  patterns: DetectedPattern[];
  issues: AnalysisIssue[];
  migrationDifficulty: 'easy' | 'medium' | 'hard';
  migrationEstimateHours: number;
  recommendations: string[];
}

interface MethodInfo {
  name: string;
  visibility: 'public' | 'protected' | 'private';
  static: boolean;
  parameters: ParameterInfo[];
  returnType?: string;
  complexity: number;
  loc: number;
  docblockComplete: boolean;
  hasTypeHints: boolean;
}

interface ParameterInfo {
  name: string;
  type?: string;
  defaultValue?: any;
  nullable: boolean;
}

interface PropertyInfo {
  name: string;
  visibility: 'public' | 'protected' | 'private';
  static: boolean;
  type?: string;
  defaultValue?: any;
}

interface DatabaseQueryInfo {
  query: string;
  type: 'select' | 'insert' | 'update' | 'delete' | 'other';
  tables: string[];
  prepared: boolean;
  line: number;
}

interface ComplexityMetrics {
  cyclomaticComplexity: number;
  maintainabilityIndex: number;
  halsteadVolume: number;
  locTotal: number;
  locLogic: number;
  locComments: number;
}

interface DetectedPattern {
  name: string;
  confidence: number;
  location: {
    startLine: number;
    endLine: number;
  };
  description: string;
}

interface AnalysisIssue {
  type: 'security' | 'performance' | 'maintainability' | 'bug' | 'style';
  severity: 'high' | 'medium' | 'low';
  message: string;
  line?: number;
  code?: string;
  recommendation?: string;
}

/**
 * Fonction principale
 */
async function main() {
  console.log(chalk.blue('üöÄ D√©marrage de l\'analyse PHP'));

  // V√©rifier les param√®tres obligatoires
  if (!options.file && !options.dir) {
    console.error(chalk.red('‚ùå Erreur: Vous devez sp√©cifier un fichier (--file) ou un r√©pertoire (--dir) √† analyser'));
    process.exit(1);
  }

  // V√©rifier la connexion √† Supabase
  try {
    const { data, error } = await supabase.from('audit_logs').select('count').limit(1);
    if (error) {
      console.error(chalk.red(`‚ùå Erreur de connexion √† Supabase: ${error.message}`));
      console.error(chalk.red('V√©rifiez vos variables d\'environnement SUPABASE_URL et SUPABASE_SERVICE_ROLE_KEY'));
      process.exit(1);
    }
    console.log(chalk.green('‚úÖ Connexion √† Supabase √©tablie avec succ√®s'));
  } catch (error) {
    console.error(chalk.red(`‚ùå Erreur inattendue lors de la connexion √† Supabase: ${error.message}`));
    process.exit(1);
  }

  // Cr√©er le r√©pertoire de sortie s'il n'existe pas
  const outputDir = path.resolve(options.output);
  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true });
  }

  // R√©cup√©rer la liste des fichiers √† analyser
  const filesToAnalyze: string[] = [];

  if (options.file) {
    // Analyse d'un seul fichier
    const filePath = path.resolve(options.file);
    if (!fs.existsSync(filePath)) {
      console.error(chalk.red(`‚ùå Erreur: Le fichier ${filePath} n'existe pas`));
      process.exit(1);
    }
    filesToAnalyze.push(filePath);
  } else if (options.dir) {
    // Analyse d'un r√©pertoire
    const dirPath = path.resolve(options.dir);
    if (!fs.existsSync(dirPath)) {
      console.error(chalk.red(`‚ùå Erreur: Le r√©pertoire ${dirPath} n'existe pas`));
      process.exit(1);
    }

    const pattern = options.recursive ? '**/*.php' : '*.php';
    filesToAnalyze.push(...glob.sync(path.join(dirPath, pattern)));

    console.log(chalk.blue(`üìÇ ${filesToAnalyze.length} fichiers PHP trouv√©s dans ${dirPath}`));
  }

  // Analyser chaque fichier
  let successCount = 0;
  let errorCount = 0;

  for (const filePath of filesToAnalyze) {
    try {
      console.log(chalk.blue(`\nüìù Analyse de ${filePath}...`));
      
      // Cr√©er un mapping de fichier avec le statut "analyzing"
      const fileMapping: FileMapping = {
        php_file: filePath,
        status: 'analyzing',
      };
      
      const mappingId = await SupabaseHelper.createFileMapping(fileMapping);
      
      if (!mappingId) {
        console.warn(chalk.yellow(`‚ö†Ô∏è Impossible de cr√©er le mapping pour ${filePath}`));
      } else if (options.verbose) {
        console.log(chalk.gray(`üìå Mapping cr√©√© avec l'ID ${mappingId}`));
      }
      
      // Cr√©er un log d'audit avec le statut "running"
      const auditLog: AuditLog = {
        file_name: filePath,
        module: detectModule(filePath),
        agent: 'php-analyzer',
        status: 'running',
        audit_json: {}
      };
      
      const auditId = await SupabaseHelper.createAuditLog(auditLog);
      
      if (!auditId) {
        console.warn(chalk.yellow(`‚ö†Ô∏è Impossible de cr√©er le log d'audit pour ${filePath}`));
      } else if (options.verbose) {
        console.log(chalk.gray(`üìù Log d'audit cr√©√© avec l'ID ${auditId}`));
      }
      
      // Effectuer l'analyse
      const result = await analyzePHPFile(filePath);
      successCount++;
      
      // Enregistrer le r√©sultat dans un fichier JSON
      const outputFilePath = path.join(outputDir, path.basename(filePath) + '.analysis.json');
      fs.writeFileSync(outputFilePath, JSON.stringify(result, null, 2));
      console.log(chalk.green(`‚úÖ Analyse enregistr√©e dans ${outputFilePath}`));
      
      // Mettre √† jour le log d'audit avec le statut "done" et les r√©sultats
      if (auditId) {
        await SupabaseHelper.updateAuditLog(auditId, {
          status: 'done',
          audit_json: result
        });
        
        if (options.verbose) {
          console.log(chalk.gray(`üìù Log d'audit mis √† jour avec les r√©sultats`));
        }
      }
      
      // Mettre √† jour le mapping de fichier avec le statut "analyzed"
      if (mappingId) {
        await SupabaseHelper.updateFileMapping(mappingId, {
          status: 'analyzed',
          migration_data: {
            analyzed_at: new Date().toISOString(),
            complexity: result.complexity,
            migration_difficulty: result.migrationDifficulty,
            migration_estimate_hours: result.migrationEstimateHours,
            issue_count: result.issues.length
          }
        });
        
        if (options.verbose) {
          console.log(chalk.gray(`üìå Mapping mis √† jour avec le statut "analyzed"`));
        }
      }
      
    } catch (error) {
      console.error(chalk.red(`‚ùå Erreur lors de l'analyse de ${filePath}: ${error.message}`));
      errorCount++;
      
      // Mettre √† jour le log d'audit avec le statut "error"
      try {
        const auditLogs = await SupabaseHelper.getAuditLogsForFile(filePath);
        const runningLog = auditLogs.find(log => log.status === 'running');
        
        if (runningLog && runningLog.id) {
          await SupabaseHelper.updateAuditLog(runningLog.id, {
            status: 'error',
            audit_json: {
              error: error.message,
              stack: error.stack
            }
          });
        }
        
        // Mettre √† jour le mapping avec le statut "error"
        const mapping = await SupabaseHelper.getFileMappingByPhpFile(filePath);
        
        if (mapping && mapping.id) {
          await SupabaseHelper.updateFileMapping(mapping.id, {
            status: 'error',
            migration_data: {
              error: error.message,
              error_at: new Date().toISOString()
            }
          });
        }
      } catch (updateError) {
        console.error(chalk.red(`‚ùå Erreur lors de la mise √† jour du statut d'erreur: ${updateError.message}`));
      }
    }
  }

  // Afficher un r√©sum√©
  console.log(chalk.blue('\nüìä R√©sum√© de l\'analyse:'));
  console.log(chalk.green(`‚úÖ ${successCount} fichier(s) analys√©(s) avec succ√®s`));
  if (errorCount > 0) {
    console.log(chalk.red(`‚ùå ${errorCount} fichier(s) ont rencontr√© des erreurs`));
  }
}

/**
 * Analyse un fichier PHP
 */
async function analyzePHPFile(filePath: string): Promise<PHPAnalysisResult> {
  // Lecture du fichier
  const fileContent = fs.readFileSync(filePath, 'utf8');
  
  // Initialiser le r√©sultat
  const result: PHPAnalysisResult = {
    filePath,
    methods: [],
    properties: [],
    dependencies: [],
    databaseQueries: [],
    complexity: {
      cyclomaticComplexity: 0,
      maintainabilityIndex: 0,
      halsteadVolume: 0,
      locTotal: 0,
      locLogic: 0,
      locComments: 0
    },
    patterns: [],
    issues: [],
    migrationDifficulty: 'medium',
    migrationEstimateHours: 2,
    recommendations: []
  };
  
  try {
    // Parser le code PHP avec une instance de Parser
    const parser = new Engine({
      parser: {
        debug: false,
        locations: true,
        extractDoc: true,
        suppressErrors: true
      },
      ast: {
        withPositions: true
      }
    });
    
    const ast = parser.parseCode(fileContent, filePath);
    
    // Extraire les informations de base
    result.className = extractClassName(ast);
    result.methods = extractMethods(ast);
    result.properties = extractProperties(ast);
    result.dependencies = extractDependencies(ast);
    result.databaseQueries = extractDatabaseQueries(fileContent);
    
    // Calculer la complexit√©
    result.complexity = calculateComplexity(fileContent, ast);
    
    // D√©tecter les patterns
    result.patterns = detectPatterns(ast, fileContent);
    
    // Analyser les probl√®mes potentiels
    result.issues = analyzeIssues(fileContent, ast);
    
    // √âvaluer la difficult√© de migration
    const difficultyAssessment = assessMigrationDifficulty(result);
    result.migrationDifficulty = difficultyAssessment.difficulty;
    result.migrationEstimateHours = difficultyAssessment.estimateHours;
    
    // G√©n√©rer des recommandations
    result.recommendations = generateRecommendations(result);
    
    return result;
  } catch (error) {
    console.error(chalk.red(`Erreur lors de l'analyse de ${filePath}:`), error);
    throw new Error(`√âchec de l'analyse: ${error.message}`);
  }
}

/**
 * D√©tecte le module auquel appartient le fichier
 */
function detectModule(filePath: string): string {
  // Logique simple bas√©e sur le chemin du fichier
  const normalizedPath = filePath.replace(/\\/g, '/');
  
  if (normalizedPath.includes('/admin/')) return 'admin';
  if (normalizedPath.includes('/cart/')) return 'cart';
  if (normalizedPath.includes('/product/')) return 'product';
  if (normalizedPath.includes('/user/')) return 'user';
  if (normalizedPath.includes('/auth/')) return 'auth';
  if (normalizedPath.includes('/order/')) return 'order';
  if (normalizedPath.includes('/payment/')) return 'payment';
  if (normalizedPath.includes('/shipping/')) return 'shipping';
  if (normalizedPath.includes('/customer/')) return 'customer';
  if (normalizedPath.includes('/inventory/')) return 'inventory';
  
  // Extraire le r√©pertoire parent comme module par d√©faut
  const parts = normalizedPath.split('/');
  if (parts.length >= 2) {
    return parts[parts.length - 2];
  }
  
  return 'core';
}

/**
 * Extrait le nom de la classe du fichier
 */
function extractClassName(ast: any): string | undefined {
  // Impl√©mentation simplifi√©e pour l'exemple
  try {
    if (ast && ast.children) {
      for (const node of ast.children) {
        if (node.kind === 'class') {
          return node.name.name;
        }
      }
    }
  } catch (error) {
    console.warn(chalk.yellow('‚ö†Ô∏è Erreur lors de l\'extraction du nom de classe'), error);
  }
  
  return undefined;
}

/**
 * Extrait les m√©thodes de la classe
 */
function extractMethods(ast: any): MethodInfo[] {
  const methods: MethodInfo[] = [];
  
  // Impl√©mentation simplifi√©e pour l'exemple
  try {
    if (ast && ast.children) {
      for (const node of ast.children) {
        if (node.kind === 'class' && node.body) {
          for (const classItem of node.body) {
            if (classItem.kind === 'method') {
              const method: MethodInfo = {
                name: classItem.name.name,
                visibility: getVisibility(classItem),
                static: Boolean(classItem.isStatic),
                parameters: extractParameters(classItem),
                complexity: 1, // Valeur par d√©faut
                loc: countLines(classItem),
                docblockComplete: hasCompleteDocblock(classItem),
                hasTypeHints: hasParameterTypeHints(classItem)
              };
              
              // Extraire le type de retour s'il existe
              if (classItem.returnType) {
                method.returnType = classItem.returnType.name;
              }
              
              methods.push(method);
            }
          }
        }
      }
    }
  } catch (error) {
    console.warn(chalk.yellow('‚ö†Ô∏è Erreur lors de l\'extraction des m√©thodes'), error);
  }
  
  return methods;
}

/**
 * D√©termine la visibilit√© d'un √©l√©ment de classe
 */
function getVisibility(node: any): 'public' | 'protected' | 'private' {
  if (node.visibility === 'protected') return 'protected';
  if (node.visibility === 'private') return 'private';
  return 'public'; // Par d√©faut
}

/**
 * Extrait les param√®tres d'une m√©thode
 */
function extractParameters(methodNode: any): ParameterInfo[] {
  const parameters: ParameterInfo[] = [];
  
  try {
    if (methodNode.arguments) {
      for (const arg of methodNode.arguments) {
        const parameter: ParameterInfo = {
          name: arg.name,
          nullable: Boolean(arg.nullable)
        };
        
        // Extraire le type s'il existe
        if (arg.type) {
          parameter.type = arg.type;
        }
        
        // Extraire la valeur par d√©faut s'il en existe une
        if (arg.value) {
          parameter.defaultValue = arg.value.value;
        }
        
        parameters.push(parameter);
      }
    }
  } catch (error) {
    console.warn(chalk.yellow('‚ö†Ô∏è Erreur lors de l\'extraction des param√®tres'), error);
  }
  
  return parameters;
}

/**
 * Compte le nombre de lignes d'une m√©thode
 */
function countLines(node: any): number {
  try {
    if (node.loc) {
      return node.loc.end.line - node.loc.start.line + 1;
    }
  } catch (error) {
    console.warn(chalk.yellow('‚ö†Ô∏è Erreur lors du comptage des lignes'), error);
  }
  
  return 0;
}

/**
 * V√©rifie si une m√©thode a un docblock complet
 */
function hasCompleteDocblock(methodNode: any): boolean {
  try {
    if (methodNode.doc) {
      const doc = methodNode.doc.toString();
      return doc.includes('@param') && doc.includes('@return');
    }
  } catch (error) {
    console.warn(chalk.yellow('‚ö†Ô∏è Erreur lors de la v√©rification du docblock'), error);
  }
  
  return false;
}

/**
 * V√©rifie si les param√®tres d'une m√©thode ont des type hints
 */
function hasParameterTypeHints(methodNode: any): boolean {
  try {
    if (methodNode.arguments && methodNode.arguments.length > 0) {
      return methodNode.arguments.every((arg: any) => Boolean(arg.type));
    }
  } catch (error) {
    console.warn(chalk.yellow('‚ö†Ô∏è Erreur lors de la v√©rification des type hints'), error);
  }
  
  return false;
}

/**
 * Extrait les propri√©t√©s de la classe
 */
function extractProperties(ast: any): PropertyInfo[] {
  const properties: PropertyInfo[] = [];
  
  // Impl√©mentation simplifi√©e pour l'exemple
  try {
    if (ast && ast.children) {
      for (const node of ast.children) {
        if (node.kind === 'class' && node.body) {
          for (const classItem of node.body) {
            if (classItem.kind === 'property') {
              for (const prop of classItem.properties) {
                const property: PropertyInfo = {
                  name: prop.name,
                  visibility: getVisibility(classItem),
                  static: Boolean(classItem.isStatic)
                };
                
                // Extraire la valeur par d√©faut s'il en existe une
                if (prop.value) {
                  property.defaultValue = prop.value.value;
                }
                
                properties.push(property);
              }
            }
          }
        }
      }
    }
  } catch (error) {
    console.warn(chalk.yellow('‚ö†Ô∏è Erreur lors de l\'extraction des propri√©t√©s'), error);
  }
  
  return properties;
}

/**
 * Extrait les d√©pendances (use, require, include, etc.)
 */
function extractDependencies(ast: any): string[] {
  const dependencies: string[] = [];
  
  // Impl√©mentation simplifi√©e pour l'exemple
  try {
    if (ast && ast.children) {
      for (const node of ast.children) {
        // Inclusions
        if (node.kind === 'include' || node.kind === 'require') {
          if (node.target && node.target.value) {
            dependencies.push(node.target.value);
          }
        }
        
        // Imports (use statements)
        if (node.kind === 'namespace' && node.children) {
          for (const nsChild of node.children) {
            if (nsChild.kind === 'use' && nsChild.items) {
              for (const useItem of nsChild.items) {
                dependencies.push(useItem.name);
              }
            }
          }
        }
        
        // Use statements au niveau global
        if (node.kind === 'use' && node.items) {
          for (const useItem of node.items) {
            dependencies.push(useItem.name);
          }
        }
      }
    }
  } catch (error) {
    console.warn(chalk.yellow('‚ö†Ô∏è Erreur lors de l\'extraction des d√©pendances'), error);
  }
  
  return [...new Set(dependencies)]; // D√©dupliquer
}

/**
 * Extrait les requ√™tes de base de donn√©es
 */
function extractDatabaseQueries(fileContent: string): DatabaseQueryInfo[] {
  const queries: DatabaseQueryInfo[] = [];
  
  // Impl√©mentation simplifi√©e pour l'exemple
  // Recherche de patterns SQL courants
  
  // Pattern 1: Requ√™tes SQL directes avec des cha√Ænes de caract√®res simples
  const directQueryRegex = /["`']SELECT\s+.*?FROM\s+.*?["`']/gi;
  const directMatches = fileContent.match(directQueryRegex) || [];
  
  // Pattern 2: Requ√™tes pr√©par√©es avec execute
  const preparedQueryRegex = /\$stmt\s*=\s*\$(?:this->)?(?:pdo|db|conn|connection|database)->prepare\s*\(\s*["'`](.*?)["'`]\s*\)/gi;
  const preparedMatches = [...fileContent.matchAll(preparedQueryRegex)];
  
  // Ajouter les requ√™tes directes
  for (const match of directMatches) {
    // Extraire les tables (simplifi√©)
    const fromRegex = /FROM\s+["`']?(\w+)["`']?/i;
    const fromMatch = match.match(fromRegex);
    const table = fromMatch ? fromMatch[1] : 'unknown';
    
    // D√©terminer le type (simplifi√©)
    let type: 'select' | 'insert' | 'update' | 'delete' | 'other' = 'other';
    if (match.toUpperCase().startsWith('SELECT')) type = 'select';
    else if (match.toUpperCase().startsWith('INSERT')) type = 'insert';
    else if (match.toUpperCase().startsWith('UPDATE')) type = 'update';
    else if (match.toUpperCase().startsWith('DELETE')) type = 'delete';
    
    // Trouver le num√©ro de ligne (approximatif)
    const lines = fileContent.split('\n');
    let lineNumber = 0;
    for (let i = 0; i < lines.length; i++) {
      if (lines[i].includes(match)) {
        lineNumber = i + 1;
        break;
      }
    }
    
    queries.push({
      query: match,
      type,
      tables: [table],
      prepared: false,
      line: lineNumber
    });
  }
  
  // Ajouter les requ√™tes pr√©par√©es
  for (const match of preparedMatches) {
    const query = match[1];
    
    // Extraire les tables (simplifi√©)
    const fromRegex = /FROM\s+["`']?(\w+)["`']?/i;
    const fromMatch = query.match(fromRegex);
    const table = fromMatch ? fromMatch[1] : 'unknown';
    
    // D√©terminer le type (simplifi√©)
    let type: 'select' | 'insert' | 'update' | 'delete' | 'other' = 'other';
    if (query.toUpperCase().startsWith('SELECT')) type = 'select';
    else if (query.toUpperCase().startsWith('INSERT')) type = 'insert';
    else if (query.toUpperCase().startsWith('UPDATE')) type = 'update';
    else if (query.toUpperCase().startsWith('DELETE')) type = 'delete';
    
    // Calculer le num√©ro de ligne
    const upToMatch = fileContent.slice(0, match.index);
    const lineNumber = upToMatch.split('\n').length;
    
    queries.push({
      query,
      type,
      tables: [table],
      prepared: true,
      line: lineNumber
    });
  }
  
  return queries;
}

/**
 * Calcule les m√©triques de complexit√©
 */
function calculateComplexity(fileContent: string, ast: any): ComplexityMetrics {
  // Impl√©mentation simplifi√©e pour l'exemple
  
  // Compter les lignes de code totales
  const lines = fileContent.split('\n');
  const locTotal = lines.length;
  
  // Compter les lignes de commentaires (approximatif)
  const commentLines = lines.filter(line => 
    line.trim().startsWith('//') || 
    line.trim().startsWith('/*') || 
    line.trim().startsWith('*')
  ).length;
  
  // Compter les lignes de code logique (approximatif)
  const logicLines = lines.filter(line => {
    const trimmed = line.trim();
    return trimmed.length > 0 && 
           !trimmed.startsWith('//') && 
           !trimmed.startsWith('/*') && 
           !trimmed.startsWith('*') &&
           !trimmed.startsWith('}') &&
           !trimmed.startsWith('{');
  }).length;
  
  // Calculer la complexit√© cyclomatique (simplifi√©)
  // Compter les structures de contr√¥le
  const controlStructures = (fileContent.match(/\b(if|else|for|foreach|while|do|switch|case)\b/g) || []).length;
  const cyclomaticComplexity = 1 + controlStructures;
  
  // Calculer l'indice de maintenabilit√© (simplifi√©)
  // Formule simplifi√©e: 171 - 5.2 * ln(halsteadVolume) - 0.23 * (cyclomaticComplexity) - 16.2 * ln(locTotal)
  const halsteadVolume = locTotal * 0.7; // Approximation
  const maintainabilityIndex = Math.max(0, Math.min(100, 
    171 - 5.2 * Math.log(halsteadVolume) - 0.23 * cyclomaticComplexity - 16.2 * Math.log(locTotal)
  ));
  
  return {
    cyclomaticComplexity,
    maintainabilityIndex,
    halsteadVolume,
    locTotal,
    locLogic: logicLines,
    locComments: commentLines
  };
}

/**
 * D√©tecte les patterns de conception dans le code
 */
function detectPatterns(ast: any, fileContent: string): DetectedPattern[] {
  const patterns: DetectedPattern[] = [];
  
  // Impl√©mentation simplifi√©e pour l'exemple
  
  // 1. D√©tection du pattern Singleton
  if (fileContent.includes('private static $instance') && 
      fileContent.includes('private function __construct') &&
      fileContent.includes('public static function getInstance')) {
    patterns.push({
      name: 'Singleton',
      confidence: 0.9,
      location: {
        startLine: 1,
        endLine: fileContent.split('\n').length
      },
      description: 'Cette classe utilise le pattern Singleton'
    });
  }
  
  // 2. D√©tection du pattern Factory
  if (fileContent.includes('function create') && 
      (fileContent.includes('return new ') || fileContent.includes('instanceof'))) {
    patterns.push({
      name: 'Factory',
      confidence: 0.7,
      location: {
        startLine: 1,
        endLine: fileContent.split('\n').length
      },
      description: 'Cette classe semble impl√©menter le pattern Factory'
    });
  }
  
  // 3. D√©tection du pattern Repository
  if ((fileContent.includes('Repository') || fileContent.includes('DAO')) && 
      (fileContent.includes('find') || fileContent.includes('get') || fileContent.includes('save'))) {
    patterns.push({
      name: 'Repository',
      confidence: 0.8,
      location: {
        startLine: 1,
        endLine: fileContent.split('\n').length
      },
      description: 'Cette classe impl√©mente le pattern Repository pour l\'acc√®s aux donn√©es'
    });
  }
  
  // 4. D√©tection du pattern Observer
  if (fileContent.includes('addObserver') && 
      fileContent.includes('notifyObservers')) {
    patterns.push({
      name: 'Observer',
      confidence: 0.85,
      location: {
        startLine: 1,
        endLine: fileContent.split('\n').length
      },
      description: 'Cette classe impl√©mente le pattern Observer'
    });
  }
  
  return patterns;
}

/**
 * Analyse les probl√®mes potentiels dans le code
 */
function analyzeIssues(fileContent: string, ast: any): AnalysisIssue[] {
  const issues: AnalysisIssue[] = [];
  
  // Impl√©mentation simplifi√©e pour l'exemple
  
  // 1. Probl√®mes de s√©curit√©
  
  // SQL Injection
  if (fileContent.includes('$_GET') && fileContent.includes('query(')) {
    issues.push({
      type: 'security',
      severity: 'high',
      message: 'Risque d\'injection SQL: utilisation de variables $_GET directement dans une requ√™te SQL',
      recommendation: 'Utilisez des requ√™tes pr√©par√©es avec des param√®tres li√©s'
    });
  }
  
  // XSS
  if (fileContent.includes('echo $_') || fileContent.includes('print $_')) {
    issues.push({
      type: 'security',
      severity: 'high',
      message: 'Risque XSS: affichage de donn√©es utilisateur sans √©chappement',
      recommendation: 'Utilisez htmlspecialchars() pour √©chapper les donn√©es utilisateur'
    });
  }
  
  // 2. Probl√®mes de performance
  
  // Requ√™tes dans des boucles
  if (fileContent.match(/for\s*\(.*\)\s*\{[\s\S]*?\$.*->query\s*\(/)) {
    issues.push({
      type: 'performance',
      severity: 'medium',
      message: 'Requ√™te de base de donn√©es dans une boucle',
      recommendation: 'Utilisez des requ√™tes avec JOIN ou avec des clauses IN plut√¥t que des requ√™tes individuelles dans des boucles'
    });
  }
  
  // 3. Probl√®mes de maintenabilit√©
  
  // M√©thodes trop longues
  const lines = fileContent.split('\n');
  let inMethod = false;
  let methodStart = 0;
  let methodName = '';
  let bracketCount = 0;
  
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i].trim();
    
    // D√©tection du d√©but d'une m√©thode
    if (!inMethod && line.match(/function\s+(\w+)\s*\(/)) {
      inMethod = true;
      methodStart = i;
      methodName = line.match(/function\s+(\w+)\s*\(/)[1];
      bracketCount = 0;
    }
    
    // Comptage des accolades
    if (inMethod) {
      bracketCount += (line.match(/\{/g) || []).length;
      bracketCount -= (line.match(/\}/g) || []).length;
      
      // Fin de m√©thode
      if (bracketCount === 0 && line.includes('}')) {
        inMethod = false;
        const methodLength = i - methodStart + 1;
        
        if (methodLength > 50) {
          issues.push({
            type: 'maintainability',
            severity: 'medium',
            message: `M√©thode "${methodName}" trop longue (${methodLength} lignes)`,
            line: methodStart + 1,
            recommendation: 'Divisez cette m√©thode en m√©thodes plus petites et plus sp√©cialis√©es'
          });
        }
      }
    }
  }
  
  // 4. Bugs potentiels
  
  // Utilisation de variables non initialis√©es
  const variableUseRegex = /\$(\w+)\s*(?:=|\+|-|\*|\/|\.)/g;
  const variableMatches = [...fileContent.matchAll(variableUseRegex)];
  const usedVariables = new Set(variableMatches.map(match => match[1]));
  
  const variableDefRegex = /\$(\w+)\s*=/g;
  const definedVariables = new Set([...fileContent.matchAll(variableDefRegex)].map(match => match[1]));
  
  // Variables globales pr√©d√©finies
  const predefinedVars = new Set(['_GET', '_POST', '_REQUEST', '_SESSION', '_COOKIE', '_SERVER', '_ENV', '_FILES', 'GLOBALS', 'this']);
  
  // V√©rification des variables potentiellement non initialis√©es
  for (const variable of usedVariables) {
    if (!definedVariables.has(variable) && !predefinedVars.has(variable) && variable !== 'this') {
      issues.push({
        type: 'bug',
        severity: 'medium',
        message: `Variable "$${variable}" potentiellement non initialis√©e`,
        recommendation: `Assurez-vous d'initialiser la variable "$${variable}" avant de l'utiliser`
      });
    }
  }
  
  return issues;
}

/**
 * √âvalue la difficult√© de migration
 */
function assessMigrationDifficulty(analysis: PHPAnalysisResult): { difficulty: 'easy' | 'medium' | 'hard', estimateHours: number } {
  // Calculer un score de difficult√© bas√© sur plusieurs facteurs
  let difficultyScore = 0;
  
  // Facteur 1: Complexit√© du code
  if (analysis.complexity.cyclomaticComplexity > 20) {
    difficultyScore += 3;
  } else if (analysis.complexity.cyclomaticComplexity > 10) {
    difficultyScore += 2;
  } else {
    difficultyScore += 1;
  }
  
  // Facteur 2: Utilisation de la base de donn√©es
  if (analysis.databaseQueries.length > 10) {
    difficultyScore += 3;
  } else if (analysis.databaseQueries.length > 5) {
    difficultyScore += 2;
  } else if (analysis.databaseQueries.length > 0) {
    difficultyScore += 1;
  }
  
  // Facteur 3: Nombre de d√©pendances
  if (analysis.dependencies.length > 10) {
    difficultyScore += 3;
  } else if (analysis.dependencies.length > 5) {
    difficultyScore += 2;
  } else {
    difficultyScore += 1;
  }
  
  // Facteur 4: Probl√®mes de s√©curit√© (pond√©ration plus √©lev√©e)
  const securityIssues = analysis.issues.filter(issue => issue.type === 'security').length;
  difficultyScore += securityIssues * 2;
  
  // Facteur 5: Taille du code
  if (analysis.complexity.locTotal > 500) {
    difficultyScore += 3;
  } else if (analysis.complexity.locTotal > 200) {
    difficultyScore += 2;
  } else {
    difficultyScore += 1;
  }
  
  // Conversion du score en difficult√©
  let difficulty: 'easy' | 'medium' | 'hard';
  let estimateHours: number;
  
  if (difficultyScore > 10) {
    difficulty = 'hard';
    estimateHours = Math.round(analysis.complexity.locTotal / 10); // ~10 lignes par heure pour les cas difficiles
  } else if (difficultyScore > 5) {
    difficulty = 'medium';
    estimateHours = Math.round(analysis.complexity.locTotal / 20); // ~20 lignes par heure pour les cas moyens
  } else {
    difficulty = 'easy';
    estimateHours = Math.round(analysis.complexity.locTotal / 30); // ~30 lignes par heure pour les cas faciles
  }
  
  // Assurer un minimum d'heures et un maximum raisonnable
  estimateHours = Math.max(1, Math.min(estimateHours, 80)); // Entre 1h et 80h (2 semaines)
  
  return { difficulty, estimateHours };
}

/**
 * G√©n√®re des recommandations pour la migration
 */
function generateRecommendations(analysis: PHPAnalysisResult): string[] {
  const recommendations: string[] = [];
  
  // Recommandation 1: Migration vers des models/repositories Prisma
  if (analysis.databaseQueries.length > 0) {
    recommendations.push('Convertir les requ√™tes SQL en mod√®les Prisma pour une meilleure type-safety et une gestion simplifi√©e de la base de donn√©es');
  }
  
  // Recommandation 2: Refactoring des m√©thodes trop longues
  const longMethods = analysis.methods.filter(method => method.loc > 50);
  if (longMethods.length > 0) {
    const methodNames = longMethods.map(m => m.name).join(', ');
    recommendations.push(`Refactoriser les m√©thodes trop longues (${methodNames}) en les divisant en m√©thodes plus petites et sp√©cialis√©es`);
  }
  
  // Recommandation 3: Ajout de types TypeScript
  if (analysis.methods.some(m => !m.hasTypeHints)) {
    recommendations.push('Ajouter des annotations de type TypeScript pour tous les param√®tres et valeurs de retour des m√©thodes');
  }
  
  // Recommandation 4: S√©curit√©
  const securityIssues = analysis.issues.filter(issue => issue.type === 'security');
  if (securityIssues.length > 0) {
    recommendations.push(`Corriger les ${securityIssues.length} probl√®mes de s√©curit√© identifi√©s avant la migration`);
  }
  
  // Recommandation 5: Adaptation du pattern
  if (analysis.patterns.length > 0) {
    const patterns = analysis.patterns.map(p => p.name).join(', ');
    recommendations.push(`Adapter les patterns existants (${patterns}) aux √©quivalents TypeScript/NestJS`);
  }
  
  // Recommandation 6: Tests
  recommendations.push('Cr√©er des tests unitaires et d\'int√©gration pour assurer que la fonctionnalit√© est pr√©serv√©e apr√®s la migration');
  
  // Recommandation 7: D√©pendances
  if (analysis.dependencies.length > 0) {
    recommendations.push('Identifier et migrer les d√©pendances PHP vers leurs √©quivalents TypeScript/Node.js');
  }
  
  // Recommandation 8: Architecture
  if (analysis.complexity.maintainabilityIndex < 65) {
    recommendations.push('Restructurer l\'architecture du code pendant la migration pour am√©liorer la maintenabilit√©');
  }
  
  return recommendations;
}

// Ex√©cuter la fonction principale
main().catch(error => {
  console.error(chalk.red(`‚ùå Erreur inattendue: ${error.message}`));
  console.error(error);
  process.exit(1);
});






















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































