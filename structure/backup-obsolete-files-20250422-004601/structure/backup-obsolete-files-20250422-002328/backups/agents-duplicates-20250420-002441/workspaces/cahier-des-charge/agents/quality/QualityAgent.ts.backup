/**
 * ‚ö†Ô∏è AGENT D√âPLAC√â - NE PAS UTILISER CETTE VERSION
 * 
 * Cet agent a √©t√© d√©plac√© et int√©gr√© dans la structure principale √†:
 * /workspaces/cahier-des-charge/packages/mcp-agents/business/misc/QualityAgent/index.ts
 * 
 * Veuillez mettre √† jour vos imports pour utiliser la nouvelle version.
 * 
 * Date de d√©placement: 2025-04-19 02:47:35
 */

import { BaseAgent } from '@workspaces/cahier-des-charge/src/core/interfaces/base-agent';
import { BusinessAgent } from '@workspaces/cahier-des-charge/src/core/interfaces/business';

export class QualityAgent implements BusinessAgent extends BaseAgent {
  /**
   * Analyse la qualit√©, la complexit√© et la s√©curit√© du code PHP
   */
  public async analyze(): Promise<void> {
    // √âvaluer la complexit√© cyclomatique
    const complexity = this.evaluateComplexity();
    
    // Analyser les risques de s√©curit√©
    const securityRisks = this.analyzeSecurityRisks();
    
    // √âvaluer la qualit√© g√©n√©rale
    const overallQuality = this.evaluateOverallQuality();
    
    // G√©n√©rer les sections d'audit
    this.addSection(
      'cyclomatic-complexity',
      'Complexit√© cyclomatique',
      complexity,
      'technical',
      this.determineComplexitySeverity(complexity)
    );
    
    this.addSection(
      'security-risks',
      'Risques de s√©curit√©',
      securityRisks.content,
      'security',
      securityRisks.severity
    );
    
    this.addSection(
      'overall-quality',
      'Qualit√© g√©n√©rale',
      overallQuality.content,
      'technical',
      overallQuality.severity
    );
  }
  
  /**
   * √âvalue la complexit√© cyclomatique du code
   */
  private evaluateComplexity(): string {
    const fileContent = this.fileContent;
    let complexity = '';
    
    // Compter les structures de contr√¥le de flux
    const ifCount = (fileContent.match(/if\s*\(/g) || []).length;
    const elseIfCount = (fileContent.match(/else\s*if\s*\(/g) || []).length;
    const switchCount = (fileContent.match(/switch\s*\(/g) || []).length;
    const caseCount = (fileContent.match(/case\s+/g) || []).length;
    const forCount = (fileContent.match(/for\s*\(/g) || []).length;
    const foreachCount = (fileContent.match(/foreach\s*\(/g) || []).length;
    const whileCount = (fileContent.match(/while\s*\(/g) || []).length;
    const doWhileCount = (fileContent.match(/do\s*{/g) || []).length;
    const ternaryCount = (fileContent.match(/\?.*:/g) || []).length;
    
    // Calcul approximatif de la complexit√© cyclomatique
    const flowControlCount = ifCount + elseIfCount + caseCount + forCount + 
                            foreachCount + whileCount + doWhileCount + ternaryCount;
    
    // Complexit√© = 1 + nombre de structures de contr√¥le
    const cyclomaticComplexity = 1 + flowControlCount;
    
    // √âvaluer la complexit√©
    let complexityRating = '';
    if (cyclomaticComplexity <= 5) {
      complexityRating = 'Faible';
    } else if (cyclomaticComplexity <= 10) {
      complexityRating = 'Mod√©r√©e';
    } else if (cyclomaticComplexity <= 20) {
      complexityRating = '√âlev√©e';
    } else {
      complexityRating = 'Tr√®s √©lev√©e';
    }
    
    // Calculer la profondeur maximale d'imbrication
    const lines = fileContent.split('
');
    let maxNestingLevel = 0;
    let currentNestingLevel = 0;
    
    lines.forEach(line => {
      // Incr√©menter le niveau d'imbrication pour les ouvertures de blocs
      if (line.includes('{')) {
        currentNestingLevel += (line.match(/{/g) || []).length;
      }
      
      // Mettre √† jour le niveau maximal observ√©
      maxNestingLevel = Math.max(maxNestingLevel, currentNestingLevel);
      
      // D√©cr√©menter le niveau d'imbrication pour les fermetures de blocs
      if (line.includes('}')) {
        currentNestingLevel -= (line.match(/}/g) || []).length;
      }
    });
    
    // G√©n√©rer le rapport de complexit√©
    complexity = `Complexit√© cyclomatique estim√©e: ${cyclomaticComplexity} (${complexityRating})

`;
    complexity += `D√©tail des structures de contr√¥le :
`;
    complexity += `- ${ifCount} if, ${elseIfCount} else if
`;
    complexity += `- ${switchCount} switch, ${caseCount} case
`;
    complexity += `- ${forCount} for, ${foreachCount} foreach, ${whileCount} while, ${doWhileCount} do-while
`;
    complexity += `- ${ternaryCount} op√©rateurs ternaires

`;
    complexity += `Profondeur maximale d'imbrication: ${maxNestingLevel} niveau(x)`;
    
    return complexity;
  }
  
  /**
   * D√©termine le niveau de s√©v√©rit√© bas√© sur la complexit√©
   */
  private determineComplexitySeverity(complexityText: string): 'info' | 'warning' | 'critical' {
    // Extraire la valeur num√©rique de la complexit√©
    const match = complexityText.match(/Complexit√© cyclomatique estim√©e: (\d+)/);
    if (!match) return 'info';
    
    const complexity = parseInt(match[1], 10);
    
    if (complexity <= 10) {
      return 'info';
    } else if (complexity <= 20) {
      return 'warning';
    } else {
      return 'critical';
    }
  }
  
  /**
   * Analyse les risques de s√©curit√© dans le code
   */
  private analyzeSecurityRisks(): { content: string, severity: 'info' | 'warning' | 'critical' } {
    const fileContent = this.fileContent;
    let securityRisks = '';
    let severity: 'info' | 'warning' | 'critical' = 'info';
    
    // Tableau pour stocker les probl√®mes d√©tect√©s
    const issues: { issue: string, severity: 'info' | 'warning' | 'critical' }[] = [];
    
    // V√©rifier les injections SQL
    if (
      (fileContent.includes('mysql_query') || fileContent.includes('mysqli_query')) &&
      (fileContent.includes('$_GET') || fileContent.includes('$_POST') || fileContent.includes('$_REQUEST'))
    ) {
      if (!fileContent.includes('prepare') && !fileContent.includes('real_escape_string')) {
        issues.push({
          issue: "Risque d'injection SQL : utilisation de variables non √©chapp√©es dans les requ√™tes",
          severity: 'critical'
        });
      }
    }
    
    // V√©rifier les failles XSS
    if (
      (fileContent.includes('echo') || fileContent.includes('print')) &&
      (fileContent.includes('$_GET') || fileContent.includes('$_POST') || fileContent.includes('$_REQUEST'))
    ) {
      if (!fileContent.includes('htmlspecialchars') && !fileContent.includes('htmlentities')) {
        issues.push({
          issue: "Risque XSS : affichage de variables utilisateur non √©chapp√©es",
          severity: 'critical'
        });
      }
    }
    
    // V√©rifier l'inclusion de fichiers dynamique
    if (
      (fileContent.includes('include') || fileContent.includes('require')) &&
      (fileContent.includes('$_GET') || fileContent.includes('$_POST') || fileContent.includes('$_REQUEST'))
    ) {
      issues.push({
        issue: "Risque d'inclusion de fichier : inclusion bas√©e sur des param√®tres utilisateur",
        severity: 'critical'
      });
    }
    
    // V√©rifier les variables non initialis√©es
    if (fileContent.match(/\$[a-zA-Z_-ˇ][a-zA-Z0-9_-ˇ]*\s*[^=]/g)) {
      issues.push({
        issue: "Possibles variables non initialis√©es",
        severity: 'warning'
      });
    }
    
    // V√©rifier les mauvaises pratiques de session
    if (fileContent.includes('$_SESSION') && !fileContent.includes('session_start')) {
      issues.push({
        issue: "Utilisation de session sans session_start()",
        severity: 'warning'
      });
    }
    
    // V√©rifier l'utilisation de fonctions d√©pr√©ci√©es
    const deprecatedFunctions = [
      'mysql_connect', 'mysql_query', 'mysql_fetch_array',
      'ereg', 'eregi', 'split',
      'create_function', 'mcrypt_encrypt'
    ];
    
    for (const func of deprecatedFunctions) {
      if (fileContent.includes(func)) {
        issues.push({
          issue: `Utilisation de la fonction d√©pr√©ci√©e ${func}()`,
          severity: 'warning'
        });
      }
    }
    
    // Si des probl√®mes critiques ont √©t√© d√©tect√©s, d√©finir la s√©v√©rit√© √† critical
    if (issues.some(issue => issue.severity === 'critical')) {
      severity = 'critical';
    } else if (issues.some(issue => issue.severity === 'warning')) {
      severity = 'warning';
    }
    
    // G√©n√©rer le rapport de s√©curit√©
    if (issues.length > 0) {
      for (const issue of issues) {
        const icon = issue.severity === 'critical' ? '‚ö†Ô∏è' : '‚ö†';
        securityRisks += `${icon} ${issue.issue}
`;
      }
    } else {
      securityRisks = "Aucun probl√®me de s√©curit√© majeur d√©tect√©.";
    }
    
    return { content: securityRisks, severity };
  }
  
  /**
   * √âvalue la qualit√© g√©n√©rale du code
   */
  private evaluateOverallQuality(): { content: string, severity: 'info' | 'warning' | 'critical' } {
    const fileContent = this.fileContent;
    let overallQuality = '';
    let severity: 'info' | 'warning' | 'critical' = 'info';
    
    // Initialiser les scores
    let debtScore = 0; // 0-100, 100 √©tant la pire dette technique
    
    // D√©tecter les longs blocs de code
    const lines = fileContent.split('
');
    if (lines.length > 500) {
      debtScore += 20;
      overallQuality += "- Fichier tr√®s long (> 500 lignes) : difficile √† maintenir
";
      severity = 'warning';
    } else if (lines.length > 200) {
      debtScore += 10;
      overallQuality += "- Fichier long (> 200 lignes) : pourrait √™tre divis√©
";
    }
    
    // D√©tecter les longues fonctions
    const functionMatches = fileContent.match(/function\s+\w+\s*\([^)]*\)\s*{[^}]*}/g) || [];
    let longFunctionsCount = 0;
    
    functionMatches.forEach(functionCode => {
      const functionLines = functionCode.split('
').length;
      if (functionLines > 50) {
        longFunctionsCount++;
      }
    });
    
    if (longFunctionsCount > 0) {
      debtScore += 15;
      overallQuality += `- ${longFunctionsCount} fonction(s) tr√®s longue(s) (> 50 lignes)
`;
      severity = 'warning';
    }
    
    // D√©tecter l'absence de documentation
    if (!fileContent.includes('/**') && !fileContent.includes('/*')) {
      debtScore += 10;
      overallQuality += "- Absence de documentation ou commentaires
";
    }
    
    // D√©tecter le code mort potentiel
    const commentedCodeBlocks = (fileContent.match(/\/\/.*\w+\s*\(/g) || []).length;
    if (commentedCodeBlocks > 5) {
      debtScore += 5;
      overallQuality += "- Pr√©sence de code comment√© (possible code mort)
";
    }
    
    // D√©tecter les variables globales
    const globalVars = (fileContent.match(/global\s+\$/g) || []).length;
    if (globalVars > 0) {
      debtScore += 10;
      overallQuality += `- Utilisation de ${globalVars} variable(s) globale(s)
`;
    }
    
    // D√©tecter l'orientation objet
    const isOOP = fileContent.includes('class ') && fileContent.includes('function ');
    if (!isOOP) {
      debtScore += 15;
      overallQuality += "- Code non orient√© objet, style proc√©dural
";
    }
    
    // √âvaluer la lisibilit√© (indentation, formatage)
    const inconsistentIndentation = lines.some(line => 
      line.trim().length > 0 && line.length - line.trimLeft().length === 1
    );
    
    if (inconsistentIndentation) {
      debtScore += 5;
      overallQuality += "- Indentation inconsistante
";
    }
    
    // D√©tecter les constantes magiques
    const magicNumbers = fileContent.match(/\W\d+\W/g) || [];
    if (magicNumbers.length > 10) {
      debtScore += 5;
      overallQuality += "- Nombreuses valeurs num√©riques cod√©es en dur
";
    }
    
    // Cat√©goriser la qualit√© g√©n√©rale selon le score de dette
    let qualityRating;
    if (debtScore < 20) {
      qualityRating = "Bonne";
    } else if (debtScore < 40) {
      qualityRating = "Moyenne";
      if (severity === 'info') severity = 'warning';
    } else if (debtScore < 60) {
      qualityRating = "M√©diocre";
      severity = 'warning';
    } else {
      qualityRating = "Mauvaise";
      severity = 'critical';
    }
    
    // Ajouter le score et la conclusion
    const conclusion = `
Score de dette technique: ${debtScore}/100
` +
                      `Qualit√© g√©n√©rale: ${qualityRating}

` +
                      `${this.generateQualityRecommendation(debtScore, qualityRating)}`;
    
    // Si aucun probl√®me n'a √©t√© identifi√©
    if (overallQuality === '') {
      overallQuality = "Aucun probl√®me de qualit√© majeur d√©tect√©.";
    }
    
    return { content: overallQuality + conclusion, severity };
  }
  
  /**
   * G√©n√®re une recommandation bas√©e sur la qualit√© du code
   */
  private generateQualityRecommendation(debtScore: number, qualityRating: string): string {
    if (debtScore < 20) {
      return "Recommendation: Ce code est relativement propre et peut √™tre facilement migr√©.";
    } else if (debtScore < 40) {
      return "Recommendation: Refactorisation l√©g√®re recommand√©e avant migration.";
    } else if (debtScore < 60) {
      return "Recommendation: Refactorisation substantielle n√©cessaire, envisager une r√©√©criture partielle.";
    } else {
      return "Recommendation: R√©√©criture compl√®te recommand√©e plut√¥t que migration.";
    }
  }
}
