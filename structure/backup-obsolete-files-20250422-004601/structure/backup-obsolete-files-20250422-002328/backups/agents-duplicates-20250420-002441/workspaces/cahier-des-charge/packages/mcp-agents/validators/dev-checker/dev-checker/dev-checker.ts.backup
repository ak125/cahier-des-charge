import { execSync } from 'child_process';
import fs from 'fs';
import path from 'path';

// Configuration
const CONFIG = {
  rootDir: process.cwd(),
  remixDir: path.join(process.cwd(), 'remix-nestjs-monorepo/apps/frontend'),
  nestjsDir: path.join(process.cwd(), 'remix-nestjs-monorepo/apps/backend'),
  prismaDir: path.join(process.cwd(), 'prisma'),
  aliasPatterns: ['@/', '@backend/', '@frontend/', '~/', 'app/'],
  outputReportPath: path.join(process.cwd(), 'reports/dev_check_report.md'),
  outputFailuresPath: path.join(process.cwd(), 'reports/dev_check_failures.json'),
  outputLogsPath: path.join(process.cwd(), 'logs/dev_check_logs.txt'),
  ignorePatterns: ['node_modules', '.git', 'dist', 'build', '.cache'],
  criticalFiles: ['schema.prisma', 'controller.ts', 'routes.ts', 'app.module.ts'],
  autoFixImports: true,
  autoFixRoutes: true,
};

// Adaptation pour le format d'agent MCP
export const devCheckerAgent = {
  name: 'dev-checker',
  description: 'Valide les int√©grations frontend/backend/orm dans le monorepo',
  category: 'quality',
  
  async run(options?: { autoFix?: boolean }): Promise<{ status: string; logs: string[]; fixes?: any[] }> {
    const logs: string[] = [];
    const fixes: any[] = [];
    const autoFix = options?.autoFix || CONFIG.autoFixImports || CONFIG.autoFixRoutes;

    try {
      logs.push('üöÄ Lancement du contr√¥le d\'int√©gration MCP...');
      
      if (autoFix) {
        logs.push('üõ†Ô∏è Mode correction automatique activ√©');
      }

      // 1. V√©rification des imports alias @/
      logs.push('üîç V√©rification des imports avec alias @/...');
      try {
        const aliasScan = execSync(`grep -r "from '@/" --include="*.ts" --include="*.tsx" apps/ packages/`, {
          stdio: 'pipe',
        }).toString();
        logs.push('‚úÖ Imports avec alias @/ d√©tect√©s et analys√©s');
        
        // V√©rifier la validit√© des imports en analysant le r√©sultat
        const invalidImports = validateAliasImports(aliasScan);
        if (invalidImports.length > 0) {
          for (const invalidImport of invalidImports) {
            logs.push(`‚ö†Ô∏è Import suspect : ${invalidImport.file}:${invalidImport.line} - ${invalidImport.import}`);
            
            if (autoFix && CONFIG.autoFixImports) {
              const fixResult = await fixImportAlias(invalidImport.file, invalidImport.line, invalidImport.import);
              if (fixResult.fixed) {
                logs.push(`üõ†Ô∏è Correction automatique appliqu√©e : ${fixResult.message}`);
                fixes.push(fixResult);
              } else {
                logs.push(`‚ùå Impossible de corriger automatiquement : ${fixResult.message}`);
              }
            }
          }
        } else {
          logs.push('‚úÖ Tous les imports avec alias semblent valides');
        }
      } catch (error) {
        if (error.status === 1 && !error.stdout.length) {
          logs.push('‚úÖ Aucun import avec alias @/ anormal d√©tect√©');
        } else {
          logs.push(`‚ùå Erreur lors de la v√©rification des imports : ${error.message}`);
        }
      }

      // 2. Validation des routes Remix
      logs.push('üîç V√©rification des routes Remix...');
      try {
        const remixFiles = execSync(`find apps/frontend/app/routes -name "*.tsx"`, {
          stdio: 'pipe',
        }).toString();
        
        const routeFiles = remixFiles.split('\n').filter(Boolean);
        logs.push(`‚úÖ ${routeFiles.length} routes Remix d√©tect√©es`);
        
        // V√©rifier que les routes sont correctement structur√©es
        if (routeFiles.length > 0) {
          let validRoutesCount = 0;
          let fixedRoutesCount = 0;
          for (const routeFile of routeFiles) {
            const validationResult = validateRemixRoute(routeFile);
            if (validationResult.valid) {
              validRoutesCount++;
            } else {
              logs.push(`‚ö†Ô∏è Route mal structur√©e : ${routeFile} - ${validationResult.reason}`);
              
              if (autoFix && CONFIG.autoFixRoutes) {
                const fixResult = await fixRemixRoute(routeFile, validationResult.reason);
                if (fixResult.fixed) {
                  logs.push(`üõ†Ô∏è Correction automatique de route : ${fixResult.message}`);
                  fixes.push(fixResult);
                  fixedRoutesCount++;
                } else {
                  logs.push(`‚ùå Impossible de corriger la route : ${fixResult.message}`);
                }
              }
            }
          }
          logs.push(`‚úÖ ${validRoutesCount}/${routeFiles.length} routes correctement structur√©es`);
          if (fixedRoutesCount > 0) {
            logs.push(`üõ†Ô∏è ${fixedRoutesCount} routes corrig√©es automatiquement`);
          }
        }
      } catch (error) {
        logs.push(`‚ùå Erreur lors de la v√©rification des routes Remix : ${error.message}`);
      }

      // 3. Validation du fichier Prisma
      logs.push('üîç V√©rification du fichier schema.prisma...');
      try {
        execSync(`npx prisma validate --schema=prisma/schema.prisma`);
        logs.push('‚úÖ schema.prisma valide');
      } catch (error) {
        logs.push(`‚ùå Erreur schema.prisma : ${error.message}`);
        
        // Pas de correction automatique pour Prisma car trop complexe et risqu√©
        logs.push('‚ö†Ô∏è Les erreurs du sch√©ma Prisma n√©cessitent une correction manuelle');
      }

      // 4. Compilation TypeScript √† sec
      logs.push('üîç V√©rification compilation TypeScript...');
      try {
        execSync(`tsc --noEmit`, { stdio: 'pipe' });
        logs.push('‚úÖ Compilation TypeScript r√©ussie');
      } catch (error) {
        // Extraire les erreurs de compilation importantes
        const errorOutput = error.message || error.stdout;
        const errorCount = (errorOutput.match(/error TS\d+/g) || []).length;
        logs.push(`‚ùå Compilation TypeScript : ${errorCount} erreurs d√©tect√©es`);
        
        // Ajouter les 5 premi√®res erreurs pour plus de visibilit√©
        const errorLines = errorOutput.split('\n')
          .filter(line => line.includes('error TS'))
          .slice(0, 5);
        
        for (const errorLine of errorLines) {
          logs.push(`  - ${errorLine.trim()}`);
        }
        
        if (errorCount > 5) {
          logs.push(`  - et ${errorCount - 5} autres erreurs...`);
        }
      }

      // G√©n√©rer un rapport d√©taill√©
      generateDetailedReport(logs, fixes);
      
      return { 
        status: 'success', 
        logs,
        fixes: fixes.length > 0 ? fixes : undefined
      };
    } catch (error) {
      logs.push('‚ùå Erreur d√©tect√©e : ' + error.message);
      return { status: 'error', logs };
    }
  },
};

// Nouvelles interfaces pour le support d'auto-correction
interface ImportIssue {
  file: string;
  line: number;
  import: string;
}

interface FixResult {
  fixed: boolean;
  message: string;
  file?: string;
  type?: 'import' | 'route' | 'other';
  originalContent?: string;
  newContent?: string;
}

interface RouteValidationResult {
  valid: boolean;
  reason?: string; 
}

// Fonctions auxiliaires am√©lior√©es
function validateAliasImports(scanOutput: string): ImportIssue[] {
  const invalidImports: ImportIssue[] = [];
  const lines = scanOutput.split('\n').filter(Boolean);
  
  for (const line of lines) {
    // Format typique: "file.ts:10:import X from '@/path'"
    const parts = line.split(':');
    if (parts.length >= 2) {
      const file = parts[0];
      const lineNumber = parseInt(parts[1], 10);
      const importStatement = parts.slice(2).join(':').trim();
      
      // V√©rifier si l'import est bien form√© et pointe vers un fichier existant
      if (!hasValidTsConfigPath() || !isValidImport(file, importStatement)) {
        invalidImports.push({
          file,
          line: lineNumber,
          import: importStatement
        });
      }
    }
  }
  
  return invalidImports;
}

function hasValidTsConfigPath(): boolean {
  try {
    const tsConfigPath = path.join(process.cwd(), 'tsconfig.json');
    if (!fs.existsSync(tsConfigPath)) return false;
    
    const tsConfig = JSON.parse(fs.readFileSync(tsConfigPath, 'utf8'));
    return !!tsConfig.compilerOptions?.paths?.['@/*'];
  } catch (error) {
    return false;
  }
}

function isValidImport(filePath: string, importStatement: string): boolean {
  try {
    // Extraire le chemin d'import
    const match = importStatement.match(/from\s+['"](@\/.+?)['"]/);
    if (!match) return true; // Pas un import avec alias @/
    
    const importPath = match[1];
    
    // V√©rifier dans tsconfig.json comment l'alias @/ est mapp√©
    const tsConfigPath = path.join(process.cwd(), 'tsconfig.json');
    const tsConfig = JSON.parse(fs.readFileSync(tsConfigPath, 'utf8'));
    const aliasMapping = tsConfig.compilerOptions?.paths?.['@/*']?.[0];
    
    if (!aliasMapping) return false;
    
    // Convertir l'import en chemin relatif au syst√®me de fichiers
    const relativePath = importPath.replace('@/', '');
    const targetPath = path.join(process.cwd(), aliasMapping.replace('*', ''), relativePath);
    
    // V√©rifier si le fichier existe avec diff√©rentes extensions
    return fs.existsSync(targetPath) || 
           fs.existsSync(targetPath + '.ts') || 
           fs.existsSync(targetPath + '.tsx') || 
           fs.existsSync(targetPath + '.js') || 
           fs.existsSync(targetPath + '.jsx') || 
           fs.existsSync(path.join(targetPath, 'index.ts')) || 
           fs.existsSync(path.join(targetPath, 'index.tsx')) || 
           fs.existsSync(path.join(targetPath, 'index.js')) || 
           fs.existsSync(path.join(targetPath, 'index.jsx'));
  } catch (error) {
    return false;
  }
}

async function fixImportAlias(filePath: string, lineNumber: number, importStatement: string): Promise<FixResult> {
  try {
    const content = fs.readFileSync(filePath, 'utf8');
    const lines = content.split('\n');
    
    if (lineNumber < 0 || lineNumber >= lines.length) {
      return { 
        fixed: false, 
        message: `Num√©ro de ligne ${lineNumber} invalide pour le fichier ${filePath}` 
      };
    }
    
    const line = lines[lineNumber];
    
    // Extraire le chemin d'import
    const match = line.match(/from\s+['"](@\/.+?)['"]/);
    if (!match) {
      return { 
        fixed: false, 
        message: 'Format d\'import non reconnu' 
      };
    }
    
    const importPath = match[1];
    
    // Essayer de trouver le bon chemin pour l'import
    const tsConfigPath = path.join(process.cwd(), 'tsconfig.json');
    const tsConfig = JSON.parse(fs.readFileSync(tsConfigPath, 'utf8'));
    const aliasMapping = tsConfig.compilerOptions?.paths?.['@/*']?.[0];
    
    if (!aliasMapping) {
      return { 
        fixed: false, 
        message: 'Alias @/ non d√©fini dans tsconfig.json' 
      };
    }
    
    // Convertir l'import en chemin relatif au syst√®me de fichiers
    const relativePath = importPath.replace('@/', '');
    const basePath = path.join(process.cwd(), aliasMapping.replace('*', ''));
    
    // Rechercher le fichier avec diff√©rentes extensions
    const possibleExtensions = ['.ts', '.tsx', '.js', '.jsx', ''];
    let correctPath = null;
    let isDirectory = false;
    
    for (const ext of possibleExtensions) {
      const targetPath = path.join(basePath, relativePath + ext);
      if (fs.existsSync(targetPath)) {
        correctPath = relativePath + ext;
        isDirectory = fs.statSync(targetPath).isDirectory();
        break;
      }
    }
    
    // V√©rifier s'il s'agit d'un r√©pertoire avec un fichier index
    if (isDirectory || !correctPath) {
      for (const ext of ['.ts', '.tsx', '.js', '.jsx']) {
        const indexPath = path.join(basePath, relativePath, 'index' + ext);
        if (fs.existsSync(indexPath)) {
          correctPath = path.join(relativePath, 'index' + ext);
          break;
        }
      }
    }
    
    if (!correctPath) {
      return { 
        fixed: false, 
        message: `Impossible de trouver un chemin valide pour l'import ${importPath}` 
      };
    }
    
    // Corriger l'import
    const correctedImport = line.replace(importPath, '@/' + correctPath.replace(/\\/g, '/'));
    lines[lineNumber] = correctedImport;
    
    // √âcrire les modifications dans le fichier
    fs.writeFileSync(filePath, lines.join('\n'));
    
    return { 
      fixed: true, 
      message: `Import corrig√© dans ${filePath}:${lineNumber}`, 
      file: filePath,
      type: 'import',
      originalContent: line,
      newContent: correctedImport
    };
  } catch (error) {
    return { 
      fixed: false, 
      message: `Erreur lors de la correction de l'import: ${error.message}` 
    };
  }
}

function validateRemixRoute(routePath: string): RouteValidationResult {
  try {
    const content = fs.readFileSync(routePath, 'utf8');
    
    // V√©rifier la pr√©sence d'un export par d√©faut (n√©cessaire pour les routes Remix)
    if (!content.includes('export default') && 
        !content.includes('export { default }')) {
      return { 
        valid: false, 
        reason: 'missing_default_export' 
      };
    }
    
    // V√©rifier si les exports n√©cessaires pour les actions/loaders sont pr√©sents
    const needsLoader = content.includes('useLoaderData') && !content.includes('export const loader');
    if (needsLoader) {
      return { 
        valid: false, 
        reason: 'missing_loader' 
      };
    }
    
    const needsAction = content.includes('useActionData') && !content.includes('export const action');
    if (needsAction) {
      return { 
        valid: false, 
        reason: 'missing_action' 
      };
    }
    
    // V√©rifier la convention de nommage des fichiers de route
    const fileName = path.basename(routePath);
    const validPattern = /^(\$.+|_?.+|index)\.tsx$/;
    
    if (!validPattern.test(fileName)) {
      return { 
        valid: false, 
        reason: 'invalid_filename' 
      };
    }
    
    return { valid: true };
  } catch (error) {
    return { 
      valid: false, 
      reason: `error_reading_file: ${error.message}` 
    };
  }
}

async function fixRemixRoute(routePath: string, reason: string): Promise<FixResult> {
  try {
    const content = fs.readFileSync(routePath, 'utf8');
    let newContent = content;
    let fixed = false;
    let message = '';
    
    switch(reason) {
      case 'missing_default_export':
        // Ajouter un export par d√©faut si le composant existe mais n'est pas export√©
        const componentNameMatch = content.match(/function\s+([A-Z][a-zA-Z0-9_]*)\s*\(/);
        if (componentNameMatch) {
          const componentName = componentNameMatch[1];
          if (!content.includes(`export default ${componentName}`)) {
            newContent = content + `\n\nexport default ${componentName};\n`;
            message = `Ajout de 'export default ${componentName}' √† la route ${routePath}`;
            fixed = true;
          }
        } else {
          message = 'Impossible de trouver le nom du composant pour ajouter export default';
        }
        break;
        
      case 'missing_loader':
        // Ajouter un loader minimal
        if (!content.includes('export const loader')) {
          const loaderCode = `
export const loader = async ({ request, params }: LoaderFunctionArgs) => {
  // TODO: Impl√©mentez le loader correctement
  return json({});
};
`;
          // Ajouter les imports n√©cessaires s'ils n'existent pas
          if (!content.includes('import { json }')) {
            newContent = content.replace(/import.*?from.*?;/, (match) => 
              match + '\nimport { json, type LoaderFunctionArgs } from "@remix-run/node";'
            );
          }
          
          // Ajouter le loader avant le composant
          newContent = newContent.replace(/function\s+([A-Z][a-zA-Z0-9_]*)\s*\(/, (match) => 
            loaderCode + '\n' + match
          );
          
          message = `Ajout d'un loader minimal √† la route ${routePath}`;
          fixed = true;
        }
        break;
        
      case 'missing_action':
        // Ajouter une action minimale
        if (!content.includes('export const action')) {
          const actionCode = `
export const action = async ({ request, params }: ActionFunctionArgs) => {
  // TODO: Impl√©mentez l'action correctement
  return json({});
};
`;
          // Ajouter les imports n√©cessaires s'ils n'existent pas
          if (!content.includes('import { json }')) {
            newContent = content.replace(/import.*?from.*?;/, (match) => 
              match + '\nimport { json, type ActionFunctionArgs } from "@remix-run/node";'
            );
          }
          
          // Ajouter l'action avant le composant
          newContent = newContent.replace(/function\s+([A-Z][a-zA-Z0-9_]*)\s*\(/, (match) => 
            actionCode + '\n' + match
          );
          
          message = `Ajout d'une action minimale √† la route ${routePath}`;
          fixed = true;
        }
        break;
        
      case 'invalid_filename':
        // Renommer le fichier selon les conventions Remix
        const dirName = path.dirname(routePath);
        const fileName = path.basename(routePath);
        
        // Appliquer la convention de nommage correcte
        let newFileName = fileName;
        
        // Si c'est une route dynamique mais sans $
        if (fileName.includes('[') && fileName.includes(']') && !fileName.startsWith('$')) {
          newFileName = '$' + fileName.replace(/\[([^\]]+)\]/g, '$1');
        }
        
        // Si c'est une route de pr√©sentation sans _
        if (!fileName.startsWith('_') && 
            !fileName.startsWith('$') && 
            !fileName.startsWith('index') && 
            content.includes('Outlet')) {
          newFileName = '_' + fileName;
        }
        
        if (newFileName !== fileName) {
          const newPath = path.join(dirName, newFileName);
          fs.renameSync(routePath, newPath);
          message = `Fichier renomm√© de ${fileName} vers ${newFileName}`;
          fixed = true;
        } else {
          message = 'Impossible de d√©terminer le bon format de nom pour le fichier';
        }
        break;
        
      default:
        message = `Type d'erreur non pris en charge: ${reason}`;
    }
    
    if (fixed && newContent !== content) {
      fs.writeFileSync(routePath, newContent);
    }
    
    return { 
      fixed, 
      message, 
      file: routePath,
      type: 'route',
      originalContent: content,
      newContent: newContent
    };
  } catch (error) {
    return { 
      fixed: false, 
      message: `Erreur lors de la correction de la route: ${error.message}` 
    };
  }
}

function generateDetailedReport(logs: string[], fixes: any[] = []): void {
  try {
    // Cr√©er le r√©pertoire de rapports s'il n'existe pas
    const reportsDir = path.dirname(CONFIG.outputReportPath);
    if (!fs.existsSync(reportsDir)) {
      fs.mkdirSync(reportsDir, { recursive: true });
    }
    
    // R√©cup√©rer la date pour le rapport
    const now = new Date();
    const dateStr = now.toISOString().replace(/[:.]/g, '-').slice(0, 19);
    
    // G√©n√©rer le contenu du rapport au format Markdown
    let reportContent = `# Rapport de v√©rification du code - ${dateStr}\n\n`;
    
    // Ajouter un r√©sum√©
    const errorCount = logs.filter(log => log.includes('‚ùå')).length;
    const warningCount = logs.filter(log => log.includes('‚ö†Ô∏è')).length;
    const successCount = logs.filter(log => log.includes('‚úÖ')).length;
    const fixCount = fixes.length;
    
    reportContent += `## üìä R√©sum√©\n\n`;
    reportContent += `| Cat√©gorie | Nombre |\n`;
    reportContent += `|-----------|--------|\n`;
    reportContent += `| ‚úÖ Succ√®s | ${successCount} |\n`;
    reportContent += `| ‚ö†Ô∏è Avertissements | ${warningCount} |\n`;
    reportContent += `| ‚ùå Erreurs | ${errorCount} |\n`;
    
    if (fixCount > 0) {
      reportContent += `| üõ†Ô∏è Corrections automatiques | ${fixCount} |\n`;
    }
    
    reportContent += `\n`;
    
    // Ajouter les d√©tails
    reportContent += `## üîç D√©tails\n\n`;
    
    let currentSection = '';
    for (const log of logs) {
      let formattedLog = log;
      
      if (log.startsWith('üîç') || log.startsWith('üöÄ')) {
        currentSection = log.replace('üîç ', '').replace('üöÄ ', '');
        formattedLog = `### ${log}\n`;
      } else if (log.startsWith('‚úÖ')) {
        formattedLog = `- ${log}\n`;
      } else if (log.startsWith('‚ùå')) {
        formattedLog = `- **${log}**\n`;
      } else if (log.startsWith('‚ö†Ô∏è')) {
        formattedLog = `- _${log}_\n`;
      } else if (log.startsWith('üõ†Ô∏è')) {
        formattedLog = `- ${log}\n`;
      } else if (log.startsWith('  -')) {
        formattedLog = `  ${log}\n`;
      } else {
        formattedLog = `- ${log}\n`;
      }
      
      reportContent += formattedLog;
    }
    
    // Ajouter les d√©tails des corrections automatiques
    if (fixes.length > 0) {
      reportContent += `\n## üõ†Ô∏è Corrections automatiques\n\n`;
      
      fixes.forEach((fix, index) => {
        reportContent += `### ${index + 1}. ${fix.message}\n\n`;
        reportContent += `- **Fichier**: \`${fix.file}\`\n`;
        reportContent += `- **Type**: ${fix.type === 'import' ? 'Import' : fix.type === 'route' ? 'Route Remix' : 'Autre'}\n`;
        
        if (fix.originalContent && fix.newContent) {
          reportContent += `\n**Avant**:\n\`\`\`typescript\n${fix.originalContent}\n\`\`\`\n\n`;
          reportContent += `**Apr√®s**:\n\`\`\`typescript\n${fix.newContent}\n\`\`\`\n\n`;
        }
      });
    }
    
    // Ajouter des recommandations
    const hasPrismaErrors = logs.some(log => log.includes('schema.prisma') && log.includes('‚ùå'));
    const hasTypeScriptErrors = logs.some(log => log.includes('Compilation TypeScript') && log.includes('‚ùå'));
    
    if (hasPrismaErrors || hasTypeScriptErrors) {
      reportContent += `\n## üß∞ Recommandations\n\n`;
      
      if (hasPrismaErrors) {
        reportContent += `### Erreurs Prisma\n\n`;
        reportContent += `- Ex√©cutez \`npx prisma validate\` pour voir les d√©tails complets des erreurs\n`;
        reportContent += `- Utilisez \`npx prisma format\` pour formatter automatiquement votre sch√©ma\n`;
        reportContent += `- V√©rifiez la coh√©rence des relations entre les mod√®les\n\n`;
      }
      
      if (hasTypeScriptErrors) {
        reportContent += `### Erreurs TypeScript\n\n`;
        reportContent += `- Ex√©cutez \`tsc --noEmit\` pour voir toutes les erreurs TypeScript\n`;
        reportContent += `- Utilisez votre IDE pour naviguer facilement entre les erreurs\n`;
        reportContent += `- V√©rifiez les types import√©s depuis les biblioth√®ques externes\n\n`;
      }
    }
    
    // Ajouter un pied de page
    reportContent += `\n---\n\n`;
    reportContent += `Rapport g√©n√©r√© le ${now.toLocaleString()} par l'agent dev-checker.\n`;
    
    // √âcrire le rapport dans un fichier
    fs.writeFileSync(CONFIG.outputReportPath, reportContent);
    
    // √âcrire les donn√©es des √©checs au format JSON pour une utilisation ult√©rieure
    const failures = {
      timestamp: now.toISOString(),
      errors: logs.filter(log => log.includes('‚ùå')),
      warnings: logs.filter(log => log.includes('‚ö†Ô∏è')),
      fixes: fixes,
      summary: {
        errorCount,
        warningCount,
        successCount,
        fixCount
      }
    };
    
    fs.writeFileSync(CONFIG.outputFailuresPath, JSON.stringify(failures, null, 2));
    
    console.log(`üìù Rapport g√©n√©r√©: ${CONFIG.outputReportPath}`);
  } catch (error) {
    console.error(`Erreur lors de la g√©n√©ration du rapport: ${error.message}`);
  }
}

// Exporter les fonctions pour les tests et la r√©utilisation
export {
  validateAliasImports,
  validateRemixRoute,
  fixImportAlias,
  fixRemixRoute,
  generateDetailedReport,
  CONFIG,
};

// Ex√©cution directe si appel√© comme script
if (require.main === module) {
  devCheckerAgent.run({ autoFix: process.argv.includes('--fix') })
    .then(result => {
      console.log(result.logs.join('\n'));
      if (result.fixes && result.fixes.length > 0) {
        console.log(`\nüõ†Ô∏è ${result.fixes.length} corrections automatiques appliqu√©es`);
      }
      process.exit(result.status === 'success' ? 0 : 1);
    })
    .catch(error => {
      console.error('Erreur:', error);
      process.exit(1);
    });
}