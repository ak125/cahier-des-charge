#!/usr/bin/env ts-node
/**
 * üß† prisma-to-zod.ts ‚Äî G√©n√©rateur automatique de sch√©mas Zod √† partir de Prisma
 * 
 * Cet outil analyse votre sch√©ma Prisma et g√©n√®re automatiquement les sch√©mas
 * Zod correspondants pour la validation c√¥t√© client et serveur.
 */

import * as fs from 'fs/promises';
import * as path from 'path';
import { execSync } from 'child_process';
import * as minimist from 'minimist';
import * as prettier from 'prettier';
import { BaseAgent } from './core/interfaces/base-agent';
import { BusinessAgent } from './core/interfaces/business';

interface CliOptions {
  /**
   * Chemin vers le sch√©ma Prisma
   */
  schemaPath: string;

  /**
   * Dossier de sortie pour les sch√©mas Zod
   */
  outputDir: string;

  /**
   * Pr√©fixe pour les imports Zod
   */
  importPrefix?: string;

  /**
   * G√©n√©ration ou non de sch√©mas pour les relations
   */
  withRelations?: boolean;

  /**
   * S√©paration des sch√©mas par mod√®le
   */
  splitByModel?: boolean;
}

/**
 * Type de champ Prisma
 */
interface PrismaField {
  name: string;
  type: string;
  isRequired: boolean;
  isArray: boolean;
  isId: boolean;
  isUnique: boolean;
  hasDefault: boolean;
  isReadonly: boolean;
  isRelation: boolean;
  relationName?: string;
  relationFromFields?: string[];
  relationToFields?: string[];
  relationType?: 'object' | 'array';
  documentation?: string;
}

/**
 * Mod√®le Prisma
 */
interface PrismaModel {
  name: string;
  fields: PrismaField[];
  documentation?: string;
  isEnum?: boolean;
  enumValues?: string[];
}

/**
 * Sch√©ma Prisma
 */
interface PrismaSchema {
  models: PrismaModel[];
  enums: PrismaModel[];
}

/**
 * Configuration pour la g√©n√©ration
 */
interface GeneratorConfig {
  /**
   * Les champs qui devraient avoir un type sp√©cifique dans Zod
   */
  customTypes: {
    [key: string]: {
      type: string;
      imports?: string[];
    }
  };

  /**
   * Les champs qui devraient avoir une validation sp√©cifique
   */
  customValidations: {
    [modelName: string]: {
      [fieldName: string]: string[];
    }
  };

  /**
   * Les transformations √† appliquer
   */
  transforms: {
    [modelName: string]: {
      [fieldName: string]: string;
    }
  };

  /**
   * Les erreurs √† personnaliser
   */
  customErrors: {
    [modelName: string]: {
      [fieldName: string]: {
        [validationType: string]: string;
      }
    }
  };
}

/**
 * Classe principale pour la g√©n√©ration de sch√©mas Zod √† partir de Prisma
 */
class PrismaToZodGenerator implements BaseAgent, BusinessAgent {
  private schema: PrismaSchema = { models: [], enums: [] };
  private config: GeneratorConfig = {
    customTypes: {},
    customValidations: {},
    transforms: {},
    customErrors: {}
  };
  private logger: Console = console;

  constructor(private options: CliOptions) {}

  /**
   * Point d'entr√©e principal
   */
  public async generate(): Promise<void> {
    this.logger.info('üîç Analyse du sch√©ma Prisma...');

    try {
      // V√©rifier si le sch√©ma Prisma existe
      await fs.access(this.options.schemaPath);

      // Lire le sch√©ma Prisma
      await this.readPrismaSchema();

      // Charger la configuration (si elle existe)
      await this.loadConfig();

      // Cr√©er le dossier de sortie s'il n'existe pas
      await fs.mkdir(this.options.outputDir, { recursive: true });

      // G√©n√©rer les sch√©mas Zod
      await this.generateZodSchemas();

      this.logger.info('‚úÖ G√©n√©ration des sch√©mas Zod termin√©e avec succ√®s!');
    } catch (error) {
      this.logger.error('‚ùå Erreur lors de la g√©n√©ration des sch√©mas Zod:', error);
      throw error;
    }
  }

  /**
   * Lecture du sch√©ma Prisma en utilisant la CLI Prisma
   */
  private async readPrismaSchema(): Promise<void> {
    try {
      // Utiliser prisma-json-schema-generator pour obtenir une repr√©sentation JSON du sch√©ma
      // Cette commande n√©cessite l'installation de prisma-json-schema-generator
      const tempJsonPath = path.join(path.dirname(this.options.outputDir), 'prisma-schema-temp.json');
      
      try {
        execSync(`npx prisma-json-schema-generator --schemaPath ${this.options.schemaPath} --outputPath ${tempJsonPath}`, { 
          stdio: 'inherit' 
        });
        
        const jsonSchema = await fs.readFile(tempJsonPath, 'utf8');
        const parsedSchema = JSON.parse(jsonSchema);
        
        // Extraction des mod√®les
        this.extractModelsFromJsonSchema(parsedSchema);
        
        // Nettoyage
        await fs.unlink(tempJsonPath).catch(() => {});
      } catch (error) {
        // Fallback: Analyser le fichier schema.prisma directement
        this.logger.warn("‚ö†Ô∏è Impossible d'utiliser prisma-json-schema-generator, analyse manuelle du sch√©ma...");
        const content = await fs.readFile(this.options.schemaPath, 'utf8');
        await this.parseSchemaContent(content);
      }
      
      this.logger.info(`‚úÖ Sch√©ma Prisma analys√©: ${this.schema.models.length} mod√®les, ${this.schema.enums.length} enums`);
    } catch (error) {
      this.logger.error('‚ùå Erreur lors de la lecture du sch√©ma Prisma:', error);
      throw error;
    }
  }

  /**
   * Extraction des mod√®les √† partir du sch√©ma JSON
   */
  private extractModelsFromJsonSchema(jsonSchema: any): void {
    const definitions = jsonSchema.definitions || {};
    
    // Parcourir les d√©finitions
    for (const [name, definition] of Object.entries(definitions)) {
      const def = definition as any;
      
      if (def.enum) {
        // C'est une √©num√©ration
        this.schema.enums.push({
          name,
          fields: [],
          isEnum: true,
          enumValues: def.enum,
          documentation: def.description
        });
      } else if (def.properties) {
        // C'est un mod√®le
        const fields: PrismaField[] = [];
        
        // Parcourir les propri√©t√©s
        for (const [fieldName, fieldDef] of Object.entries(def.properties || {})) {
          const field = fieldDef as any;
          const required = (def.required || []).includes(fieldName);
          
          // D√©tecter si c'est une relation
          const isRelation = field.$ref || (field.items && field.items.$ref);
          let relationType: 'object' | 'array' | undefined;
          let relationName: string | undefined;
          
          if (isRelation) {
            if (field.$ref) {
              relationType = 'object';
              relationName = field.$ref.replace('#/definitions/', '');
            } else if (field.items && field.items.$ref) {
              relationType = 'array';
              relationName = field.items.$ref.replace('#/definitions/', '');
            }
          }
          
          fields.push({
            name: fieldName,
            type: this.getFieldType(field),
            isRequired: required,
            isArray: field.type === 'array',
            isId: field['x-id'] === true,
            isUnique: field['x-unique'] === true,
            hasDefault: field.default !== undefined,
            isReadonly: field.readOnly === true,
            isRelation,
            relationName,
            relationType,
            documentation: field.description
          });
        }
        
        this.schema.models.push({
          name,
          fields,
          documentation: def.description
        });
      }
    }
  }

  /**
   * Obtenir le type d'un champ √† partir de sa d√©finition JSON
   */
  private getFieldType(field: any): string {
    if (field.$ref) {
      return field.$ref.replace('#/definitions/', '');
    } else if (field.type === 'array' && field.items) {
      if (field.items.$ref) {
        return `${field.items.$ref.replace('#/definitions/', '')}[]`;
      } else {
        return `${field.items.type}[]`;
      }
    } else if (field.type) {
      return field.type;
    } else {
      return 'string';
    }
  }

  /**
   * Analyse manuelle du contenu du sch√©ma Prisma
   */
  private async parseSchemaContent(content: string): Promise<void> {
    // Expression r√©guli√®re pour extraire les mod√®les
    const modelRegex = /model\s+(\w+)\s*{([^}]*)}/g;
    let modelMatch;
    
    while ((modelMatch = modelRegex.exec(content)) !== null) {
      const modelName = modelMatch[1];
      const modelBody = modelMatch[2];
      const fields: PrismaField[] = [];
      
      // Expression r√©guli√®re pour extraire les champs
      const fieldLines = modelBody.split('\n').map(line => line.trim()).filter(line => line && !line.startsWith('//'));
      
      for (const line of fieldLines) {
        const fieldMatch = line.match(/(\w+)\s+(\w+)(\?)?(\[\])?(.+)?/);
        if (fieldMatch) {
          const fieldName = fieldMatch[1];
          const fieldType = fieldMatch[2];
          const isRequired = !fieldMatch[3];
          const isArray = !!fieldMatch[4];
          const rest = fieldMatch[5] || '';
          
          // V√©rifier les attributs suppl√©mentaires
          const isId = rest.includes('@id');
          const isUnique = rest.includes('@unique');
          const hasDefault = rest.includes('@default');
          
          // V√©rifier si c'est une relation
          const isRelation = rest.includes('@relation');
          let relationName: string | undefined;
          let relationType: 'object' | 'array' | undefined;
          
          if (isRelation) {
            // Extraire le nom de la relation
            const relationMatch = rest.match(/@relation\([^)]*name:\s*["']([^"']+)["']/);
            relationName = relationMatch ? relationMatch[1] : undefined;
            
            // D√©terminer le type de relation
            relationType = isArray ? 'array' : 'object';
          }
          
          fields.push({
            name: fieldName,
            type: fieldType,
            isRequired,
            isArray,
            isId,
            isUnique,
            hasDefault,
            isReadonly: false,
            isRelation,
            relationName,
            relationType
          });
        }
      }
      
      this.schema.models.push({
        name: modelName,
        fields
      });
    }
    
    // Expression r√©guli√®re pour extraire les enums
    const enumRegex = /enum\s+(\w+)\s*{([^}]*)}/g;
    let enumMatch;
    
    while ((enumMatch = enumRegex.exec(content)) !== null) {
      const enumName = enumMatch[1];
      const enumBody = enumMatch[2];
      
      // Extraire les valeurs de l'enum
      const enumValues = enumBody.split('\n')
        .map(line => line.trim())
        .filter(line => line && !line.startsWith('//'))
        .map(line => line.replace(/,$/, ''));
      
      this.schema.enums.push({
        name: enumName,
        fields: [],
        isEnum: true,
        enumValues
      });
    }
  }

  /**
   * Charger la configuration pour la g√©n√©ration
   */
  private async loadConfig(): Promise<void> {
    const configPath = path.join(path.dirname(this.options.outputDir), 'prisma-to-zod.config.json');
    
    try {
      await fs.access(configPath);
      const content = await fs.readFile(configPath, 'utf8');
      this.config = JSON.parse(content);
      this.logger.info('‚úÖ Configuration charg√©e avec succ√®s');
    } catch (error) {
      this.logger.warn('‚ö†Ô∏è Pas de fichier de configuration trouv√©, utilisation des param√®tres par d√©faut');
      // Cr√©er une configuration par d√©faut
      this.config = {
        customTypes: {
          DateTime: {
            type: 'z.string().datetime()',
            imports: []
          },
          Json: {
            type: 'z.record(z.any())',
            imports: []
          },
          Decimal: {
            type: 'z.number()',
            imports: []
          },
          BigInt: {
            type: 'z.bigint()',
            imports: []
          },
          Bytes: {
            type: 'z.instanceof(Buffer)',
            imports: []
          }
        },
        customValidations: {},
        transforms: {},
        customErrors: {}
      };
    }
  }

  /**
   * G√©n√©rer les sch√©mas Zod
   */
  private async generateZodSchemas(): Promise<void> {
    if (this.options.splitByModel) {
      // G√©n√©rer un fichier par mod√®le
      await this.generateSplitSchemas();
    } else {
      // G√©n√©rer un seul fichier pour tous les mod√®les
      await this.generateCombinedSchema();
    }
  }

  /**
   * G√©n√©rer un fichier de sch√©ma pour chaque mod√®le
   */
  private async generateSplitSchemas(): Promise<void> {
    // Cr√©er le dossier pour les sch√©mas
    const schemasDir = path.join(this.options.outputDir, 'schemas');
    await fs.mkdir(schemasDir, { recursive: true });
    
    // Cr√©er un fichier d'index pour exporter tous les sch√©mas
    let indexContent = `// G√©n√©r√© automatiquement par prisma-to-zod.ts - ne pas modifier manuellement\n\n`;
    
    // G√©n√©rer les sch√©mas pour les enums
    for (const enumModel of this.schema.enums) {
      const { name } = enumModel;
      const fileName = `${this.camelToKebab(name)}.schema.ts`;
      const filePath = path.join(schemasDir, fileName);
      
      // G√©n√©rer le contenu du sch√©ma
      const content = this.generateEnumSchema(enumModel);
      
      // √âcrire le fichier
      await this.writeFormattedFile(filePath, content);
      
      // Mettre √† jour le fichier d'index
      indexContent += `export * from './schemas/${this.camelToKebab(name)}.schema';\n`;
      
      this.logger.info(`‚úÖ Sch√©ma Zod g√©n√©r√© pour l'enum ${name}`);
    }
    
    // G√©n√©rer les sch√©mas pour les mod√®les
    for (const model of this.schema.models) {
      const { name } = model;
      const fileName = `${this.camelToKebab(name)}.schema.ts`;
      const filePath = path.join(schemasDir, fileName);
      
      // G√©n√©rer le contenu du sch√©ma
      const content = this.generateModelSchema(model);
      
      // √âcrire le fichier
      await this.writeFormattedFile(filePath, content);
      
      // Mettre √† jour le fichier d'index
      indexContent += `export * from './schemas/${this.camelToKebab(name)}.schema';\n`;
      
      this.logger.info(`‚úÖ Sch√©ma Zod g√©n√©r√© pour le mod√®le ${name}`);
    }
    
    // √âcrire le fichier d'index
    const indexPath = path.join(this.options.outputDir, 'index.ts');
    await this.writeFormattedFile(indexPath, indexContent);
    
    this.logger.info(`‚úÖ Fichier d'index g√©n√©r√©`);
  }

  /**
   * G√©n√©rer un fichier combin√© pour tous les sch√©mas
   */
  private async generateCombinedSchema(): Promise<void> {
    let content = `// G√©n√©r√© automatiquement par prisma-to-zod.ts - ne pas modifier manuellement
import { z } from 'zod';\n\n`;
    
    // Imports personnalis√©s
    const customImports = new Set<string>();
    
    // Ajouter les imports personnalis√©s des types
    for (const customType of Object.values(this.config.customTypes)) {
      if (customType.imports && customType.imports.length > 0) {
        for (const importStatement of customType.imports) {
          customImports.add(importStatement);
        }
      }
    }
    
    // Ajouter les imports personnalis√©s
    if (customImports.size > 0) {
      customImports.forEach(importStatement => {
        content += `${importStatement}\n`;
      });
      content += '\n';
    }
    
    // G√©n√©rer les sch√©mas pour les enums
    for (const enumModel of this.schema.enums) {
      content += this.generateEnumSchema(enumModel, false);
      content += '\n\n';
    }
    
    // G√©n√©rer les sch√©mas pour les mod√®les
    for (const model of this.schema.models) {
      content += this.generateModelSchema(model, false);
      content += '\n\n';
    }
    
    // √âcrire le fichier
    const filePath = path.join(this.options.outputDir, 'zod-schemas.ts');
    await this.writeFormattedFile(filePath, content);
    
    this.logger.info(`‚úÖ Sch√©mas Zod combin√©s g√©n√©r√©s √† ${filePath}`);
  }

  /**
   * G√©n√©rer le sch√©ma Zod pour un enum
   */
  private generateEnumSchema(enumModel: PrismaModel, withImports: boolean = true): string {
    const { name, enumValues = [] } = enumModel;
    
    let content = '';
    
    // Ajouter les imports si n√©cessaire
    if (withImports) {
      content += `// G√©n√©r√© automatiquement par prisma-to-zod.ts - ne pas modifier manuellement
import { z } from 'zod';\n\n`;
    }
    
    // Documentation
    if (enumModel.documentation) {
      content += `/**\n * ${enumModel.documentation}\n */\n`;
    }
    
    // G√©n√©rer le sch√©ma enum
    content += `export const ${name}Schema = z.enum([\n`;
    enumValues.forEach(value => {
      content += `  '${value}',\n`;
    });
    content += `]);\n\n`;
    
    // Export du type
    content += `export type ${name} = z.infer<typeof ${name}Schema>;\n`;
    
    return content;
  }

  /**
   * G√©n√©rer le sch√©ma Zod pour un mod√®le
   */
  private generateModelSchema(model: PrismaModel, withImports: boolean = true): string {
    const { name, fields } = model;
    
    let content = '';
    
    // Ajouter les imports si n√©cessaire
    if (withImports) {
      content += `// G√©n√©r√© automatiquement par prisma-to-zod.ts - ne pas modifier manuellement
import { z } from 'zod';\n`;
      
      // Ajouter les imports pour les relations si n√©cessaire
      if (this.options.withRelations) {
        const relationImports = new Set<string>();
        
        fields.forEach(field => {
          if (field.isRelation && field.relationName) {
            // V√©rifier si c'est un mod√®le ou un enum
            const isEnum = this.schema.enums.some(e => e.name === field.relationName);
            
            if (!isEnum) {
              relationImports.add(field.relationName!);
            }
          }
        });
        
        if (relationImports.size > 0) {
          // Ajouter les imports
          if (this.options.importPrefix) {
            // Avec pr√©fixe (ex: import { UserSchema } from './user.schema')
            relationImports.forEach(relationName => {
              const fileName = this.camelToKebab(relationName);
              content += `import { ${relationName}Schema } from '${this.options.importPrefix}${fileName}.schema';\n`;
            });
          } else {
            // Sans pr√©fixe (import relatif)
            relationImports.forEach(relationName => {
              const fileName = this.camelToKebab(relationName);
              content += `import { ${relationName}Schema } from './${fileName}.schema';\n`;
            });
          }
          content += '\n';
        }
      }
      
      // Imports personnalis√©s
      const customImports = new Set<string>();
      
      // Parcourir les champs pour trouver les types personnalis√©s
      fields.forEach(field => {
        const customType = this.config.customTypes[field.type];
        if (customType && customType.imports) {
          customType.imports.forEach(importStatement => {
            customImports.add(importStatement);
          });
        }
      });
      
      if (customImports.size > 0) {
        customImports.forEach(importStatement => {
          content += `${importStatement}\n`;
        });
        content += '\n';
      }
    }
    
    // Documentation
    if (model.documentation) {
      content += `/**\n * ${model.documentation}\n */\n`;
    }
    
    // G√©n√©rer le sch√©ma pour la cr√©ation (tous les champs sauf ceux g√©n√©r√©s automatiquement)
    content += `export const ${name}CreateSchema = z.object({\n`;
    
    fields.forEach(field => {
      // Ignorer les champs g√©n√©r√©s automatiquement pour le sch√©ma de cr√©ation
      const isGenerated = field.hasDefault || field.isReadonly || (field.isId && field.hasDefault);
      
      if (!isGenerated || !field.isRequired) {
        content += this.generateFieldSchema(field, model.name, true);
      }
    });
    
    content += `});\n\n`;
    
    // G√©n√©rer le sch√©ma pour la mise √† jour (tous les champs optionnels)
    content += `export const ${name}UpdateSchema = z.object({\n`;
    
    fields.forEach(field => {
      // Ignorer les champs g√©n√©r√©s automatiquement ou en lecture seule pour le sch√©ma de mise √† jour
      const isReadOnly = field.isReadonly || (field.isId && !field.hasDefault);
      
      if (!isReadOnly) {
        content += this.generateFieldSchema(field, model.name, false, true);
      }
    });
    
    content += `});\n\n`;
    
    // G√©n√©rer le sch√©ma complet
    content += `export const ${name}Schema = z.object({\n`;
    
    fields.forEach(field => {
      content += this.generateFieldSchema(field, model.name);
    });
    
    content += `});\n\n`;
    
    // Export des types
    content += `export type ${name}Create = z.infer<typeof ${name}CreateSchema>;\n`;
    content += `export type ${name}Update = z.infer<typeof ${name}UpdateSchema>;\n`;
    content += `export type ${name} = z.infer<typeof ${name}Schema>;\n`;
    
    return content;
  }

  /**
   * G√©n√©rer le sch√©ma Zod pour un champ
   */
  private generateFieldSchema(
    field: PrismaField, 
    modelName: string, 
    isCreateSchema: boolean = false, 
    isUpdateSchema: boolean = false
  ): string {
    const { name, type, isRequired, isArray, isRelation, relationName, relationType } = field;
    
    let fieldSchema = '';
    
    // Documentation
    if (field.documentation) {
      fieldSchema += `  /** ${field.documentation} */\n`;
    }
    
    fieldSchema += `  ${name}: `;
    
    // G√©rer les relations si elles sont activ√©es
    if (isRelation && this.options.withRelations && relationName) {
      // V√©rifier si c'est un enum
      const isEnum = this.schema.enums.some(e => e.name === relationName);
      
      if (isEnum) {
        fieldSchema += `${relationName}Schema`;
      } else if (relationType === 'array') {
        fieldSchema += `z.array(${relationName}Schema)`;
      } else {
        fieldSchema += `${relationName}Schema`;
      }
    } else {
      // G√©rer les types standards
      fieldSchema += this.getZodTypeForField(field, modelName);
    }
    
    // Rendre optionnel si n√©cessaire pour le sch√©ma de cr√©ation et le champ n'est pas requis
    if (isCreateSchema && !isRequired) {
      fieldSchema += '.optional()';
    }
    
    // Rendre optionnel pour le sch√©ma de mise √† jour
    if (isUpdateSchema) {
      fieldSchema += '.optional()';
    }
    
    // Ajouter les validations personnalis√©es
    const customValidations = this.config.customValidations[modelName]?.[name];
    if (customValidations) {
      customValidations.forEach(validation => {
        fieldSchema += `.${validation}`;
      });
    }
    
    // Ajouter les transformations personnalis√©es
    const transform = this.config.transforms[modelName]?.[name];
    if (transform) {
      fieldSchema += `.transform(${transform})`;
    }
    
    // Ajouter les erreurs personnalis√©es
    const customErrors = this.config.customErrors[modelName]?.[name];
    if (customErrors) {
      for (const [validationType, errorMessage] of Object.entries(customErrors)) {
        fieldSchema += `.${validationType}({ message: "${errorMessage}" })`;
      }
    }
    
    fieldSchema += ',\n';
    
    return fieldSchema;
  }

  /**
   * Obtenir le type Zod correspondant √† un type Prisma
   */
  private getZodTypeForField(field: PrismaField, modelName: string): string {
    const { type, isArray, isRequired } = field;
    
    // V√©rifier si c'est un type personnalis√©
    const customType = this.config.customTypes[type];
    if (customType) {
      if (isArray) {
        return `z.array(${customType.type})`;
      }
      return customType.type;
    }
    
    // Types standards
    let zodType: string;
    
    switch (type.toLowerCase()) {
      case 'string':
        zodType = 'z.string()';
        break;
      case 'boolean':
        zodType = 'z.boolean()';
        break;
      case 'int':
      case 'float':
      case 'decimal':
        zodType = 'z.number()';
        break;
      case 'datetime':
        zodType = 'z.date()';
        break;
      case 'json':
        zodType = 'z.record(z.any())';
        break;
      case 'bytes':
        zodType = 'z.instanceof(Buffer)';
        break;
      case 'bigint':
        zodType = 'z.bigint()';
        break;
      default:
        // Si c'est probablement un enum
        const isEnum = this.schema.enums.some(e => e.name === type);
        if (isEnum) {
          zodType = `${type}Schema`;
        } else {
          // Type inconnu, utiliser any
          zodType = 'z.any()';
        }
    }
    
    // G√©rer les arrays
    if (isArray) {
      zodType = `z.array(${zodType})`;
    }
    
    // G√©rer les champs optionnels pour le sch√©ma principal
    if (!isRequired) {
      zodType = `${zodType}.nullable()`;
    }
    
    return zodType;
  }

  /**
   * √âcrire un fichier avec formatage
   */
  private async writeFormattedFile(filePath: string, content: string): Promise<void> {
    try {
      // Formater avec Prettier
      const formattedContent = await prettier.format(content, {
        parser: 'typescript',
        singleQuote: true,
        trailingComma: 'es5',
        tabWidth: 2,
        printWidth: 100,
        semi: true,
      });
      
      // √âcrire le fichier
      await fs.writeFile(filePath, formattedContent, 'utf8');
    } catch (error) {
      // En cas d'erreur de formatage, √©crire le contenu brut
      this.logger.warn(`‚ö†Ô∏è Erreur lors du formatage de ${filePath}, √©criture du contenu brut`);
      await fs.writeFile(filePath, content, 'utf8');
    }
  }

  /**
   * Convertir camelCase en kebab-case
   */
  private camelToKebab(str: string): string {
    return str.replace(/([a-z0-9])([A-Z])/g, '$1-$2').toLowerCase();
  }
}

/**
 * Point d'entr√©e principal
 */
async function main() {
  // Analyser les arguments de ligne de commande
  const args = minimist(process.argv.slice(2));
  
  if (!args.schemaPath) {
    console.error('‚ùå Erreur: Le param√®tre --schemaPath est requis');
    console.log('Utilisation: node prisma-to-zod.ts --schemaPath=/chemin/vers/schema.prisma --outputDir=/chemin/sortie [--importPrefix=@schemas/] [--withRelations=true] [--splitByModel=true]');
    process.exit(1);
  }
  
  if (!args.outputDir) {
    console.error('‚ùå Erreur: Le param√®tre --outputDir est requis');
    console.log('Utilisation: node prisma-to-zod.ts --schemaPath=/chemin/vers/schema.prisma --outputDir=/chemin/sortie [--importPrefix=@schemas/] [--withRelations=true] [--splitByModel=true]');
    process.exit(1);
  }
  
  const options: CliOptions = {
    schemaPath: args.schemaPath,
    outputDir: args.outputDir,
    importPrefix: args.importPrefix,
    withRelations: args.withRelations === 'true' || args.withRelations === true,
    splitByModel: args.splitByModel === 'true' || args.splitByModel === true
  };
  
  console.log(`üîç G√©n√©ration des sch√©mas Zod √† partir du sch√©ma Prisma: ${options.schemaPath}`);
  
  try {
    const generator = new PrismaToZodGenerator(options);
    await generator.generate();
  } catch (error) {
    console.error('‚ùå Erreur lors de la g√©n√©ration:', error);
    process.exit(1);
  }
}

// Ex√©cution de la fonction principale
if (require.main === module) {
  main();
}

// Export pour les tests et l'utilisation comme module
export { PrismaToZodGenerator };




































































































































































































































































































































