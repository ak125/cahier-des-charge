#!/usr/bin/env node
/**
 * prisma-migration-generator.ts
 *
 * Cet agent g√©n√®re les commandes Prisma n√©cessaires pour la migration bas√©e sur
 * le mod√®le Prisma sugg√©r√© et peut d√©clencher les migrations en fonction des options choisies.
 *
 * Usage: ts-node prisma-migration-generator.ts [options]
 *
 * Options:
 *   --mode=<mode>       Mode de migration (preview, diff, push, migrate)
 *   --schema=<path>     Chemin vers le fichier schema.prisma √† utiliser
 *   --from=<path>       Chemin vers le fichier de mod√®le Prisma sugg√©r√©
 *   --to=<path>         Chemin de destination pour l'int√©gration du schema
 *   --dry-run           Affiche les commandes sans les ex√©cuter
 *   --auto-generate-dto G√©n√®re automatiquement les DTOs NestJS
 */

import { execSync } from 'child_process';
import * as fs from 'fs';
import * as path from 'path';
import chalk from 'chalk';
import { program } from 'commander';

// Configuration de la ligne de commande
program
  .version('1.0.0')
  .description('G√©n√®re et ex√©cute les commandes Prisma pour la migration')
  .option('--mode <mode>', 'Mode de migration (preview, diff, push, migrate)', 'preview')
  .option(
    '--schema <path>',
    'Chemin vers le fichier schema.prisma √† utiliser',
    './prisma/schema.prisma'
  )
  .option(
    '--from <path>',
    'Chemin vers le fichier de mod√®le Prisma sugg√©r√©',
    './reports/latest/prisma_models.suggestion.prisma'
  )
  .option(
    '--to <path>',
    "Chemin de destination pour l'int√©gration du schema",
    './apps/backend/prisma/schema.prisma'
  )
  .option('--dry-run', 'Affiche les commandes sans les ex√©cuter', false)
  .option('--auto-generate-dto', 'G√©n√®re automatiquement les DTOs NestJS', false)
  .parse(process.argv);

const options = program.opts();

// V√©rification des chemins
const fromPath = path.resolve(options.from);
const toPath = path.resolve(options.to);
const schemaPath = path.resolve(options.schema);

/**
 * Fonction principale
 */
async function main() {
  try {
    console.log(chalk.blue('üöÄ D√©marrage du g√©n√©rateur de migration Prisma'));

    // V√©rifier que les fichiers existent
    if (!fs.existsSync(fromPath)) {
      console.error(chalk.red(`‚ùå Erreur: Le fichier ${fromPath} n'existe pas`));
      process.exit(1);
    }

    // En fonction du mode choisi
    switch (options.mode) {
      case 'preview':
        await previewMigration();
        break;
      case 'diff':
        await generateDiff();
        break;
      case 'push':
        await pushSchema();
        break;
      case 'migrate':
        await migrateSchema();
        break;
      default:
        console.error(chalk.red(`‚ùå Mode non reconnu: ${options.mode}`));
        process.exit(1);
    }

    // G√©n√©ration de DTOs si demand√©
    if (options.autoGenerateDto) {
      await generateDtos();
    }

    console.log(chalk.green('‚úÖ Op√©ration termin√©e avec succ√®s'));
  } catch (error) {
    console.error(chalk.red(`‚ùå Erreur: ${error.message}`));
    console.error(error);
    process.exit(1);
  }
}

/**
 * Affiche un aper√ßu de la migration sans appliquer les changements
 */
async function previewMigration() {
  console.log(chalk.blue("üìä G√©n√©ration de l'aper√ßu de la migration..."));

  // Lire le contenu du fichier sugg√©r√©
  const suggestedSchema = fs.readFileSync(fromPath, 'utf8');
  console.log(chalk.gray('Schema Prisma sugg√©r√© charg√©'));

  // Cr√©er une copie temporaire du sch√©ma existant si n√©cessaire
  let tempSchemaPath = '';
  if (fs.existsSync(schemaPath)) {
    tempSchemaPath = `${schemaPath}.backup`;
    fs.copyFileSync(schemaPath, tempSchemaPath);
    console.log(chalk.gray(`Sauvegarde du sch√©ma existant cr√©√©e: ${tempSchemaPath}`));
  }

  try {
    // Copier le sch√©ma sugg√©r√© vers le sch√©ma cible (temporairement)
    fs.writeFileSync(schemaPath, suggestedSchema);
    console.log(chalk.gray(`Schema temporairement √©crit dans: ${schemaPath}`));

    // Ex√©cuter la commande prisma migrate diff
    const command = `npx prisma migrate diff --from-schema-datamodel ${
      tempSchemaPath || 'mysql://url'
    } --to-schema-datamodel ${schemaPath} --pretty`;
    console.log(chalk.blue(`Ex√©cution de: ${command}`));

    if (!options.dryRun) {
      const output = execSync(command).toString();
      console.log(chalk.green('Aper√ßu de la migration:'));
      console.log(output);
    } else {
      console.log(chalk.yellow('[DRY RUN] La commande aurait √©t√© ex√©cut√©e'));
    }
  } finally {
    // Restaurer le sch√©ma original
    if (tempSchemaPath) {
      fs.copyFileSync(tempSchemaPath, schemaPath);
      fs.unlinkSync(tempSchemaPath);
      console.log(chalk.gray('Sch√©ma original restaur√©'));
    }
  }
}

/**
 * G√©n√®re un diff SQL entre le sch√©ma actuel et le sch√©ma cible
 */
async function generateDiff() {
  console.log(chalk.blue('üìù G√©n√©ration du diff SQL...'));

  // Copier le sch√©ma sugg√©r√© vers la destination souhait√©e
  if (options.to !== options.schema) {
    fs.copyFileSync(fromPath, toPath);
    console.log(chalk.gray(`Fichier copi√© de ${fromPath} vers ${toPath}`));
  }

  // Ex√©cuter la commande prisma migrate diff
  const command = `npx prisma migrate diff --from-schema-datasource ${options.schema} --to-schema-datamodel ${toPath} --script > migration.sql`;
  console.log(chalk.blue(`Ex√©cution de: ${command}`));

  if (!options.dryRun) {
    execSync(command);
    console.log(chalk.green('‚úÖ Fichier migration.sql g√©n√©r√© avec succ√®s'));
  } else {
    console.log(chalk.yellow('[DRY RUN] La commande aurait √©t√© ex√©cut√©e'));
  }
}

/**
 * Pousse le sch√©ma directement vers la base de donn√©es sans migration
 */
async function pushSchema() {
  console.log(chalk.blue('üì§ Push du sch√©ma vers la base de donn√©es...'));

  // Copier le sch√©ma sugg√©r√© vers la destination souhait√©e
  fs.copyFileSync(fromPath, toPath);
  console.log(chalk.gray(`Fichier copi√© de ${fromPath} vers ${toPath}`));

  // Ex√©cuter la commande prisma db push
  const command = `npx prisma db push --schema=${toPath} --accept-data-loss`;
  console.log(chalk.blue(`Ex√©cution de: ${command}`));

  if (!options.dryRun) {
    const output = execSync(command).toString();
    console.log(output);
    console.log(chalk.green('‚úÖ Sch√©ma pouss√© avec succ√®s vers la base de donn√©es'));
  } else {
    console.log(chalk.yellow('[DRY RUN] La commande aurait √©t√© ex√©cut√©e'));
  }
}

/**
 * Cr√©e une migration nomm√©e et l'applique
 */
async function migrateSchema() {
  console.log(chalk.blue("üîÑ Cr√©ation d'une migration Prisma..."));

  // Copier le sch√©ma sugg√©r√© vers la destination souhait√©e
  fs.copyFileSync(fromPath, toPath);
  console.log(chalk.gray(`Fichier copi√© de ${fromPath} vers ${toPath}`));

  // G√©n√©rer un nom de migration bas√© sur la date
  const migrationName = `migration_${new Date().toISOString().replace(/[:.]/g, '_').slice(0, 19)}`;

  // Ex√©cuter la commande prisma migrate dev
  const command = `npx prisma migrate dev --schema=${toPath} --name=${migrationName}`;
  console.log(chalk.blue(`Ex√©cution de: ${command}`));

  if (!options.dryRun) {
    const output = execSync(command).toString();
    console.log(output);
    console.log(chalk.green('‚úÖ Migration cr√©√©e et appliqu√©e avec succ√®s'));
  } else {
    console.log(chalk.yellow('[DRY RUN] La commande aurait √©t√© ex√©cut√©e'));
  }
}

/**
 * G√©n√®re les DTOs NestJS √† partir du sch√©ma Prisma
 */
async function generateDtos() {
  console.log(chalk.blue('üìã G√©n√©ration des DTOs NestJS...'));

  // V√©rifier si prisma-nestjs-dto est install√©
  try {
    execSync('npm list -g prisma-nestjs-dto');
  } catch (error) {
    console.log(chalk.yellow('Installation de prisma-nestjs-dto...'));
    if (!options.dryRun) {
      execSync('npm install -g prisma-nestjs-dto');
    } else {
      console.log(chalk.yellow("[DRY RUN] La commande d'installation aurait √©t√© ex√©cut√©e"));
    }
  }

  // Ex√©cuter la commande de g√©n√©ration de DTOs
  const outputDir = './apps/backend/src/dto';
  const command = `prisma-nestjs-dto generate --input ${toPath} --output ${outputDir}`;
  console.log(chalk.blue(`Ex√©cution de: ${command}`));

  if (!options.dryRun) {
    if (!fs.existsSync(outputDir)) {
      fs.mkdirSync(outputDir, { recursive: true });
    }
    const output = execSync(command).toString();
    console.log(output);
    console.log(chalk.green(`‚úÖ DTOs g√©n√©r√©s dans ${outputDir}`));
  } else {
    console.log(chalk.yellow('[DRY RUN] La commande aurait √©t√© ex√©cut√©e'));
  }
}

// Ex√©cuter la fonction principale
main().catch((error) => {
  console.error(chalk.red('Erreur inattendue:'), error);
  process.exit(1);
});
